<!DOCTYPE html>

<html>
<head>
  <title>react-dom.development-doc.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>react-dom.development-doc.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">&#x00a7;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">&#x00a7;</a>
              </div>
              <p>在外部生成<code>ReactDOM</code>对象，并把<code>ReactDOM</code>和<code>React</code>传入<code>factory</code>中</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">global</span>, factory</span>) {
  <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">exports</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">module</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-title function_">factory</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react&#x27;</span>)) :
    <span class="hljs-keyword">typeof</span> define === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="hljs-property">amd</span> ? <span class="hljs-title function_">define</span>([<span class="hljs-string">&#x27;exports&#x27;</span>, <span class="hljs-string">&#x27;react&#x27;</span>], factory) :
      (<span class="hljs-variable language_">global</span> = <span class="hljs-variable language_">global</span> || self, <span class="hljs-title function_">factory</span>(<span class="hljs-variable language_">global</span>.<span class="hljs-property">ReactDOM</span> = {}, <span class="hljs-variable language_">global</span>.<span class="hljs-property">React</span>));
}(<span class="hljs-variable language_">this</span>, (<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">exports</span>, React</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactSharedInternals</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-3">&#x00a7;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-4">&#x00a7;</a>
              </div>
              <p>提取第二个到最后一个参数成为<code>args</code>数组，传入<code>printWarning</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warn</span>(<span class="hljs-params">format</span>) {
    {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>, args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(_len &gt; <span class="hljs-number">1</span> ? _len - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), _key = <span class="hljs-number">1</span>; _key &lt; _len; _key++) {
        args[_key - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">arguments</span>[_key];
      }

      <span class="hljs-title function_">printWarning</span>(<span class="hljs-string">&#x27;warn&#x27;</span>, format, args);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">format</span>) {
    {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _len2 = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>, args = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(_len2 &gt; <span class="hljs-number">1</span> ? _len2 - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>), _key2 = <span class="hljs-number">1</span>; _key2 &lt; _len2; _key2++) {
        args[_key2 - <span class="hljs-number">1</span>] = <span class="hljs-variable language_">arguments</span>[_key2];
      }

      <span class="hljs-title function_">printWarning</span>(<span class="hljs-string">&#x27;error&#x27;</span>, format, args);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-5">&#x00a7;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-6">&#x00a7;</a>
              </div>
              <p>使用<code>console[level]</code>来输出<code>args</code>，<code>format</code>是控制台的样式</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">printWarning</span>(<span class="hljs-params">level, format, args</span>) {
    {
      <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactDebugCurrentFrame</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactDebugCurrentFrame</span>;
      <span class="hljs-keyword">var</span> stack = <span class="hljs-title class_">ReactDebugCurrentFrame</span>.<span class="hljs-title function_">getStackAddendum</span>();

      <span class="hljs-keyword">if</span> (stack !== <span class="hljs-string">&#x27;&#x27;</span>) {
        format += <span class="hljs-string">&#x27;%s&#x27;</span>;
        args = args.<span class="hljs-title function_">concat</span>([stack]);
      }

      <span class="hljs-keyword">var</span> argsWithFormat = args.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span> + item;
      });

      argsWithFormat.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&#x27;Warning: &#x27;</span> + format);

      <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">console</span>[level], <span class="hljs-variable language_">console</span>, argsWithFormat);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-7">&#x00a7;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-8">&#x00a7;</a>
              </div>
              <p>没有提前加载<code>React</code>则抛出错误</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">React</span>) {
    {
      <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.&quot;</span>);
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-9">&#x00a7;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-10">&#x00a7;</a>
              </div>
              <p><code>React</code>的<code>Component</code>类型</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> <span class="hljs-title class_">FunctionComponent</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ClassComponent</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IndeterminateComponent</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// Before we know whether it is function or class</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HostRoot</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// Root of a host tree. Could be nested inside another node.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HostPortal</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// A subtree. Could be an entry point to a different renderer.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HostComponent</span> = <span class="hljs-number">5</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HostText</span> = <span class="hljs-number">6</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Fragment</span> = <span class="hljs-number">7</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Mode</span> = <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ContextConsumer</span> = <span class="hljs-number">9</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ContextProvider</span> = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ForwardRef</span> = <span class="hljs-number">11</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Profiler</span> = <span class="hljs-number">12</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SuspenseComponent</span> = <span class="hljs-number">13</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">MemoComponent</span> = <span class="hljs-number">14</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SimpleMemoComponent</span> = <span class="hljs-number">15</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LazyComponent</span> = <span class="hljs-number">16</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IncompleteClassComponent</span> = <span class="hljs-number">17</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DehydratedFragment</span> = <span class="hljs-number">18</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SuspenseListComponent</span> = <span class="hljs-number">19</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">FundamentalComponent</span> = <span class="hljs-number">20</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ScopeComponent</span> = <span class="hljs-number">21</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Block</span> = <span class="hljs-number">22</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">OffscreenComponent</span> = <span class="hljs-number">23</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LegacyHiddenComponent</span> = <span class="hljs-number">24</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-11">&#x00a7;</a>
              </div>
              <p>Filter certain DOM attributes (e.g. src, href) if their values are empty strings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> enableProfilerTimer = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Record durations for commit and passive effects phases.</span>

  <span class="hljs-keyword">var</span> enableFundamentalAPI = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Experimental Scope support.</span>
  <span class="hljs-keyword">var</span> enableNewReconciler = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Errors that are thrown while unmounting (or after in the case of passive effects)</span>
  <span class="hljs-keyword">var</span> warnAboutStringRefs = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">var</span> allNativeEvents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  <span class="hljs-comment">/**
   * Mapping from registration name to event name
   */</span>


  <span class="hljs-keyword">var</span> registrationNameDependencies = {};
  <span class="hljs-comment">/**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in true.
   * <span class="hljs-doctag">@type</span> {<span class="hljs-type">Object</span>}
   */</span>

  <span class="hljs-keyword">var</span> possibleRegistrationNames = {}; <span class="hljs-comment">// Trust the developer to only use possibleRegistrationNames in true</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerTwoPhaseEvent</span>(<span class="hljs-params">registrationName, dependencies</span>) {
    <span class="hljs-title function_">registerDirectEvent</span>(registrationName, dependencies);
    <span class="hljs-title function_">registerDirectEvent</span>(registrationName + <span class="hljs-string">&#x27;Capture&#x27;</span>, dependencies);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerDirectEvent</span>(<span class="hljs-params">registrationName, dependencies</span>) {
    {
      <span class="hljs-keyword">if</span> (registrationNameDependencies[registrationName]) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;EventRegistry: More than one plugin attempted to publish the same &#x27;</span> + <span class="hljs-string">&#x27;registration name, `%s`.&#x27;</span>, registrationName);
      }
    }

    registrationNameDependencies[registrationName] = dependencies;

    {
      <span class="hljs-keyword">var</span> lowerCasedName = registrationName.<span class="hljs-title function_">toLowerCase</span>();
      possibleRegistrationNames[lowerCasedName] = registrationName;

      <span class="hljs-keyword">if</span> (registrationName === <span class="hljs-string">&#x27;onDoubleClick&#x27;</span>) {
        possibleRegistrationNames.<span class="hljs-property">ondblclick</span> = registrationName;
      }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dependencies.<span class="hljs-property">length</span>; i++) {
      allNativeEvents.<span class="hljs-title function_">add</span>(dependencies[i]);
    }
  }

  <span class="hljs-keyword">var</span> canUseDOM = !!(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">document</span>.<span class="hljs-property">createElement</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-12">&#x00a7;</a>
              </div>
              <p>A reserved attribute.
It is handled by React separately and shouldn’t be written to the DOM.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">RESERVED</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// A simple string attribute.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-13">&#x00a7;</a>
              </div>
              <p>Attributes that aren’t in the filter are presumed to have this type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">STRING</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// A string attribute that accepts booleans in React. In HTML, these are called</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-14">&#x00a7;</a>
              </div>
              <p>“enumerated” attributes with “true” and “false” as possible values.
When true, it should be set to a “true” string.
When false, it should be set to a “false” string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">BOOLEANISH_STRING</span> = <span class="hljs-number">2</span>; <span class="hljs-comment">// A real boolean attribute.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-15">&#x00a7;</a>
              </div>
              <p>When true, it should be present (set either to an empty string or its name).
When false, it should be omitted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">BOOLEAN</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// An attribute that can be used as a flag as well as with a value.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-16">&#x00a7;</a>
              </div>
              <p>When true, it should be present (set either to an empty string or its name).
When false, it should be omitted.
For any other value, should be present with that value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">OVERLOADED_BOOLEAN</span> = <span class="hljs-number">4</span>; <span class="hljs-comment">// An attribute that must be numeric or parse as a numeric.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-17">&#x00a7;</a>
              </div>
              <p>When falsy, it should be removed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NUMERIC</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// An attribute that must be positive numeric or parse as a positive numeric.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-18">&#x00a7;</a>
              </div>
              <p>When falsy, it should be removed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">POSITIVE_NUMERIC</span> = <span class="hljs-number">6</span>;

  <span class="hljs-comment">/* eslint-disable max-len */</span>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ATTRIBUTE_NAME_START_CHAR</span> = <span class="hljs-string">&quot;:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD&quot;</span>;
  <span class="hljs-comment">/* eslint-enable max-len */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ATTRIBUTE_NAME_CHAR</span> = <span class="hljs-variable constant_">ATTRIBUTE_NAME_START_CHAR</span> + <span class="hljs-string">&quot;\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040&quot;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ROOT_ATTRIBUTE_NAME</span> = <span class="hljs-string">&#x27;data-reactroot&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">VALID_ATTRIBUTE_NAME_REGEX</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;^[&#x27;</span> + <span class="hljs-variable constant_">ATTRIBUTE_NAME_START_CHAR</span> + <span class="hljs-string">&#x27;][&#x27;</span> + <span class="hljs-variable constant_">ATTRIBUTE_NAME_CHAR</span> + <span class="hljs-string">&#x27;]*$&#x27;</span>);
  <span class="hljs-keyword">var</span> hasOwnProperty = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>;
  <span class="hljs-keyword">var</span> illegalAttributeNameCache = {};
  <span class="hljs-keyword">var</span> validatedAttributeNameCache = {};
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isAttributeNameSafe</span>(<span class="hljs-params">attributeName</span>) {
    <span class="hljs-keyword">if</span> (hasOwnProperty.<span class="hljs-title function_">call</span>(validatedAttributeNameCache, attributeName)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (hasOwnProperty.<span class="hljs-title function_">call</span>(illegalAttributeNameCache, attributeName)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">VALID_ATTRIBUTE_NAME_REGEX</span>.<span class="hljs-title function_">test</span>(attributeName)) {
      validatedAttributeNameCache[attributeName] = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    illegalAttributeNameCache[attributeName] = <span class="hljs-literal">true</span>;

    {
      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid attribute name: `%s`&#x27;</span>, attributeName);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldIgnoreAttribute</span>(<span class="hljs-params">name, propertyInfo, isCustomComponentTag</span>) {
    <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> propertyInfo.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">RESERVED</span>;
    }

    <span class="hljs-keyword">if</span> (isCustomComponentTag) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (name.<span class="hljs-property">length</span> &gt; <span class="hljs-number">2</span> &amp;&amp; (name[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;o&#x27;</span> || name[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;O&#x27;</span>) &amp;&amp; (name[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;n&#x27;</span> || name[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;N&#x27;</span>)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldRemoveAttributeWithWarning</span>(<span class="hljs-params">name, value, propertyInfo, isCustomComponentTag</span>) {
    <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span> &amp;&amp; propertyInfo.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">RESERVED</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> value) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;function&#x27;</span>: <span class="hljs-comment">// $FlowIssue symbol is perfectly valid here</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;symbol&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-19">&#x00a7;</a>
              </div>
              <p>eslint-disable-line</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;boolean&#x27;</span>:
        {
          <span class="hljs-keyword">if</span> (isCustomComponentTag) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
          }

          <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> !propertyInfo.<span class="hljs-property">acceptsBooleans</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> prefix = name.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
            <span class="hljs-keyword">return</span> prefix !== <span class="hljs-string">&#x27;data-&#x27;</span> &amp;&amp; prefix !== <span class="hljs-string">&#x27;aria-&#x27;</span>;
          }
        }

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldRemoveAttribute</span>(<span class="hljs-params">name, value, propertyInfo, isCustomComponentTag</span>) {
    <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;undefined&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldRemoveAttributeWithWarning</span>(name, value, propertyInfo, isCustomComponentTag)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (isCustomComponentTag) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {

      <span class="hljs-keyword">switch</span> (propertyInfo.<span class="hljs-property">type</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-attr">BOOLEAN</span>:
          <span class="hljs-keyword">return</span> !value;

        <span class="hljs-keyword">case</span> <span class="hljs-attr">OVERLOADED_BOOLEAN</span>:
          <span class="hljs-keyword">return</span> value === <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-attr">NUMERIC</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(value);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">POSITIVE_NUMERIC</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">isNaN</span>(value) || value &lt; <span class="hljs-number">1</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPropertyInfo</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">return</span> properties.<span class="hljs-title function_">hasOwnProperty</span>(name) ? properties[name] : <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">PropertyInfoRecord</span>(<span class="hljs-params">name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">acceptsBooleans</span> = type === <span class="hljs-variable constant_">BOOLEANISH_STRING</span> || type === <span class="hljs-variable constant_">BOOLEAN</span> || type === <span class="hljs-variable constant_">OVERLOADED_BOOLEAN</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">attributeName</span> = attributeName;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">attributeNamespace</span> = attributeNamespace;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mustUseProperty</span> = mustUseProperty;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">propertyName</span> = name;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = type;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sanitizeURL</span> = sanitizeURL;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">removeEmptyString</span> = removeEmptyString;
  } <span class="hljs-comment">// When adding attributes to this list, be sure to also add them to</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-20">&#x00a7;</a>
              </div>
              <p>the <code>possibleStandardNames</code> module to ensure casing and incorrect
name warnings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">var</span> properties = {}; <span class="hljs-comment">// These props are reserved by React. They shouldn&#x27;t be written to the DOM.</span>

  <span class="hljs-keyword">var</span> reservedProps = [<span class="hljs-string">&#x27;children&#x27;</span>, <span class="hljs-string">&#x27;dangerouslySetInnerHTML&#x27;</span>, <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This prevents the assignment of defaultValue to regular</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-21">&#x00a7;</a>
              </div>
              <p>elements (not just inputs). Now that ReactDOMInput assigns to the
defaultValue property – do we need this?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;defaultValue&#x27;</span>, <span class="hljs-string">&#x27;defaultChecked&#x27;</span>, <span class="hljs-string">&#x27;innerHTML&#x27;</span>, <span class="hljs-string">&#x27;suppressContentEditableWarning&#x27;</span>, <span class="hljs-string">&#x27;suppressHydrationWarning&#x27;</span>, <span class="hljs-string">&#x27;style&#x27;</span>];
  reservedProps.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">RESERVED</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// A few React string attributes have a different name.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-22">&#x00a7;</a>
              </div>
              <p>This is a mapping from React prop names to the attribute names.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  [[<span class="hljs-string">&#x27;acceptCharset&#x27;</span>, <span class="hljs-string">&#x27;accept-charset&#x27;</span>], [<span class="hljs-string">&#x27;className&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>], [<span class="hljs-string">&#x27;htmlFor&#x27;</span>, <span class="hljs-string">&#x27;for&#x27;</span>], [<span class="hljs-string">&#x27;httpEquiv&#x27;</span>, <span class="hljs-string">&#x27;http-equiv&#x27;</span>]].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">_ref</span>) {
    <span class="hljs-keyword">var</span> name = _ref[<span class="hljs-number">0</span>],
      attributeName = _ref[<span class="hljs-number">1</span>];
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These are &quot;enumerated&quot; HTML attributes that accept &quot;true&quot; and &quot;false&quot;.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-23">&#x00a7;</a>
              </div>
              <p>In React, we let users pass <code>true</code> and <code>false</code> even though technically
these aren’t boolean attributes (they are coerced to strings).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  [<span class="hljs-string">&#x27;contentEditable&#x27;</span>, <span class="hljs-string">&#x27;draggable&#x27;</span>, <span class="hljs-string">&#x27;spellCheck&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">BOOLEANISH_STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name.<span class="hljs-title function_">toLowerCase</span>(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These are &quot;enumerated&quot; SVG attributes that accept &quot;true&quot; and &quot;false&quot;.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-24">&#x00a7;</a>
              </div>
              <p>In React, we let users pass <code>true</code> and <code>false</code> even though technically
these aren’t boolean attributes (they are coerced to strings).
Since these are SVG attributes, their attribute names are case-sensitive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  [<span class="hljs-string">&#x27;autoReverse&#x27;</span>, <span class="hljs-string">&#x27;externalResourcesRequired&#x27;</span>, <span class="hljs-string">&#x27;focusable&#x27;</span>, <span class="hljs-string">&#x27;preserveAlpha&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">BOOLEANISH_STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These are HTML boolean attributes.</span>

  [<span class="hljs-string">&#x27;allowFullScreen&#x27;</span>, <span class="hljs-string">&#x27;async&#x27;</span>, <span class="hljs-comment">// Note: there is a special case that prevents it from being written to the DOM</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-25">&#x00a7;</a>
              </div>
              <p>on the client side because the browsers are inconsistent. Instead we call focus().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;autoFocus&#x27;</span>, <span class="hljs-string">&#x27;autoPlay&#x27;</span>, <span class="hljs-string">&#x27;controls&#x27;</span>, <span class="hljs-string">&#x27;default&#x27;</span>, <span class="hljs-string">&#x27;defer&#x27;</span>, <span class="hljs-string">&#x27;disabled&#x27;</span>, <span class="hljs-string">&#x27;disablePictureInPicture&#x27;</span>, <span class="hljs-string">&#x27;disableRemotePlayback&#x27;</span>, <span class="hljs-string">&#x27;formNoValidate&#x27;</span>, <span class="hljs-string">&#x27;hidden&#x27;</span>, <span class="hljs-string">&#x27;loop&#x27;</span>, <span class="hljs-string">&#x27;noModule&#x27;</span>, <span class="hljs-string">&#x27;noValidate&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;playsInline&#x27;</span>, <span class="hljs-string">&#x27;readOnly&#x27;</span>, <span class="hljs-string">&#x27;required&#x27;</span>, <span class="hljs-string">&#x27;reversed&#x27;</span>, <span class="hljs-string">&#x27;scoped&#x27;</span>, <span class="hljs-string">&#x27;seamless&#x27;</span>, <span class="hljs-comment">// Microdata</span>
    <span class="hljs-string">&#x27;itemScope&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
      properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">BOOLEAN</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
        name.<span class="hljs-title function_">toLowerCase</span>(), <span class="hljs-comment">// attributeName</span>
        <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
        <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
        <span class="hljs-literal">false</span>);
    }); <span class="hljs-comment">// These are the few React props that we set as DOM properties</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-26">&#x00a7;</a>
              </div>
              <p>rather than attributes. These are all booleans.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  [<span class="hljs-string">&#x27;checked&#x27;</span>, <span class="hljs-comment">// Note: `option.selected` is not updated if `select.multiple` is</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-27">&#x00a7;</a>
              </div>
              <p>disabled with <code>removeAttribute</code>. We have special logic for handling this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;multiple&#x27;</span>, <span class="hljs-string">&#x27;muted&#x27;</span>, <span class="hljs-string">&#x27;selected&#x27;</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-28">&#x00a7;</a>
              </div>
              <p>you’ll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">BOOLEAN</span>, <span class="hljs-literal">true</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These are HTML attributes that are &quot;overloaded booleans&quot;: they behave like</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-29">&#x00a7;</a>
              </div>
              <p>booleans, but can also accept a string value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  [<span class="hljs-string">&#x27;capture&#x27;</span>, <span class="hljs-string">&#x27;download&#x27;</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-30">&#x00a7;</a>
              </div>
              <p>you’ll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">OVERLOADED_BOOLEAN</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These are HTML attributes that must be positive numbers.</span>

  [<span class="hljs-string">&#x27;cols&#x27;</span>, <span class="hljs-string">&#x27;rows&#x27;</span>, <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;span&#x27;</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-31">&#x00a7;</a>
              </div>
              <p>you’ll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">POSITIVE_NUMERIC</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name, <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These are HTML attributes that must be numbers.</span>

  [<span class="hljs-string">&#x27;rowSpan&#x27;</span>, <span class="hljs-string">&#x27;start&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">NUMERIC</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      name.<span class="hljs-title function_">toLowerCase</span>(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  });
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">CAMELIZE</span> = <span class="hljs-regexp">/[\-\:]([a-z])/g</span>;

  <span class="hljs-keyword">var</span> capitalize = <span class="hljs-keyword">function</span> (<span class="hljs-params">token</span>) {
    <span class="hljs-keyword">return</span> token[<span class="hljs-number">1</span>].<span class="hljs-title function_">toUpperCase</span>();
  }; <span class="hljs-comment">// This is a list of all SVG attributes that need special casing, namespacing,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-32">&#x00a7;</a>
              </div>
              <p>or boolean value assignment. Regular attributes that just accept strings
and have the same names are omitted, just like in the HTML attribute filter.
Some of these attributes can be hard to find. This list was created by
scraping the MDN documentation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  [<span class="hljs-string">&#x27;accent-height&#x27;</span>, <span class="hljs-string">&#x27;alignment-baseline&#x27;</span>, <span class="hljs-string">&#x27;arabic-form&#x27;</span>, <span class="hljs-string">&#x27;baseline-shift&#x27;</span>, <span class="hljs-string">&#x27;cap-height&#x27;</span>, <span class="hljs-string">&#x27;clip-path&#x27;</span>, <span class="hljs-string">&#x27;clip-rule&#x27;</span>, <span class="hljs-string">&#x27;color-interpolation&#x27;</span>, <span class="hljs-string">&#x27;color-interpolation-filters&#x27;</span>, <span class="hljs-string">&#x27;color-profile&#x27;</span>, <span class="hljs-string">&#x27;color-rendering&#x27;</span>, <span class="hljs-string">&#x27;dominant-baseline&#x27;</span>, <span class="hljs-string">&#x27;enable-background&#x27;</span>, <span class="hljs-string">&#x27;fill-opacity&#x27;</span>, <span class="hljs-string">&#x27;fill-rule&#x27;</span>, <span class="hljs-string">&#x27;flood-color&#x27;</span>, <span class="hljs-string">&#x27;flood-opacity&#x27;</span>, <span class="hljs-string">&#x27;font-family&#x27;</span>, <span class="hljs-string">&#x27;font-size&#x27;</span>, <span class="hljs-string">&#x27;font-size-adjust&#x27;</span>, <span class="hljs-string">&#x27;font-stretch&#x27;</span>, <span class="hljs-string">&#x27;font-style&#x27;</span>, <span class="hljs-string">&#x27;font-variant&#x27;</span>, <span class="hljs-string">&#x27;font-weight&#x27;</span>, <span class="hljs-string">&#x27;glyph-name&#x27;</span>, <span class="hljs-string">&#x27;glyph-orientation-horizontal&#x27;</span>, <span class="hljs-string">&#x27;glyph-orientation-vertical&#x27;</span>, <span class="hljs-string">&#x27;horiz-adv-x&#x27;</span>, <span class="hljs-string">&#x27;horiz-origin-x&#x27;</span>, <span class="hljs-string">&#x27;image-rendering&#x27;</span>, <span class="hljs-string">&#x27;letter-spacing&#x27;</span>, <span class="hljs-string">&#x27;lighting-color&#x27;</span>, <span class="hljs-string">&#x27;marker-end&#x27;</span>, <span class="hljs-string">&#x27;marker-mid&#x27;</span>, <span class="hljs-string">&#x27;marker-start&#x27;</span>, <span class="hljs-string">&#x27;overline-position&#x27;</span>, <span class="hljs-string">&#x27;overline-thickness&#x27;</span>, <span class="hljs-string">&#x27;paint-order&#x27;</span>, <span class="hljs-string">&#x27;panose-1&#x27;</span>, <span class="hljs-string">&#x27;pointer-events&#x27;</span>, <span class="hljs-string">&#x27;rendering-intent&#x27;</span>, <span class="hljs-string">&#x27;shape-rendering&#x27;</span>, <span class="hljs-string">&#x27;stop-color&#x27;</span>, <span class="hljs-string">&#x27;stop-opacity&#x27;</span>, <span class="hljs-string">&#x27;strikethrough-position&#x27;</span>, <span class="hljs-string">&#x27;strikethrough-thickness&#x27;</span>, <span class="hljs-string">&#x27;stroke-dasharray&#x27;</span>, <span class="hljs-string">&#x27;stroke-dashoffset&#x27;</span>, <span class="hljs-string">&#x27;stroke-linecap&#x27;</span>, <span class="hljs-string">&#x27;stroke-linejoin&#x27;</span>, <span class="hljs-string">&#x27;stroke-miterlimit&#x27;</span>, <span class="hljs-string">&#x27;stroke-opacity&#x27;</span>, <span class="hljs-string">&#x27;stroke-width&#x27;</span>, <span class="hljs-string">&#x27;text-anchor&#x27;</span>, <span class="hljs-string">&#x27;text-decoration&#x27;</span>, <span class="hljs-string">&#x27;text-rendering&#x27;</span>, <span class="hljs-string">&#x27;underline-position&#x27;</span>, <span class="hljs-string">&#x27;underline-thickness&#x27;</span>, <span class="hljs-string">&#x27;unicode-bidi&#x27;</span>, <span class="hljs-string">&#x27;unicode-range&#x27;</span>, <span class="hljs-string">&#x27;units-per-em&#x27;</span>, <span class="hljs-string">&#x27;v-alphabetic&#x27;</span>, <span class="hljs-string">&#x27;v-hanging&#x27;</span>, <span class="hljs-string">&#x27;v-ideographic&#x27;</span>, <span class="hljs-string">&#x27;v-mathematical&#x27;</span>, <span class="hljs-string">&#x27;vector-effect&#x27;</span>, <span class="hljs-string">&#x27;vert-adv-y&#x27;</span>, <span class="hljs-string">&#x27;vert-origin-x&#x27;</span>, <span class="hljs-string">&#x27;vert-origin-y&#x27;</span>, <span class="hljs-string">&#x27;word-spacing&#x27;</span>, <span class="hljs-string">&#x27;writing-mode&#x27;</span>, <span class="hljs-string">&#x27;xmlns:xlink&#x27;</span>, <span class="hljs-string">&#x27;x-height&#x27;</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-33">&#x00a7;</a>
              </div>
              <p>you’ll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) {
    <span class="hljs-keyword">var</span> name = attributeName.<span class="hljs-title function_">replace</span>(<span class="hljs-variable constant_">CAMELIZE</span>, capitalize);
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// String SVG attributes with the xlink namespace.</span>

  [<span class="hljs-string">&#x27;xlink:actuate&#x27;</span>, <span class="hljs-string">&#x27;xlink:arcrole&#x27;</span>, <span class="hljs-string">&#x27;xlink:role&#x27;</span>, <span class="hljs-string">&#x27;xlink:show&#x27;</span>, <span class="hljs-string">&#x27;xlink:title&#x27;</span>, <span class="hljs-string">&#x27;xlink:type&#x27;</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-34">&#x00a7;</a>
              </div>
              <p>you’ll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) {
    <span class="hljs-keyword">var</span> name = attributeName.<span class="hljs-title function_">replace</span>(<span class="hljs-variable constant_">CAMELIZE</span>, capitalize);
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-string">&#x27;http://www.w3.org/1999/xlink&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// String SVG attributes with the xml namespace.</span>

  [<span class="hljs-string">&#x27;xml:base&#x27;</span>, <span class="hljs-string">&#x27;xml:lang&#x27;</span>, <span class="hljs-string">&#x27;xml:space&#x27;</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> if you add a camelCased prop to this list,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-35">&#x00a7;</a>
              </div>
              <p>you’ll need to set attributeName to name.toLowerCase()
instead in the assignment below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  ].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) {
    <span class="hljs-keyword">var</span> name = attributeName.<span class="hljs-title function_">replace</span>(<span class="hljs-variable constant_">CAMELIZE</span>, capitalize);
    properties[name] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(name, <span class="hljs-variable constant_">STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName, <span class="hljs-string">&#x27;http://www.w3.org/XML/1998/namespace&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These attribute exists both in HTML and SVG.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-36">&#x00a7;</a>
              </div>
              <p>The attribute name is case-sensitive in SVG so we can’t just use
the React name like we do for attributes that exist only in HTML.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  [<span class="hljs-string">&#x27;tabIndex&#x27;</span>, <span class="hljs-string">&#x27;crossOrigin&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) {
    properties[attributeName] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(attributeName, <span class="hljs-variable constant_">STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName.<span class="hljs-title function_">toLowerCase</span>(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">false</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">false</span>);
  }); <span class="hljs-comment">// These attributes accept URLs. These must not allow javascript: URLS.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-37">&#x00a7;</a>
              </div>
              <p>These will also need to accept Trusted Types object in the future.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> xlinkHref = <span class="hljs-string">&#x27;xlinkHref&#x27;</span>;
  properties[xlinkHref] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(<span class="hljs-string">&#x27;xlinkHref&#x27;</span>, <span class="hljs-variable constant_">STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
    <span class="hljs-string">&#x27;xlink:href&#x27;</span>, <span class="hljs-string">&#x27;http://www.w3.org/1999/xlink&#x27;</span>, <span class="hljs-literal">true</span>, <span class="hljs-comment">// sanitizeURL</span>
    <span class="hljs-literal">false</span>);
  [<span class="hljs-string">&#x27;src&#x27;</span>, <span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&#x27;action&#x27;</span>, <span class="hljs-string">&#x27;formAction&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">attributeName</span>) {
    properties[attributeName] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyInfoRecord</span>(attributeName, <span class="hljs-variable constant_">STRING</span>, <span class="hljs-literal">false</span>, <span class="hljs-comment">// mustUseProperty</span>
      attributeName.<span class="hljs-title function_">toLowerCase</span>(), <span class="hljs-comment">// attributeName</span>
      <span class="hljs-literal">null</span>, <span class="hljs-comment">// attributeNamespace</span>
      <span class="hljs-literal">true</span>, <span class="hljs-comment">// sanitizeURL</span>
      <span class="hljs-literal">true</span>);
  });</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-38">&#x00a7;</a>
              </div>
              <p>and any newline or tab are filtered out as if they’re not part of the URL.
<a href="https://url.spec.whatwg.org/#url-parsing">https://url.spec.whatwg.org/#url-parsing</a>
Tab or newline are defined as \r\n\t:
<a href="https://infra.spec.whatwg.org/#ascii-tab-or-newline">https://infra.spec.whatwg.org/#ascii-tab-or-newline</a>
A C0 control is a code point in the range \u0000 NULL to \u001F
INFORMATION SEPARATOR ONE, inclusive:
<a href="https://infra.spec.whatwg.org/#c0-control-or-space">https://infra.spec.whatwg.org/#c0-control-or-space</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-comment">/* eslint-disable max-len */</span>

  <span class="hljs-keyword">var</span> isJavaScriptProtocol = <span class="hljs-regexp">/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i</span>;
  <span class="hljs-keyword">var</span> didWarn = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">sanitizeURL</span>(<span class="hljs-params">url</span>) {
    {
      <span class="hljs-keyword">if</span> (!didWarn &amp;&amp; isJavaScriptProtocol.<span class="hljs-title function_">test</span>(url)) {
        didWarn = <span class="hljs-literal">true</span>;

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A future version of React will block javascript: URLs as a security precaution. &#x27;</span> + <span class="hljs-string">&#x27;Use event handlers instead if you can. If you need to generate unsafe HTML try &#x27;</span> + <span class="hljs-string">&#x27;using dangerouslySetInnerHTML instead. React was passed %s.&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(url));
      }
    }
  }

  <span class="hljs-comment">/**
   * Get the value for a property on a node. Only used in DEV for SSR validation.
   * The &quot;expected&quot; argument is used as a hint of what the expected value is.
   * Some properties have multiple equivalent values.
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getValueForProperty</span>(<span class="hljs-params">node, name, expected, propertyInfo</span>) {
    {
      <span class="hljs-keyword">if</span> (propertyInfo.<span class="hljs-property">mustUseProperty</span>) {
        <span class="hljs-keyword">var</span> propertyName = propertyInfo.<span class="hljs-property">propertyName</span>;
        <span class="hljs-keyword">return</span> node[propertyName];
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (propertyInfo.<span class="hljs-property">sanitizeURL</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-39">&#x00a7;</a>
              </div>
              <p>If we haven’t fully disabled javascript: URLs, and if
the hydration is successful of a javascript: URL, we
still want to warn on the client.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">sanitizeURL</span>(<span class="hljs-string">&#x27;&#x27;</span> + expected);
        }

        <span class="hljs-keyword">var</span> attributeName = propertyInfo.<span class="hljs-property">attributeName</span>;
        <span class="hljs-keyword">var</span> stringValue = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (propertyInfo.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">OVERLOADED_BOOLEAN</span>) {
          <span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasAttribute</span>(attributeName)) {
            <span class="hljs-keyword">var</span> value = node.<span class="hljs-title function_">getAttribute</span>(attributeName);

            <span class="hljs-keyword">if</span> (value === <span class="hljs-string">&#x27;&#x27;</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldRemoveAttribute</span>(name, expected, propertyInfo, <span class="hljs-literal">false</span>)) {
              <span class="hljs-keyword">return</span> value;
            }

            <span class="hljs-keyword">if</span> (value === <span class="hljs-string">&#x27;&#x27;</span> + expected) {
              <span class="hljs-keyword">return</span> expected;
            }

            <span class="hljs-keyword">return</span> value;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasAttribute</span>(attributeName)) {
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldRemoveAttribute</span>(name, expected, propertyInfo, <span class="hljs-literal">false</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-40">&#x00a7;</a>
              </div>
              <p>We had an attribute but shouldn’t have had one, so read it
for the error message.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> node.<span class="hljs-title function_">getAttribute</span>(attributeName);
          }

          <span class="hljs-keyword">if</span> (propertyInfo.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">BOOLEAN</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-41">&#x00a7;</a>
              </div>
              <p>If this was a boolean, it doesn’t matter what the value is
the fact that we have it is the same as the expected.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> expected;
          } <span class="hljs-comment">// Even if this property uses a namespace we use getAttribute</span></pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-42">&#x00a7;</a>
              </div>
              <p>because we assume its namespaced name is the same as our config.
To use getAttributeNS we need the local name which we don’t have
in our config atm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          stringValue = node.<span class="hljs-title function_">getAttribute</span>(attributeName);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldRemoveAttribute</span>(name, expected, propertyInfo, <span class="hljs-literal">false</span>)) {
          <span class="hljs-keyword">return</span> stringValue === <span class="hljs-literal">null</span> ? expected : stringValue;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stringValue === <span class="hljs-string">&#x27;&#x27;</span> + expected) {
          <span class="hljs-keyword">return</span> expected;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> stringValue;
        }
      }
    }
  }
  <span class="hljs-comment">/**
   * Get the value for a attribute on a node. Only used in DEV for SSR validation.
   * The third argument is used as a hint of what the expected value is. Some
   * attributes have multiple equivalent values.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getValueForAttribute</span>(<span class="hljs-params">node, name, expected</span>) {
    {
      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isAttributeNameSafe</span>(name)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// If the object is an opaque reference ID, it&#x27;s expected that</span></pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-43">&#x00a7;</a>
              </div>
              <p>the next prop is different than the server value, so just return
expected</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isOpaqueHydratingObject</span>(expected)) {
        <span class="hljs-keyword">return</span> expected;
      }

      <span class="hljs-keyword">if</span> (!node.<span class="hljs-title function_">hasAttribute</span>(name)) {
        <span class="hljs-keyword">return</span> expected === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">undefined</span> : <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> value = node.<span class="hljs-title function_">getAttribute</span>(name);

      <span class="hljs-keyword">if</span> (value === <span class="hljs-string">&#x27;&#x27;</span> + expected) {
        <span class="hljs-keyword">return</span> expected;
      }

      <span class="hljs-keyword">return</span> value;
    }
  }
  <span class="hljs-comment">/**
   * Sets the value for a property on a node.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement</span>} <span class="hljs-variable">node</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">name</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} <span class="hljs-variable">value</span>
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setValueForProperty</span>(<span class="hljs-params">node, name, value, isCustomComponentTag</span>) {
    <span class="hljs-keyword">var</span> propertyInfo = <span class="hljs-title function_">getPropertyInfo</span>(name);

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldIgnoreAttribute</span>(name, propertyInfo, isCustomComponentTag)) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldRemoveAttribute</span>(name, value, propertyInfo, isCustomComponentTag)) {
      value = <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// If the prop isn&#x27;t in the special list, treat it as a simple attribute.</span>


    <span class="hljs-keyword">if</span> (isCustomComponentTag || propertyInfo === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAttributeNameSafe</span>(name)) {
        <span class="hljs-keyword">var</span> _attributeName = name;

        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
          node.<span class="hljs-title function_">removeAttribute</span>(_attributeName);
        } <span class="hljs-keyword">else</span> {
          node.<span class="hljs-title function_">setAttribute</span>(_attributeName, <span class="hljs-string">&#x27;&#x27;</span> + value);
        }
      }

      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> mustUseProperty = propertyInfo.<span class="hljs-property">mustUseProperty</span>;

    <span class="hljs-keyword">if</span> (mustUseProperty) {
      <span class="hljs-keyword">var</span> propertyName = propertyInfo.<span class="hljs-property">propertyName</span>;

      <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> type = propertyInfo.<span class="hljs-property">type</span>;
        node[propertyName] = type === <span class="hljs-variable constant_">BOOLEAN</span> ? <span class="hljs-literal">false</span> : <span class="hljs-string">&#x27;&#x27;</span>;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-44">&#x00a7;</a>
              </div>
              <p>Contrary to <code>setAttribute</code>, object properties are properly
<code>toString</code>ed by IE8/9.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        node[propertyName] = value;
      }

      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// The rest are treated as attributes with special cases.</span>


    <span class="hljs-keyword">var</span> attributeName = propertyInfo.<span class="hljs-property">attributeName</span>,
      attributeNamespace = propertyInfo.<span class="hljs-property">attributeNamespace</span>;

    <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
      node.<span class="hljs-title function_">removeAttribute</span>(attributeName);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> _type = propertyInfo.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">var</span> attributeValue;

      <span class="hljs-keyword">if</span> (_type === <span class="hljs-variable constant_">BOOLEAN</span> || _type === <span class="hljs-variable constant_">OVERLOADED_BOOLEAN</span> &amp;&amp; value === <span class="hljs-literal">true</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-45">&#x00a7;</a>
              </div>
              <p>If attribute type is boolean, we know for sure it won’t be an execution sink
and we won’t require Trusted Type here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        attributeValue = <span class="hljs-string">&#x27;&#x27;</span>;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-46">&#x00a7;</a>
              </div>
              <p><code>setAttribute</code> with objects becomes only <code>[object]</code> in IE8/9,
(‘’ + value) makes it output the correct toString()-value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        {
          attributeValue = <span class="hljs-string">&#x27;&#x27;</span> + value;
        }

        <span class="hljs-keyword">if</span> (propertyInfo.<span class="hljs-property">sanitizeURL</span>) {
          <span class="hljs-title function_">sanitizeURL</span>(attributeValue.<span class="hljs-title function_">toString</span>());
        }
      }

      <span class="hljs-keyword">if</span> (attributeNamespace) {
        node.<span class="hljs-title function_">setAttributeNS</span>(attributeNamespace, attributeName, attributeValue);
      } <span class="hljs-keyword">else</span> {
        node.<span class="hljs-title function_">setAttribute</span>(attributeName, attributeValue);
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactInternals</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>;
  <span class="hljs-keyword">var</span> _assign = <span class="hljs-title class_">ReactInternals</span>.<span class="hljs-property">assign</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-47">&#x00a7;</a>
              </div>
              <p>ATTENTION
When adding new symbols to this file,
Please consider also adding to ‘react-devtools-shared/src/backend/ReactSymbols’
The Symbol used to tag the ReactElement-like types. If there is no native Symbol
nor polyfill, then a plain number is used for performance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_ELEMENT_TYPE</span> = <span class="hljs-number">0xeac7</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_PORTAL_TYPE</span> = <span class="hljs-number">0xeaca</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span> = <span class="hljs-number">0xeacb</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_STRICT_MODE_TYPE</span> = <span class="hljs-number">0xeacc</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_PROFILER_TYPE</span> = <span class="hljs-number">0xead2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_PROVIDER_TYPE</span> = <span class="hljs-number">0xeacd</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_CONTEXT_TYPE</span> = <span class="hljs-number">0xeace</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_FORWARD_REF_TYPE</span> = <span class="hljs-number">0xead0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_SUSPENSE_TYPE</span> = <span class="hljs-number">0xead1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_SUSPENSE_LIST_TYPE</span> = <span class="hljs-number">0xead8</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_MEMO_TYPE</span> = <span class="hljs-number">0xead3</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_LAZY_TYPE</span> = <span class="hljs-number">0xead4</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_BLOCK_TYPE</span> = <span class="hljs-number">0xead9</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_SERVER_BLOCK_TYPE</span> = <span class="hljs-number">0xeada</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_FUNDAMENTAL_TYPE</span> = <span class="hljs-number">0xead5</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_SCOPE_TYPE</span> = <span class="hljs-number">0xead7</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_OPAQUE_ID_TYPE</span> = <span class="hljs-number">0xeae0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_DEBUG_TRACING_MODE_TYPE</span> = <span class="hljs-number">0xeae1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_OFFSCREEN_TYPE</span> = <span class="hljs-number">0xeae2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">REACT_LEGACY_HIDDEN_TYPE</span> = <span class="hljs-number">0xeae3</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">for</span>) {
    <span class="hljs-keyword">var</span> symbolFor = <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">for</span>;
    <span class="hljs-variable constant_">REACT_ELEMENT_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.element&#x27;</span>);
    <span class="hljs-variable constant_">REACT_PORTAL_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.portal&#x27;</span>);
    <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.fragment&#x27;</span>);
    <span class="hljs-variable constant_">REACT_STRICT_MODE_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.strict_mode&#x27;</span>);
    <span class="hljs-variable constant_">REACT_PROFILER_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.profiler&#x27;</span>);
    <span class="hljs-variable constant_">REACT_PROVIDER_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.provider&#x27;</span>);
    <span class="hljs-variable constant_">REACT_CONTEXT_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.context&#x27;</span>);
    <span class="hljs-variable constant_">REACT_FORWARD_REF_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.forward_ref&#x27;</span>);
    <span class="hljs-variable constant_">REACT_SUSPENSE_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.suspense&#x27;</span>);
    <span class="hljs-variable constant_">REACT_SUSPENSE_LIST_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.suspense_list&#x27;</span>);
    <span class="hljs-variable constant_">REACT_MEMO_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.memo&#x27;</span>);
    <span class="hljs-variable constant_">REACT_LAZY_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.lazy&#x27;</span>);
    <span class="hljs-variable constant_">REACT_BLOCK_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.block&#x27;</span>);
    <span class="hljs-variable constant_">REACT_SERVER_BLOCK_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.server.block&#x27;</span>);
    <span class="hljs-variable constant_">REACT_FUNDAMENTAL_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.fundamental&#x27;</span>);
    <span class="hljs-variable constant_">REACT_SCOPE_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.scope&#x27;</span>);
    <span class="hljs-variable constant_">REACT_OPAQUE_ID_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.opaque.id&#x27;</span>);
    <span class="hljs-variable constant_">REACT_DEBUG_TRACING_MODE_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.debug_trace_mode&#x27;</span>);
    <span class="hljs-variable constant_">REACT_OFFSCREEN_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.offscreen&#x27;</span>);
    <span class="hljs-variable constant_">REACT_LEGACY_HIDDEN_TYPE</span> = <span class="hljs-title function_">symbolFor</span>(<span class="hljs-string">&#x27;react.legacy_hidden&#x27;</span>);
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">MAYBE_ITERATOR_SYMBOL</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">FAUX_ITERATOR_SYMBOL</span> = <span class="hljs-string">&#x27;@@iterator&#x27;</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getIteratorFn</span>(<span class="hljs-params">maybeIterable</span>) {
    <span class="hljs-keyword">if</span> (maybeIterable === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> maybeIterable !== <span class="hljs-string">&#x27;object&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> maybeIterator = <span class="hljs-variable constant_">MAYBE_ITERATOR_SYMBOL</span> &amp;&amp; maybeIterable[<span class="hljs-variable constant_">MAYBE_ITERATOR_SYMBOL</span>] || maybeIterable[<span class="hljs-variable constant_">FAUX_ITERATOR_SYMBOL</span>];

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> maybeIterator === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">return</span> maybeIterator;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-48">&#x00a7;</a>
              </div>
              <p>Helpers to patch console.logs to avoid logging during side-effect free
replaying on render function. This currently only patches the object
lazily which won’t cover if the log function was extracted eagerly.
We could also eagerly patch the method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> disabledDepth = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> prevLog;
  <span class="hljs-keyword">var</span> prevInfo;
  <span class="hljs-keyword">var</span> prevWarn;
  <span class="hljs-keyword">var</span> prevError;
  <span class="hljs-keyword">var</span> prevGroup;
  <span class="hljs-keyword">var</span> prevGroupCollapsed;
  <span class="hljs-keyword">var</span> prevGroupEnd;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">disabledLog</span>(<span class="hljs-params"></span>) { }

  disabledLog.<span class="hljs-property">__reactDisabledLog</span> = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">disableLogs</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (disabledDepth === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">/* eslint-disable react-internal/no-production-logging */</span>
        prevLog = <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>;
        prevInfo = <span class="hljs-variable language_">console</span>.<span class="hljs-property">info</span>;
        prevWarn = <span class="hljs-variable language_">console</span>.<span class="hljs-property">warn</span>;
        prevError = <span class="hljs-variable language_">console</span>.<span class="hljs-property">error</span>;
        prevGroup = <span class="hljs-variable language_">console</span>.<span class="hljs-property">group</span>;
        prevGroupCollapsed = <span class="hljs-variable language_">console</span>.<span class="hljs-property">groupCollapsed</span>;
        prevGroupEnd = <span class="hljs-variable language_">console</span>.<span class="hljs-property">groupEnd</span>; <span class="hljs-comment">// https://github.com/facebook/react/issues/19099</span>

        <span class="hljs-keyword">var</span> props = {
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">value</span>: disabledLog,
          <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
        }; <span class="hljs-comment">// $FlowFixMe Flow thinks console is immutable.</span>

        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(<span class="hljs-variable language_">console</span>, {
          <span class="hljs-attr">info</span>: props,
          <span class="hljs-attr">log</span>: props,
          <span class="hljs-attr">warn</span>: props,
          <span class="hljs-attr">error</span>: props,
          <span class="hljs-attr">group</span>: props,
          <span class="hljs-attr">groupCollapsed</span>: props,
          <span class="hljs-attr">groupEnd</span>: props
        });
        <span class="hljs-comment">/* eslint-enable react-internal/no-production-logging */</span>
      }

      disabledDepth++;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reenableLogs</span>(<span class="hljs-params"></span>) {
    {
      disabledDepth--;

      <span class="hljs-keyword">if</span> (disabledDepth === <span class="hljs-number">0</span>) {
        <span class="hljs-comment">/* eslint-disable react-internal/no-production-logging */</span>
        <span class="hljs-keyword">var</span> props = {
          <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,
          <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
        }; <span class="hljs-comment">// $FlowFixMe Flow thinks console is immutable.</span>

        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(<span class="hljs-variable language_">console</span>, {
          <span class="hljs-attr">log</span>: <span class="hljs-title function_">_assign</span>({}, props, {
            <span class="hljs-attr">value</span>: prevLog
          }),
          <span class="hljs-attr">info</span>: <span class="hljs-title function_">_assign</span>({}, props, {
            <span class="hljs-attr">value</span>: prevInfo
          }),
          <span class="hljs-attr">warn</span>: <span class="hljs-title function_">_assign</span>({}, props, {
            <span class="hljs-attr">value</span>: prevWarn
          }),
          <span class="hljs-attr">error</span>: <span class="hljs-title function_">_assign</span>({}, props, {
            <span class="hljs-attr">value</span>: prevError
          }),
          <span class="hljs-attr">group</span>: <span class="hljs-title function_">_assign</span>({}, props, {
            <span class="hljs-attr">value</span>: prevGroup
          }),
          <span class="hljs-attr">groupCollapsed</span>: <span class="hljs-title function_">_assign</span>({}, props, {
            <span class="hljs-attr">value</span>: prevGroupCollapsed
          }),
          <span class="hljs-attr">groupEnd</span>: <span class="hljs-title function_">_assign</span>({}, props, {
            <span class="hljs-attr">value</span>: prevGroupEnd
          })
        });
        <span class="hljs-comment">/* eslint-enable react-internal/no-production-logging */</span>
      }

      <span class="hljs-keyword">if</span> (disabledDepth &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;disabledDepth fell below zero. &#x27;</span> + <span class="hljs-string">&#x27;This is a bug in React. Please file an issue.&#x27;</span>);
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentDispatcher</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentDispatcher</span>;
  <span class="hljs-keyword">var</span> prefix;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(<span class="hljs-params">name, source, ownerFn</span>) {
    {
      <span class="hljs-keyword">if</span> (prefix === <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-49">&#x00a7;</a>
              </div>
              <p>Extract the VM specific prefix used by each line.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>();
        } <span class="hljs-keyword">catch</span> (x) {
          <span class="hljs-keyword">var</span> match = x.<span class="hljs-property">stack</span>.<span class="hljs-title function_">trim</span>().<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\n( *(at )?)/</span>);
          prefix = match &amp;&amp; match[<span class="hljs-number">1</span>] || <span class="hljs-string">&#x27;&#x27;</span>;
        }
      } <span class="hljs-comment">// We use the prefix to ensure our stacks line up with native stack frames.</span>


      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n&#x27;</span> + prefix + name;
    }
  }
  <span class="hljs-keyword">var</span> reentry = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> componentFrameCache;

  {
    <span class="hljs-keyword">var</span> <span class="hljs-title class_">PossiblyWeakMap</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WeakMap</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title class_">WeakMap</span> : <span class="hljs-title class_">Map</span>;
    componentFrameCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PossiblyWeakMap</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">describeNativeComponentFrame</span>(<span class="hljs-params">fn, construct</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-50">&#x00a7;</a>
              </div>
              <p>If something asked for a stack inside a fake render, it should get ignored.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!fn || reentry) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
    }

    {
      <span class="hljs-keyword">var</span> frame = componentFrameCache.<span class="hljs-title function_">get</span>(fn);

      <span class="hljs-keyword">if</span> (frame !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">return</span> frame;
      }
    }

    <span class="hljs-keyword">var</span> control;
    reentry = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> previousPrepareStackTrace = <span class="hljs-title class_">Error</span>.<span class="hljs-property">prepareStackTrace</span>; <span class="hljs-comment">// $FlowFixMe It does accept undefined.</span>

    <span class="hljs-title class_">Error</span>.<span class="hljs-property">prepareStackTrace</span> = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">var</span> previousDispatcher;

    {
      previousDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span>; <span class="hljs-comment">// Set the dispatcher in DEV because this might be call in the render function</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-51">&#x00a7;</a>
              </div>
              <p>for warnings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-title function_">disableLogs</span>();
    }

    <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-52">&#x00a7;</a>
              </div>
              <p>This should throw.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (construct) {</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-53">&#x00a7;</a>
              </div>
              <p>Something should be setting the props in the constructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> <span class="hljs-title class_">Fake</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>();
        }; <span class="hljs-comment">// $FlowFixMe</span>


        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Fake</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;props&#x27;</span>, {
          <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-54">&#x00a7;</a>
              </div>
              <p>We use a throwing setter instead of frozen or non-writable props
because that won’t throw in a non-strict mode function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>();
          }
        });

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Reflect</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">construct</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-55">&#x00a7;</a>
              </div>
              <p>We construct a different control for this case to include any extra
frames added by the construct call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(<span class="hljs-title class_">Fake</span>, []);
          } <span class="hljs-keyword">catch</span> (x) {
            control = x;
          }

          <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(fn, [], <span class="hljs-title class_">Fake</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">try</span> {
            <span class="hljs-title class_">Fake</span>.<span class="hljs-title function_">call</span>();
          } <span class="hljs-keyword">catch</span> (x) {
            control = x;
          }

          fn.<span class="hljs-title function_">call</span>(<span class="hljs-title class_">Fake</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>();
        } <span class="hljs-keyword">catch</span> (x) {
          control = x;
        }

        <span class="hljs-title function_">fn</span>();
      }
    } <span class="hljs-keyword">catch</span> (sample) {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-56">&#x00a7;</a>
              </div>
              <p>This is inlined manually because closure doesn’t do it for us.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (sample &amp;&amp; control &amp;&amp; <span class="hljs-keyword">typeof</span> sample.<span class="hljs-property">stack</span> === <span class="hljs-string">&#x27;string&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-57">&#x00a7;</a>
              </div>
              <p>This extracts the first frame from the sample that isn’t also in the control.
Skipping one frame that we assume is the frame that calls the two.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> sampleLines = sample.<span class="hljs-property">stack</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);
        <span class="hljs-keyword">var</span> controlLines = control.<span class="hljs-property">stack</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);
        <span class="hljs-keyword">var</span> s = sampleLines.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">var</span> c = controlLines.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;

        <span class="hljs-keyword">while</span> (s &gt;= <span class="hljs-number">1</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span> &amp;&amp; sampleLines[s] !== controlLines[c]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-58">&#x00a7;</a>
              </div>
              <p>We expect at least one stack frame to be shared.
Typically this will be the root most one. However, stack frames may be
cut off due to maximum stack limits. In this case, one maybe cut off
earlier than the other. We assume that the sample is longer or the same
and there for cut off earlier. So we should find the root most frame in
the sample somewhere in the control.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          c--;
        }

        <span class="hljs-keyword">for</span> (; s &gt;= <span class="hljs-number">1</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span>; s--, c--) {</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-59">&#x00a7;</a>
              </div>
              <p>Next we find the first one that isn’t the same which should be the
frame that called our sample function and the control.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (sampleLines[s] !== controlLines[c]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-60">&#x00a7;</a>
              </div>
              <p>In V8, the first line is describing the message but other VMs don’t.
If we’re about to return the first line, and the control is also on the same
line, that’s a pretty good indicator that our sample threw at same line as
the control. I.e. before we entered the sample frame. So we ignore this result.
This can happen if you passed a class to function component, or non-function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (s !== <span class="hljs-number">1</span> || c !== <span class="hljs-number">1</span>) {
              <span class="hljs-keyword">do</span> {
                s--;
                c--; <span class="hljs-comment">// We may still have similar intermediate frames from the construct call.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-61">&#x00a7;</a>
              </div>
              <p>The next one that isn’t the same should be our match though.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-number">0</span> || sampleLines[s] !== controlLines[c]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-62">&#x00a7;</a>
              </div>
              <p>V8 adds a “new” prefix for native classes. Let’s remove it to make it prettier.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">var</span> _frame = <span class="hljs-string">&#x27;\n&#x27;</span> + sampleLines[s].<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27; at new &#x27;</span>, <span class="hljs-string">&#x27; at &#x27;</span>);

                  {
                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&#x27;function&#x27;</span>) {
                      componentFrameCache.<span class="hljs-title function_">set</span>(fn, _frame);
                    }
                  } <span class="hljs-comment">// Return the line we found.</span>


                  <span class="hljs-keyword">return</span> _frame;
                }
              } <span class="hljs-keyword">while</span> (s &gt;= <span class="hljs-number">1</span> &amp;&amp; c &gt;= <span class="hljs-number">0</span>);
            }

            <span class="hljs-keyword">break</span>;
          }
        }
      }
    } <span class="hljs-keyword">finally</span> {
      reentry = <span class="hljs-literal">false</span>;

      {
        <span class="hljs-title class_">ReactCurrentDispatcher</span>.<span class="hljs-property">current</span> = previousDispatcher;
        <span class="hljs-title function_">reenableLogs</span>();
      }

      <span class="hljs-title class_">Error</span>.<span class="hljs-property">prepareStackTrace</span> = previousPrepareStackTrace;
    } <span class="hljs-comment">// Fallback to just using the name if we couldn&#x27;t make it throw.</span>


    <span class="hljs-keyword">var</span> name = fn ? fn.<span class="hljs-property">displayName</span> || fn.<span class="hljs-property">name</span> : <span class="hljs-string">&#x27;&#x27;</span>;
    <span class="hljs-keyword">var</span> syntheticFrame = name ? <span class="hljs-title function_">describeBuiltInComponentFrame</span>(name) : <span class="hljs-string">&#x27;&#x27;</span>;

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn === <span class="hljs-string">&#x27;function&#x27;</span>) {
        componentFrameCache.<span class="hljs-title function_">set</span>(fn, syntheticFrame);
      }
    }

    <span class="hljs-keyword">return</span> syntheticFrame;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">describeClassComponentFrame</span>(<span class="hljs-params">ctor, source, ownerFn</span>) {
    {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeNativeComponentFrame</span>(ctor, <span class="hljs-literal">true</span>);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">describeFunctionComponentFrame</span>(<span class="hljs-params">fn, source, ownerFn</span>) {
    {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeNativeComponentFrame</span>(fn, <span class="hljs-literal">false</span>);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldConstruct</span>(<span class="hljs-params">Component</span>) {
    <span class="hljs-keyword">var</span> prototype = <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
    <span class="hljs-keyword">return</span> !!(prototype &amp;&amp; prototype.<span class="hljs-property">isReactComponent</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">describeUnknownElementTypeFrameInDEV</span>(<span class="hljs-params">type, source, ownerFn</span>) {

    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;function&#x27;</span>) {
      {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeNativeComponentFrame</span>(type, <span class="hljs-title function_">shouldConstruct</span>(type));
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;string&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(type);
    }

    <span class="hljs-keyword">switch</span> (type) {
      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(<span class="hljs-string">&#x27;Suspense&#x27;</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_LIST_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(<span class="hljs-string">&#x27;SuspenseList&#x27;</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;object&#x27;</span>) {
      <span class="hljs-keyword">switch</span> (type.<span class="hljs-property">$$typeof</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_FORWARD_REF_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeFunctionComponentFrame</span>(type.<span class="hljs-property">render</span>);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_MEMO_TYPE</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-63">&#x00a7;</a>
              </div>
              <p>Memo may contain any component type so we recursively resolve it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeUnknownElementTypeFrameInDEV</span>(type.<span class="hljs-property">type</span>, source, ownerFn);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_BLOCK_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeFunctionComponentFrame</span>(type.<span class="hljs-property">_render</span>);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
          {
            <span class="hljs-keyword">var</span> lazyComponent = type;
            <span class="hljs-keyword">var</span> payload = lazyComponent.<span class="hljs-property">_payload</span>;
            <span class="hljs-keyword">var</span> init = lazyComponent.<span class="hljs-property">_init</span>;

            <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-64">&#x00a7;</a>
              </div>
              <p>Lazy may contain any component type so we recursively resolve it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeUnknownElementTypeFrameInDEV</span>(<span class="hljs-title function_">init</span>(payload), source, ownerFn);
            } <span class="hljs-keyword">catch</span> (x) { }
          }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">describeFiber</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> owner = fiber.<span class="hljs-property">_debugOwner</span> ? fiber.<span class="hljs-property">_debugOwner</span>.<span class="hljs-property">type</span> : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> source = fiber.<span class="hljs-property">_debugSource</span>;

    <span class="hljs-keyword">switch</span> (fiber.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(fiber.<span class="hljs-property">type</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LazyComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(<span class="hljs-string">&#x27;Lazy&#x27;</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(<span class="hljs-string">&#x27;Suspense&#x27;</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeBuiltInComponentFrame</span>(<span class="hljs-string">&#x27;SuspenseList&#x27;</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeFunctionComponentFrame</span>(fiber.<span class="hljs-property">type</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeFunctionComponentFrame</span>(fiber.<span class="hljs-property">type</span>.<span class="hljs-property">render</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeFunctionComponentFrame</span>(fiber.<span class="hljs-property">type</span>.<span class="hljs-property">_render</span>);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">describeClassComponentFrame</span>(fiber.<span class="hljs-property">type</span>);

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStackByFiberInDevAndProd</span>(<span class="hljs-params">workInProgress</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> info = <span class="hljs-string">&#x27;&#x27;</span>;
      <span class="hljs-keyword">var</span> node = workInProgress;

      <span class="hljs-keyword">do</span> {
        info += <span class="hljs-title function_">describeFiber</span>(node);
        node = node.<span class="hljs-property">return</span>;
      } <span class="hljs-keyword">while</span> (node);

      <span class="hljs-keyword">return</span> info;
    } <span class="hljs-keyword">catch</span> (x) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\nError generating stack: &#x27;</span> + x.<span class="hljs-property">message</span> + <span class="hljs-string">&#x27;\n&#x27;</span> + x.<span class="hljs-property">stack</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getWrappedName</span>(<span class="hljs-params">outerType, innerType, wrapperName</span>) {
    <span class="hljs-keyword">var</span> functionName = innerType.<span class="hljs-property">displayName</span> || innerType.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;&#x27;</span>;
    <span class="hljs-keyword">return</span> outerType.<span class="hljs-property">displayName</span> || (functionName !== <span class="hljs-string">&#x27;&#x27;</span> ? wrapperName + <span class="hljs-string">&quot;(&quot;</span> + functionName + <span class="hljs-string">&quot;)&quot;</span> : wrapperName);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getContextName</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">return</span> type.<span class="hljs-property">displayName</span> || <span class="hljs-string">&#x27;Context&#x27;</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getComponentName</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-65">&#x00a7;</a>
              </div>
              <p>Host root, text node or just invalid type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type.<span class="hljs-property">tag</span> === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Received an unexpected object in getComponentName(). &#x27;</span> + <span class="hljs-string">&#x27;This is likely a bug in React. Please file an issue.&#x27;</span>);
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">return</span> type.<span class="hljs-property">displayName</span> || type.<span class="hljs-property">name</span> || <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;string&#x27;</span>) {
      <span class="hljs-keyword">return</span> type;
    }

    <span class="hljs-keyword">switch</span> (type) {
      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_FRAGMENT_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Fragment&#x27;</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Portal&#x27;</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PROFILER_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Profiler&#x27;</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_STRICT_MODE_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;StrictMode&#x27;</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Suspense&#x27;</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_LIST_TYPE</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;SuspenseList&#x27;</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;object&#x27;</span>) {
      <span class="hljs-keyword">switch</span> (type.<span class="hljs-property">$$typeof</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_CONTEXT_TYPE</span>:
          <span class="hljs-keyword">var</span> context = type;
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContextName</span>(context) + <span class="hljs-string">&#x27;.Consumer&#x27;</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PROVIDER_TYPE</span>:
          <span class="hljs-keyword">var</span> provider = type;
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContextName</span>(provider.<span class="hljs-property">_context</span>) + <span class="hljs-string">&#x27;.Provider&#x27;</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_FORWARD_REF_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">getWrappedName</span>(type, type.<span class="hljs-property">render</span>, <span class="hljs-string">&#x27;ForwardRef&#x27;</span>);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_MEMO_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">getComponentName</span>(type.<span class="hljs-property">type</span>);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_BLOCK_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">getComponentName</span>(type.<span class="hljs-property">_render</span>);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
          {
            <span class="hljs-keyword">var</span> lazyComponent = type;
            <span class="hljs-keyword">var</span> payload = lazyComponent.<span class="hljs-property">_payload</span>;
            <span class="hljs-keyword">var</span> init = lazyComponent.<span class="hljs-property">_init</span>;

            <span class="hljs-keyword">try</span> {
              <span class="hljs-keyword">return</span> <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title function_">init</span>(payload));
            } <span class="hljs-keyword">catch</span> (x) {
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }
          }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactDebugCurrentFrame</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactDebugCurrentFrame</span>;
  <span class="hljs-keyword">var</span> current = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> isRendering = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentFiberOwnerNameInDevOrNull</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">var</span> owner = current.<span class="hljs-property">_debugOwner</span>;

      <span class="hljs-keyword">if</span> (owner !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> owner !== <span class="hljs-string">&#x27;undefined&#x27;</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getComponentName</span>(owner.<span class="hljs-property">type</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentFiberStackInDev</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
      } <span class="hljs-comment">// Safe because if current fiber exists, we are reconciling,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-66">&#x00a7;</a>
              </div>
              <p>and it is guaranteed to be the work-in-progress version.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getStackByFiberInDevAndProd</span>(current);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetCurrentFiber</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-title class_">ReactDebugCurrentFrame</span>.<span class="hljs-property">getCurrentStack</span> = <span class="hljs-literal">null</span>;
      current = <span class="hljs-literal">null</span>;
      isRendering = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setCurrentFiber</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-title class_">ReactDebugCurrentFrame</span>.<span class="hljs-property">getCurrentStack</span> = getCurrentFiberStackInDev;
      current = fiber;
      isRendering = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-params">rendering</span>) {
    {
      isRendering = rendering;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getIsRendering</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">return</span> isRendering;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-67">&#x00a7;</a>
              </div>
              <p>Flow does not allow string concatenation of most non-string types. To work
around this limitation, we use an opaque type that can only be obtained by
passing the value through getToStringValue first.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span> + value;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getToStringValue</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> value) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;boolean&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;number&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;object&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;string&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;undefined&#x27;</span>:
        <span class="hljs-keyword">return</span> value;

      <span class="hljs-attr">default</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-68">&#x00a7;</a>
              </div>
              <p>function, symbol are assigned as empty strings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
    }
  }

  <span class="hljs-keyword">var</span> hasReadOnlyValue = {
    <span class="hljs-attr">button</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">checkbox</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">image</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">hidden</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">radio</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">reset</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">submit</span>: <span class="hljs-literal">true</span>
  };
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkControlledValueProps</span>(<span class="hljs-params">tagName, props</span>) {
    {
      <span class="hljs-keyword">if</span> (!(hasReadOnlyValue[props.<span class="hljs-property">type</span>] || props.<span class="hljs-property">onChange</span> || props.<span class="hljs-property">onInput</span> || props.<span class="hljs-property">readOnly</span> || props.<span class="hljs-property">disabled</span> || props.<span class="hljs-property">value</span> == <span class="hljs-literal">null</span>)) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;You provided a `value` prop to a form field without an &#x27;</span> + <span class="hljs-string">&#x27;`onChange` handler. This will render a read-only field. If &#x27;</span> + <span class="hljs-string">&#x27;the field should be mutable use `defaultValue`. Otherwise, &#x27;</span> + <span class="hljs-string">&#x27;set either `onChange` or `readOnly`.&#x27;</span>);
      }

      <span class="hljs-keyword">if</span> (!(props.<span class="hljs-property">onChange</span> || props.<span class="hljs-property">readOnly</span> || props.<span class="hljs-property">disabled</span> || props.<span class="hljs-property">checked</span> == <span class="hljs-literal">null</span>)) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;You provided a `checked` prop to a form field without an &#x27;</span> + <span class="hljs-string">&#x27;`onChange` handler. This will render a read-only field. If &#x27;</span> + <span class="hljs-string">&#x27;the field should be mutable use `defaultChecked`. Otherwise, &#x27;</span> + <span class="hljs-string">&#x27;set either `onChange` or `readOnly`.&#x27;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isCheckable</span>(<span class="hljs-params">elem</span>) {
    <span class="hljs-keyword">var</span> type = elem.<span class="hljs-property">type</span>;
    <span class="hljs-keyword">var</span> nodeName = elem.<span class="hljs-property">nodeName</span>;
    <span class="hljs-keyword">return</span> nodeName &amp;&amp; nodeName.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;input&#x27;</span> &amp;&amp; (type === <span class="hljs-string">&#x27;checkbox&#x27;</span> || type === <span class="hljs-string">&#x27;radio&#x27;</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTracker</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> node.<span class="hljs-property">_valueTracker</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">detachTracker</span>(<span class="hljs-params">node</span>) {
    node.<span class="hljs-property">_valueTracker</span> = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getValueFromNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">var</span> value = <span class="hljs-string">&#x27;&#x27;</span>;

    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> value;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCheckable</span>(node)) {
      value = node.<span class="hljs-property">checked</span> ? <span class="hljs-string">&#x27;true&#x27;</span> : <span class="hljs-string">&#x27;false&#x27;</span>;
    } <span class="hljs-keyword">else</span> {
      value = node.<span class="hljs-property">value</span>;
    }

    <span class="hljs-keyword">return</span> value;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">trackValueOnNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">var</span> valueField = <span class="hljs-title function_">isCheckable</span>(node) ? <span class="hljs-string">&#x27;checked&#x27;</span> : <span class="hljs-string">&#x27;value&#x27;</span>;
    <span class="hljs-keyword">var</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(node.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, valueField);
    <span class="hljs-keyword">var</span> currentValue = <span class="hljs-string">&#x27;&#x27;</span> + node[valueField]; <span class="hljs-comment">// if someone has already defined a value or Safari, then bail</span></pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-69">&#x00a7;</a>
              </div>
              <p>and don’t track value will cause over reporting of changes,
but it’s better then a hard failure
(needed for certain tests that spyOn input values and Safari)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasOwnProperty</span>(valueField) || <span class="hljs-keyword">typeof</span> descriptor === <span class="hljs-string">&#x27;undefined&#x27;</span> || <span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">get</span> !== <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">set</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> get = descriptor.<span class="hljs-property">get</span>,
      set = descriptor.<span class="hljs-property">set</span>;
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(node, valueField, {
      <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> get.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
      },
      <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentValue = <span class="hljs-string">&#x27;&#x27;</span> + value;
        set.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, value);
      }
    }); <span class="hljs-comment">// We could&#x27;ve passed this the first time</span></pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-70">&#x00a7;</a>
              </div>
              <p>but it triggers a bug in IE11 and Edge 14/15.
Calling defineProperty() again should be equivalent.
<a href="https://github.com/facebook/react/issues/11768">https://github.com/facebook/react/issues/11768</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(node, valueField, {
      <span class="hljs-attr">enumerable</span>: descriptor.<span class="hljs-property">enumerable</span>
    });
    <span class="hljs-keyword">var</span> tracker = {
      <span class="hljs-attr">getValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> currentValue;
      },
      <span class="hljs-attr">setValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentValue = <span class="hljs-string">&#x27;&#x27;</span> + value;
      },
      <span class="hljs-attr">stopTracking</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">detachTracker</span>(node);
        <span class="hljs-keyword">delete</span> node[valueField];
      }
    };
    <span class="hljs-keyword">return</span> tracker;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getTracker</span>(node)) {
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Once it&#x27;s just Fiber we can move this to node._wrapperState</span>


    node.<span class="hljs-property">_valueTracker</span> = <span class="hljs-title function_">trackValueOnNode</span>(node);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateValueIfChanged</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (!node) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> tracker = <span class="hljs-title function_">getTracker</span>(node); <span class="hljs-comment">// if there is no tracker at this point it&#x27;s unlikely</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-71">&#x00a7;</a>
              </div>
              <p>that trying again will succeed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!tracker) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">var</span> lastValue = tracker.<span class="hljs-title function_">getValue</span>();
    <span class="hljs-keyword">var</span> nextValue = <span class="hljs-title function_">getValueFromNode</span>(node);

    <span class="hljs-keyword">if</span> (nextValue !== lastValue) {
      tracker.<span class="hljs-title function_">setValue</span>(nextValue);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getActiveElement</span>(<span class="hljs-params">doc</span>) {
    doc = doc || (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> ? <span class="hljs-variable language_">document</span> : <span class="hljs-literal">undefined</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> doc === <span class="hljs-string">&#x27;undefined&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> doc.<span class="hljs-property">activeElement</span> || doc.<span class="hljs-property">body</span>;
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> doc.<span class="hljs-property">body</span>;
    }
  }

  <span class="hljs-keyword">var</span> didWarnValueDefaultValue = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> didWarnCheckedDefaultChecked = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> didWarnControlledToUncontrolled = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> didWarnUncontrolledToControlled = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isControlled</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-keyword">var</span> usesChecked = props.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;checkbox&#x27;</span> || props.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;radio&#x27;</span>;
    <span class="hljs-keyword">return</span> usesChecked ? props.<span class="hljs-property">checked</span> != <span class="hljs-literal">null</span> : props.<span class="hljs-property">value</span> != <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">/**
   * Implements an &lt;input&gt; host component that allows setting these optional
   * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
   *
   * If `checked` or `value` are not supplied (or null/undefined), user actions
   * that affect the checked state or value will trigger updates to the element.
   *
   * If they are supplied (and not null/undefined), the rendered element will not
   * trigger updates to the element. Instead, the props must change in order for
   * the rendered element to be updated.
   *
   * The rendered element will be initialized as unchecked (or `defaultChecked`)
   * with an empty value (or `defaultValue`).
   *
   * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHostProps</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;
    <span class="hljs-keyword">var</span> checked = props.<span class="hljs-property">checked</span>;

    <span class="hljs-keyword">var</span> hostProps = <span class="hljs-title function_">_assign</span>({}, props, {
      <span class="hljs-attr">defaultChecked</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-attr">checked</span>: checked != <span class="hljs-literal">null</span> ? checked : node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">initialChecked</span>
    });

    <span class="hljs-keyword">return</span> hostProps;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">initWrapperState</span>(<span class="hljs-params">element, props</span>) {
    {
      <span class="hljs-title function_">checkControlledValueProps</span>(<span class="hljs-string">&#x27;input&#x27;</span>, props);

      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">checked</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; props.<span class="hljs-property">defaultChecked</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnCheckedDefaultChecked) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s contains an input of type %s with both checked and defaultChecked props. &#x27;</span> + <span class="hljs-string">&#x27;Input elements must be either controlled or uncontrolled &#x27;</span> + <span class="hljs-string">&#x27;(specify either the checked prop, or the defaultChecked prop, but not &#x27;</span> + <span class="hljs-string">&#x27;both). Decide between using a controlled or uncontrolled input &#x27;</span> + <span class="hljs-string">&#x27;element and remove one of these props. More info: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/controlled-components&#x27;</span>, <span class="hljs-title function_">getCurrentFiberOwnerNameInDevOrNull</span>() || <span class="hljs-string">&#x27;A component&#x27;</span>, props.<span class="hljs-property">type</span>);

        didWarnCheckedDefaultChecked = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">value</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; props.<span class="hljs-property">defaultValue</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnValueDefaultValue) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s contains an input of type %s with both value and defaultValue props. &#x27;</span> + <span class="hljs-string">&#x27;Input elements must be either controlled or uncontrolled &#x27;</span> + <span class="hljs-string">&#x27;(specify either the value prop, or the defaultValue prop, but not &#x27;</span> + <span class="hljs-string">&#x27;both). Decide between using a controlled or uncontrolled input &#x27;</span> + <span class="hljs-string">&#x27;element and remove one of these props. More info: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/controlled-components&#x27;</span>, <span class="hljs-title function_">getCurrentFiberOwnerNameInDevOrNull</span>() || <span class="hljs-string">&#x27;A component&#x27;</span>, props.<span class="hljs-property">type</span>);

        didWarnValueDefaultValue = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">var</span> node = element;
    <span class="hljs-keyword">var</span> defaultValue = props.<span class="hljs-property">defaultValue</span> == <span class="hljs-literal">null</span> ? <span class="hljs-string">&#x27;&#x27;</span> : props.<span class="hljs-property">defaultValue</span>;
    node.<span class="hljs-property">_wrapperState</span> = {
      <span class="hljs-attr">initialChecked</span>: props.<span class="hljs-property">checked</span> != <span class="hljs-literal">null</span> ? props.<span class="hljs-property">checked</span> : props.<span class="hljs-property">defaultChecked</span>,
      <span class="hljs-attr">initialValue</span>: <span class="hljs-title function_">getToStringValue</span>(props.<span class="hljs-property">value</span> != <span class="hljs-literal">null</span> ? props.<span class="hljs-property">value</span> : defaultValue),
      <span class="hljs-attr">controlled</span>: <span class="hljs-title function_">isControlled</span>(props)
    };
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateChecked</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;
    <span class="hljs-keyword">var</span> checked = props.<span class="hljs-property">checked</span>;

    <span class="hljs-keyword">if</span> (checked != <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">setValueForProperty</span>(node, <span class="hljs-string">&#x27;checked&#x27;</span>, checked, <span class="hljs-literal">false</span>);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateWrapper</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;

    {
      <span class="hljs-keyword">var</span> controlled = <span class="hljs-title function_">isControlled</span>(props);

      <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">controlled</span> &amp;&amp; controlled &amp;&amp; !didWarnUncontrolledToControlled) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A component is changing an uncontrolled input to be controlled. &#x27;</span> + <span class="hljs-string">&#x27;This is likely caused by the value changing from undefined to &#x27;</span> + <span class="hljs-string">&#x27;a defined value, which should not happen. &#x27;</span> + <span class="hljs-string">&#x27;Decide between using a controlled or uncontrolled input &#x27;</span> + <span class="hljs-string">&#x27;element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components&#x27;</span>);

        didWarnUncontrolledToControlled = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">controlled</span> &amp;&amp; !controlled &amp;&amp; !didWarnControlledToUncontrolled) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A component is changing a controlled input to be uncontrolled. &#x27;</span> + <span class="hljs-string">&#x27;This is likely caused by the value changing from a defined to &#x27;</span> + <span class="hljs-string">&#x27;undefined, which should not happen. &#x27;</span> + <span class="hljs-string">&#x27;Decide between using a controlled or uncontrolled input &#x27;</span> + <span class="hljs-string">&#x27;element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components&#x27;</span>);

        didWarnControlledToUncontrolled = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-title function_">updateChecked</span>(element, props);
    <span class="hljs-keyword">var</span> value = <span class="hljs-title function_">getToStringValue</span>(props.<span class="hljs-property">value</span>);
    <span class="hljs-keyword">var</span> type = props.<span class="hljs-property">type</span>;

    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-keyword">if</span> (value === <span class="hljs-number">0</span> &amp;&amp; node.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-comment">// We explicitly want to coerce to number here if possible.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-72">&#x00a7;</a>
              </div>
              <p>eslint-disable-next-line</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          node.<span class="hljs-property">value</span> != value) {
          node.<span class="hljs-property">value</span> = <span class="hljs-title function_">toString</span>(value);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">value</span> !== <span class="hljs-title function_">toString</span>(value)) {
        node.<span class="hljs-property">value</span> = <span class="hljs-title function_">toString</span>(value);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;submit&#x27;</span> || type === <span class="hljs-string">&#x27;reset&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-73">&#x00a7;</a>
              </div>
              <p>Submit/reset inputs need the attribute removed completely to avoid
blank-text buttons.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      node.<span class="hljs-title function_">removeAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>);
      <span class="hljs-keyword">return</span>;
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-74">&#x00a7;</a>
              </div>
              <p>When syncing the value attribute, the value comes from a cascade of
properties:</p>
<ol>
<li>The value React property</li>
<li>The defaultValue React property</li>
<li>Otherwise there should be no change</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (props.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;value&#x27;</span>)) {
        <span class="hljs-title function_">setDefaultValue</span>(node, props.<span class="hljs-property">type</span>, value);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (props.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;defaultValue&#x27;</span>)) {
        <span class="hljs-title function_">setDefaultValue</span>(node, props.<span class="hljs-property">type</span>, <span class="hljs-title function_">getToStringValue</span>(props.<span class="hljs-property">defaultValue</span>));
      }
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-75">&#x00a7;</a>
              </div>
              <p>When syncing the checked attribute, it only changes when it needs
to be removed, such as transitioning from a checkbox into a text input</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">checked</span> == <span class="hljs-literal">null</span> &amp;&amp; props.<span class="hljs-property">defaultChecked</span> != <span class="hljs-literal">null</span>) {
        node.<span class="hljs-property">defaultChecked</span> = !!props.<span class="hljs-property">defaultChecked</span>;
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">postMountWrapper</span>(<span class="hljs-params">element, props, isHydrating</span>) {
    <span class="hljs-keyword">var</span> node = element; <span class="hljs-comment">// Do not assign value if it is already set. This prevents user text input</span></pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-76">&#x00a7;</a>
              </div>
              <p>from being lost during SSR hydration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (props.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;value&#x27;</span>) || props.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;defaultValue&#x27;</span>)) {
      <span class="hljs-keyword">var</span> type = props.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">var</span> isButton = type === <span class="hljs-string">&#x27;submit&#x27;</span> || type === <span class="hljs-string">&#x27;reset&#x27;</span>; <span class="hljs-comment">// Avoid setting value attribute on submit/reset inputs as it overrides the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-77">&#x00a7;</a>
              </div>
              <p>default value provided by the browser. See: #12872</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (isButton &amp;&amp; (props.<span class="hljs-property">value</span> === <span class="hljs-literal">undefined</span> || props.<span class="hljs-property">value</span> === <span class="hljs-literal">null</span>)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> initialValue = <span class="hljs-title function_">toString</span>(node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">initialValue</span>); <span class="hljs-comment">// Do not assign value if it is already set. This prevents user text input</span></pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-78">&#x00a7;</a>
              </div>
              <p>from being lost during SSR hydration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (!isHydrating) {
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-79">&#x00a7;</a>
              </div>
              <p>When syncing the value attribute, the value property should use
the wrapperState._initialValue property. This uses:</p>
<ol>
<li>The value React property when present</li>
<li>The defaultValue React property when present</li>
<li>An empty string</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (initialValue !== node.<span class="hljs-property">value</span>) {
            node.<span class="hljs-property">value</span> = initialValue;
          }
        }
      }

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-80">&#x00a7;</a>
              </div>
              <p>Otherwise, the value attribute is synchronized to the property,
so we assign defaultValue to the same thing as the value property
assignment step above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        node.<span class="hljs-property">defaultValue</span> = initialValue;
      }
    } <span class="hljs-comment">// Normally, we&#x27;d just do `node.checked = node.checked` upon initial mount, less this bug</span></pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-81">&#x00a7;</a>
              </div>
              <p>this is needed to work around a chrome bug where setting defaultChecked
will sometimes influence the value of checked (even after detachment).
Reference: <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=608416">https://bugs.chromium.org/p/chromium/issues/detail?id=608416</a>
We need to temporarily unset name to avoid disrupting radio button groups.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> name = node.<span class="hljs-property">name</span>;

    <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&#x27;&#x27;</span>) {
      node.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;&#x27;</span>;
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-82">&#x00a7;</a>
              </div>
              <p>When syncing the checked attribute, both the checked property and
attribute are assigned at the same time using defaultChecked. This uses:</p>
<ol>
<li>The checked React property when present</li>
<li>The defaultChecked React property when present</li>
<li>Otherwise, false</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>      node.<span class="hljs-property">defaultChecked</span> = !node.<span class="hljs-property">defaultChecked</span>;
      node.<span class="hljs-property">defaultChecked</span> = !!node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">initialChecked</span>;
    }

    <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&#x27;&#x27;</span>) {
      node.<span class="hljs-property">name</span> = name;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreControlledState</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;
    <span class="hljs-title function_">updateWrapper</span>(node, props);
    <span class="hljs-title function_">updateNamedCousins</span>(node, props);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateNamedCousins</span>(<span class="hljs-params">rootNode, props</span>) {
    <span class="hljs-keyword">var</span> name = props.<span class="hljs-property">name</span>;

    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;radio&#x27;</span> &amp;&amp; name != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> queryRoot = rootNode;

      <span class="hljs-keyword">while</span> (queryRoot.<span class="hljs-property">parentNode</span>) {
        queryRoot = queryRoot.<span class="hljs-property">parentNode</span>;
      } <span class="hljs-comment">// If `rootNode.form` was non-null, then we could try `form.elements`,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-83">&#x00a7;</a>
              </div>
              <p>but that sometimes behaves strangely in IE8. We could also try using
<code>form.getElementsByName</code>, but that will only return direct children
and won’t include inputs that use the HTML5 <code>form=</code> attribute. Since
the input might not even be in a form. It might not even be in the
document. Let’s just use the local <code>querySelectorAll</code> to ensure we don’t
miss anything.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> group = queryRoot.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;input[name=&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-string">&#x27;&#x27;</span> + name) + <span class="hljs-string">&#x27;][type=&quot;radio&quot;]&#x27;</span>);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; group.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">var</span> otherNode = group[i];

        <span class="hljs-keyword">if</span> (otherNode === rootNode || otherNode.<span class="hljs-property">form</span> !== rootNode.<span class="hljs-property">form</span>) {
          <span class="hljs-keyword">continue</span>;
        } <span class="hljs-comment">// This will throw if radio buttons rendered by different copies of React</span></pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-84">&#x00a7;</a>
              </div>
              <p>and the same name are rendered into the same form (same as #1939).
That’s probably okay; we don’t support it just as we don’t support
mixing React radio buttons with non-React ones.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-keyword">var</span> otherProps = <span class="hljs-title function_">getFiberCurrentPropsFromNode</span>(otherNode);

        <span class="hljs-keyword">if</span> (!otherProps) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.&quot;</span>);
          }
        } <span class="hljs-comment">// We need update the tracked value on the named cousin since the value</span></pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-85">&#x00a7;</a>
              </div>
              <p>was changed but the input saw no event or value set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-title function_">updateValueIfChanged</span>(otherNode); <span class="hljs-comment">// If this is a controlled radio button group, forcing the input that</span></pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-86">&#x00a7;</a>
              </div>
              <p>was previously checked to update will cause it to be come re-checked
as appropriate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">updateWrapper</span>(otherNode, otherProps);
      }
    }
  } <span class="hljs-comment">// In Chrome, assigning defaultValue to certain input types triggers input validation.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-87">&#x00a7;</a>
              </div>
              <p>For number inputs, the display value loses trailing decimal points. For email inputs,
Chrome raises “The specified value <x> is not a valid email address”.</p>
<p>Here we check to see if the defaultValue has actually changed, avoiding these problems
when the user is inputting text</p>
<p><a href="https://github.com/facebook/react/issues/7253">https://github.com/facebook/react/issues/7253</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setDefaultValue</span>(<span class="hljs-params">node, type, value</span>) {
    <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Focused number inputs synchronize on blur. See ChangeEventPlugin.js</span>
      type !== <span class="hljs-string">&#x27;number&#x27;</span> || <span class="hljs-title function_">getActiveElement</span>(node.<span class="hljs-property">ownerDocument</span>) !== node) {
      <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) {
        node.<span class="hljs-property">defaultValue</span> = <span class="hljs-title function_">toString</span>(node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">initialValue</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">defaultValue</span> !== <span class="hljs-title function_">toString</span>(value)) {
        node.<span class="hljs-property">defaultValue</span> = <span class="hljs-title function_">toString</span>(value);
      }
    }
  }

  <span class="hljs-keyword">var</span> didWarnSelectedSetOnOption = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> didWarnInvalidChild = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flattenChildren</span>(<span class="hljs-params">children</span>) {
    <span class="hljs-keyword">var</span> content = <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// Flatten children. We&#x27;ll warn if they are invalid</span></pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-88">&#x00a7;</a>
              </div>
              <p>during validateProps() which runs for hydration too.
Note that this would throw on non-element objects.
Elements are stringified (which is normally irrelevant
but matters for <fbt>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title class_">React</span>.<span class="hljs-property">Children</span>.<span class="hljs-title function_">forEach</span>(children, <span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) {
      <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>;
      }

      content += child; <span class="hljs-comment">// Note: we don&#x27;t warn about invalid children here.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-89">&#x00a7;</a>
              </div>
              <p>Instead, this is done separately below so that
it happens during the hydration code path too.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    });
    <span class="hljs-keyword">return</span> content;
  }
  <span class="hljs-comment">/**
   * Implements an &lt;option&gt; host component that warns when `selected` is set.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateProps</span>(<span class="hljs-params">element, props</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-90">&#x00a7;</a>
              </div>
              <p>This mirrors the code path above, but runs for hydration too.
Warn about invalid children here so that client and hydration are consistent.
TODO: this seems like it could cause a DEV-only throw for hydration
if children contains a non-element object. We should try to avoid that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; props.<span class="hljs-property">children</span> !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title class_">React</span>.<span class="hljs-property">Children</span>.<span class="hljs-title function_">forEach</span>(props.<span class="hljs-property">children</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) {
          <span class="hljs-keyword">if</span> (child == <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> child === <span class="hljs-string">&#x27;number&#x27;</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">if</span> (!didWarnInvalidChild) {
            didWarnInvalidChild = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Only strings and numbers are supported as &lt;option&gt; children.&#x27;</span>);
          }
        });
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove support for `selected` in &lt;option&gt;.</span>


      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">selected</span> != <span class="hljs-literal">null</span> &amp;&amp; !didWarnSelectedSetOnOption) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Use the `defaultValue` or `value` props on &lt;select&gt; instead of &#x27;</span> + <span class="hljs-string">&#x27;setting `selected` on &lt;option&gt;.&#x27;</span>);

        didWarnSelectedSetOnOption = <span class="hljs-literal">true</span>;
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">postMountWrapper$1</span>(<span class="hljs-params">element, props</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-91">&#x00a7;</a>
              </div>
              <p>value=”” should make a value attribute (#6219)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">value</span> != <span class="hljs-literal">null</span>) {
      element.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-title function_">toString</span>(<span class="hljs-title function_">getToStringValue</span>(props.<span class="hljs-property">value</span>)));
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHostProps$1</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> hostProps = <span class="hljs-title function_">_assign</span>({
      <span class="hljs-attr">children</span>: <span class="hljs-literal">undefined</span>
    }, props);

    <span class="hljs-keyword">var</span> content = <span class="hljs-title function_">flattenChildren</span>(props.<span class="hljs-property">children</span>);

    <span class="hljs-keyword">if</span> (content) {
      hostProps.<span class="hljs-property">children</span> = content;
    }

    <span class="hljs-keyword">return</span> hostProps;
  }

  <span class="hljs-keyword">var</span> didWarnValueDefaultValue$<span class="hljs-number">1</span>;

  {
    didWarnValueDefaultValue$<span class="hljs-number">1</span> = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDeclarationErrorAddendum</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> ownerName = <span class="hljs-title function_">getCurrentFiberOwnerNameInDevOrNull</span>();

    <span class="hljs-keyword">if</span> (ownerName) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;\n\nCheck the render method of `&#x27;</span> + ownerName + <span class="hljs-string">&#x27;`.&#x27;</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
  }

  <span class="hljs-keyword">var</span> valuePropNames = [<span class="hljs-string">&#x27;value&#x27;</span>, <span class="hljs-string">&#x27;defaultValue&#x27;</span>];
  <span class="hljs-comment">/**
   * Validation function for `value` and `defaultValue`.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkSelectPropTypes</span>(<span class="hljs-params">props</span>) {
    {
      <span class="hljs-title function_">checkControlledValueProps</span>(<span class="hljs-string">&#x27;select&#x27;</span>, props);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; valuePropNames.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">var</span> propName = valuePropNames[i];

        <span class="hljs-keyword">if</span> (props[propName] == <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> isArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(props[propName]);

        <span class="hljs-keyword">if</span> (props.<span class="hljs-property">multiple</span> &amp;&amp; !isArray) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The `%s` prop supplied to &lt;select&gt; must be an array if &#x27;</span> + <span class="hljs-string">&#x27;`multiple` is true.%s&#x27;</span>, propName, <span class="hljs-title function_">getDeclarationErrorAddendum</span>());
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">multiple</span> &amp;&amp; isArray) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The `%s` prop supplied to &lt;select&gt; must be a scalar &#x27;</span> + <span class="hljs-string">&#x27;value if `multiple` is false.%s&#x27;</span>, propName, <span class="hljs-title function_">getDeclarationErrorAddendum</span>());
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateOptions</span>(<span class="hljs-params">node, multiple, propValue, setDefaultSelected</span>) {
    <span class="hljs-keyword">var</span> options = node.<span class="hljs-property">options</span>;

    <span class="hljs-keyword">if</span> (multiple) {
      <span class="hljs-keyword">var</span> selectedValues = propValue;
      <span class="hljs-keyword">var</span> selectedValue = {};

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; selectedValues.<span class="hljs-property">length</span>; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-92">&#x00a7;</a>
              </div>
              <p>Prefix to avoid chaos with special keys.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        selectedValue[<span class="hljs-string">&#x27;$&#x27;</span> + selectedValues[i]] = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; options.<span class="hljs-property">length</span>; _i++) {
        <span class="hljs-keyword">var</span> selected = selectedValue.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;$&#x27;</span> + options[_i].<span class="hljs-property">value</span>);

        <span class="hljs-keyword">if</span> (options[_i].<span class="hljs-property">selected</span> !== selected) {
          options[_i].<span class="hljs-property">selected</span> = selected;
        }

        <span class="hljs-keyword">if</span> (selected &amp;&amp; setDefaultSelected) {
          options[_i].<span class="hljs-property">defaultSelected</span> = <span class="hljs-literal">true</span>;
        }
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-93">&#x00a7;</a>
              </div>
              <p>Do not set <code>select.value</code> as exact behavior isn’t consistent across all
browsers for all cases.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> _selectedValue = <span class="hljs-title function_">toString</span>(<span class="hljs-title function_">getToStringValue</span>(propValue));

      <span class="hljs-keyword">var</span> defaultSelected = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i2 = <span class="hljs-number">0</span>; _i2 &lt; options.<span class="hljs-property">length</span>; _i2++) {
        <span class="hljs-keyword">if</span> (options[_i2].<span class="hljs-property">value</span> === _selectedValue) {
          options[_i2].<span class="hljs-property">selected</span> = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">if</span> (setDefaultSelected) {
            options[_i2].<span class="hljs-property">defaultSelected</span> = <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (defaultSelected === <span class="hljs-literal">null</span> &amp;&amp; !options[_i2].<span class="hljs-property">disabled</span>) {
          defaultSelected = options[_i2];
        }
      }

      <span class="hljs-keyword">if</span> (defaultSelected !== <span class="hljs-literal">null</span>) {
        defaultSelected.<span class="hljs-property">selected</span> = <span class="hljs-literal">true</span>;
      }
    }
  }
  <span class="hljs-comment">/**
   * Implements a &lt;select&gt; host component that allows optionally setting the
   * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
   * stringable. If `multiple` is true, the prop must be an array of stringables.
   *
   * If `value` is not supplied (or null/undefined), user actions that change the
   * selected option will trigger updates to the rendered options.
   *
   * If it is supplied (and not null/undefined), the rendered options will not
   * update in response to user actions. Instead, the `value` prop must change in
   * order for the rendered options to update.
   *
   * If `defaultValue` is provided, any options with the supplied values will be
   * selected.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHostProps$2</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">_assign</span>({}, props, {
      <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>
    });
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">initWrapperState$1</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;

    {
      <span class="hljs-title function_">checkSelectPropTypes</span>(props);
    }

    node.<span class="hljs-property">_wrapperState</span> = {
      <span class="hljs-attr">wasMultiple</span>: !!props.<span class="hljs-property">multiple</span>
    };

    {
      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">value</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; props.<span class="hljs-property">defaultValue</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnValueDefaultValue$<span class="hljs-number">1</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Select elements must be either controlled or uncontrolled &#x27;</span> + <span class="hljs-string">&#x27;(specify either the value prop, or the defaultValue prop, but not &#x27;</span> + <span class="hljs-string">&#x27;both). Decide between using a controlled or uncontrolled select &#x27;</span> + <span class="hljs-string">&#x27;element and remove one of these props. More info: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/controlled-components&#x27;</span>);

        didWarnValueDefaultValue$<span class="hljs-number">1</span> = <span class="hljs-literal">true</span>;
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">postMountWrapper$2</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;
    node.<span class="hljs-property">multiple</span> = !!props.<span class="hljs-property">multiple</span>;
    <span class="hljs-keyword">var</span> value = props.<span class="hljs-property">value</span>;

    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">updateOptions</span>(node, !!props.<span class="hljs-property">multiple</span>, value, <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (props.<span class="hljs-property">defaultValue</span> != <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">updateOptions</span>(node, !!props.<span class="hljs-property">multiple</span>, props.<span class="hljs-property">defaultValue</span>, <span class="hljs-literal">true</span>);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">postUpdateWrapper</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;
    <span class="hljs-keyword">var</span> wasMultiple = node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">wasMultiple</span>;
    node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">wasMultiple</span> = !!props.<span class="hljs-property">multiple</span>;
    <span class="hljs-keyword">var</span> value = props.<span class="hljs-property">value</span>;

    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">updateOptions</span>(node, !!props.<span class="hljs-property">multiple</span>, value, <span class="hljs-literal">false</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wasMultiple !== !!props.<span class="hljs-property">multiple</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-94">&#x00a7;</a>
              </div>
              <p>For simplicity, reapply <code>defaultValue</code> if <code>multiple</code> is toggled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">defaultValue</span> != <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">updateOptions</span>(node, !!props.<span class="hljs-property">multiple</span>, props.<span class="hljs-property">defaultValue</span>, <span class="hljs-literal">true</span>);
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-95">&#x00a7;</a>
              </div>
              <p>Revert the select back to its default unselected state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">updateOptions</span>(node, !!props.<span class="hljs-property">multiple</span>, props.<span class="hljs-property">multiple</span> ? [] : <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-literal">false</span>);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreControlledState$1</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;
    <span class="hljs-keyword">var</span> value = props.<span class="hljs-property">value</span>;

    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">updateOptions</span>(node, !!props.<span class="hljs-property">multiple</span>, value, <span class="hljs-literal">false</span>);
    }
  }

  <span class="hljs-keyword">var</span> didWarnValDefaultVal = <span class="hljs-literal">false</span>;

  <span class="hljs-comment">/**
   * Implements a &lt;textarea&gt; host component that allows setting `value`, and
   * `defaultValue`. This differs from the traditional DOM API because value is
   * usually set as PCDATA children.
   *
   * If `value` is not supplied (or null/undefined), user actions that affect the
   * value will trigger updates to the element.
   *
   * If `value` is supplied (and not null/undefined), the rendered element will
   * not trigger updates to the element. Instead, the `value` prop must change in
   * order for the rendered element to be updated.
   *
   * The rendered element will be initialized with an empty value, the prop
   * `defaultValue` if specified, or the children content (deprecated).
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHostProps$3</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;

    <span class="hljs-keyword">if</span> (!(props.<span class="hljs-property">dangerouslySetInnerHTML</span> == <span class="hljs-literal">null</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;`dangerouslySetInnerHTML` does not make sense on &lt;textarea&gt;.&quot;</span>);
      }
    } <span class="hljs-comment">// Always set children to the same thing. In IE9, the selection range will</span></pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-96">&#x00a7;</a>
              </div>
              <p>get reset if <code>textContent</code> is mutated.  We could add a check in setTextContent
to only set the value if/when the value differs from the node value (which would
completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
solution. The value can be a boolean or object so that’s why it’s forced
to be a string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> hostProps = <span class="hljs-title function_">_assign</span>({}, props, {
      <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-attr">defaultValue</span>: <span class="hljs-literal">undefined</span>,
      <span class="hljs-attr">children</span>: <span class="hljs-title function_">toString</span>(node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">initialValue</span>)
    });

    <span class="hljs-keyword">return</span> hostProps;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">initWrapperState$2</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;

    {
      <span class="hljs-title function_">checkControlledValueProps</span>(<span class="hljs-string">&#x27;textarea&#x27;</span>, props);

      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">value</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; props.<span class="hljs-property">defaultValue</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnValDefaultVal) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s contains a textarea with both value and defaultValue props. &#x27;</span> + <span class="hljs-string">&#x27;Textarea elements must be either controlled or uncontrolled &#x27;</span> + <span class="hljs-string">&#x27;(specify either the value prop, or the defaultValue prop, but not &#x27;</span> + <span class="hljs-string">&#x27;both). Decide between using a controlled or uncontrolled textarea &#x27;</span> + <span class="hljs-string">&#x27;and remove one of these props. More info: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/controlled-components&#x27;</span>, <span class="hljs-title function_">getCurrentFiberOwnerNameInDevOrNull</span>() || <span class="hljs-string">&#x27;A component&#x27;</span>);

        didWarnValDefaultVal = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">var</span> initialValue = props.<span class="hljs-property">value</span>; <span class="hljs-comment">// Only bother fetching default value if we&#x27;re going to use it</span>

    <span class="hljs-keyword">if</span> (initialValue == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> children = props.<span class="hljs-property">children</span>,
        defaultValue = props.<span class="hljs-property">defaultValue</span>;

      <span class="hljs-keyword">if</span> (children != <span class="hljs-literal">null</span>) {
        {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Use the `defaultValue` or `value` props instead of setting &#x27;</span> + <span class="hljs-string">&#x27;children on &lt;textarea&gt;.&#x27;</span>);
        }

        {
          <span class="hljs-keyword">if</span> (!(defaultValue == <span class="hljs-literal">null</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;If you supply `defaultValue` on a &lt;textarea&gt;, do not pass children.&quot;</span>);
            }
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(children)) {
            <span class="hljs-keyword">if</span> (!(children.<span class="hljs-property">length</span> &lt;= <span class="hljs-number">1</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;&lt;textarea&gt; can only have at most one child.&quot;</span>);
              }
            }

            children = children[<span class="hljs-number">0</span>];
          }

          defaultValue = children;
        }
      }

      <span class="hljs-keyword">if</span> (defaultValue == <span class="hljs-literal">null</span>) {
        defaultValue = <span class="hljs-string">&#x27;&#x27;</span>;
      }

      initialValue = defaultValue;
    }

    node.<span class="hljs-property">_wrapperState</span> = {
      <span class="hljs-attr">initialValue</span>: <span class="hljs-title function_">getToStringValue</span>(initialValue)
    };
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateWrapper$1</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element;
    <span class="hljs-keyword">var</span> value = <span class="hljs-title function_">getToStringValue</span>(props.<span class="hljs-property">value</span>);
    <span class="hljs-keyword">var</span> defaultValue = <span class="hljs-title function_">getToStringValue</span>(props.<span class="hljs-property">defaultValue</span>);

    <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-97">&#x00a7;</a>
              </div>
              <p>Cast <code>value</code> to a string to ensure the value is set correctly. While
browsers typically do this as necessary, jsdom doesn’t.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> newValue = <span class="hljs-title function_">toString</span>(value); <span class="hljs-comment">// To avoid side effects (such as losing text selection), only set value if changed</span>

      <span class="hljs-keyword">if</span> (newValue !== node.<span class="hljs-property">value</span>) {
        node.<span class="hljs-property">value</span> = newValue;
      }

      <span class="hljs-keyword">if</span> (props.<span class="hljs-property">defaultValue</span> == <span class="hljs-literal">null</span> &amp;&amp; node.<span class="hljs-property">defaultValue</span> !== newValue) {
        node.<span class="hljs-property">defaultValue</span> = newValue;
      }
    }

    <span class="hljs-keyword">if</span> (defaultValue != <span class="hljs-literal">null</span>) {
      node.<span class="hljs-property">defaultValue</span> = <span class="hljs-title function_">toString</span>(defaultValue);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">postMountWrapper$3</span>(<span class="hljs-params">element, props</span>) {
    <span class="hljs-keyword">var</span> node = element; <span class="hljs-comment">// This is in postMount because we need access to the DOM node, which is not</span></pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-98">&#x00a7;</a>
              </div>
              <p>available until after the component has mounted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> textContent = node.<span class="hljs-property">textContent</span>; <span class="hljs-comment">// Only set node.value if textContent is equal to the expected</span></pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-99">&#x00a7;</a>
              </div>
              <p>initial value. In IE10/IE11 there is a bug where the placeholder attribute
will populate textContent as well.
<a href="https://developer.microsoft.com/microsoft-edge/platform/issues/101525/">https://developer.microsoft.com/microsoft-edge/platform/issues/101525/</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (textContent === node.<span class="hljs-property">_wrapperState</span>.<span class="hljs-property">initialValue</span>) {
      <span class="hljs-keyword">if</span> (textContent !== <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; textContent !== <span class="hljs-literal">null</span>) {
        node.<span class="hljs-property">value</span> = textContent;
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreControlledState$2</span>(<span class="hljs-params">element, props</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-100">&#x00a7;</a>
              </div>
              <p>DOM component is still mounted; update</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">updateWrapper$1</span>(element, props);
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">HTML_NAMESPACE</span> = <span class="hljs-string">&#x27;http://www.w3.org/1999/xhtml&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">MATH_NAMESPACE</span> = <span class="hljs-string">&#x27;http://www.w3.org/1998/Math/MathML&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SVG_NAMESPACE</span> = <span class="hljs-string">&#x27;http://www.w3.org/2000/svg&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Namespaces</span> = {
    <span class="hljs-attr">html</span>: <span class="hljs-variable constant_">HTML_NAMESPACE</span>,
    <span class="hljs-attr">mathml</span>: <span class="hljs-variable constant_">MATH_NAMESPACE</span>,
    <span class="hljs-attr">svg</span>: <span class="hljs-variable constant_">SVG_NAMESPACE</span>
  }; <span class="hljs-comment">// Assumes there is no parent namespace.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getIntrinsicNamespace</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">switch</span> (type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;svg&#x27;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">SVG_NAMESPACE</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;math&#x27;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">MATH_NAMESPACE</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">HTML_NAMESPACE</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getChildNamespace</span>(<span class="hljs-params">parentNamespace, type</span>) {
    <span class="hljs-keyword">if</span> (parentNamespace == <span class="hljs-literal">null</span> || parentNamespace === <span class="hljs-variable constant_">HTML_NAMESPACE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-101">&#x00a7;</a>
              </div>
              <p>No (or default) parent namespace: potential entry point.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getIntrinsicNamespace</span>(type);
    }

    <span class="hljs-keyword">if</span> (parentNamespace === <span class="hljs-variable constant_">SVG_NAMESPACE</span> &amp;&amp; type === <span class="hljs-string">&#x27;foreignObject&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-102">&#x00a7;</a>
              </div>
              <p>We’re leaving SVG.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">HTML_NAMESPACE</span>;
    } <span class="hljs-comment">// By default, pass namespace below.</span>


    <span class="hljs-keyword">return</span> parentNamespace;
  }

  <span class="hljs-comment">/* globals MSApp */</span>

  <span class="hljs-comment">/**
   * Create a function which has &#x27;unsafe&#x27; privileges (required by windows8 apps)
   */</span>
  <span class="hljs-keyword">var</span> createMicrosoftUnsafeLocalFunction = <span class="hljs-keyword">function</span> (<span class="hljs-params">func</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MSApp</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title class_">MSApp</span>.<span class="hljs-property">execUnsafeLocalFunction</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">arg0, arg1, arg2, arg3</span>) {
        <span class="hljs-title class_">MSApp</span>.<span class="hljs-title function_">execUnsafeLocalFunction</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">func</span>(arg0, arg1, arg2, arg3);
        });
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> func;
    }
  };

  <span class="hljs-keyword">var</span> reusableSVGContainer;
  <span class="hljs-comment">/**
   * Set the innerHTML property of a node
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement</span>} <span class="hljs-variable">node</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">html</span>
   * <span class="hljs-doctag">@internal</span>
   */</span>

  <span class="hljs-keyword">var</span> setInnerHTML = <span class="hljs-title function_">createMicrosoftUnsafeLocalFunction</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">node, html</span>) {
    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">namespaceURI</span> === <span class="hljs-title class_">Namespaces</span>.<span class="hljs-property">svg</span>) {

      <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;innerHTML&#x27;</span> <span class="hljs-keyword">in</span> node)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-103">&#x00a7;</a>
              </div>
              <p>IE does not have innerHTML for SVG nodes, so instead we inject the
new markup in a temp node and then move the child nodes across into
the target node</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        reusableSVGContainer = reusableSVGContainer || <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
        reusableSVGContainer.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;svg&gt;&#x27;</span> + html.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">toString</span>() + <span class="hljs-string">&#x27;&lt;/svg&gt;&#x27;</span>;
        <span class="hljs-keyword">var</span> svgNode = reusableSVGContainer.<span class="hljs-property">firstChild</span>;

        <span class="hljs-keyword">while</span> (node.<span class="hljs-property">firstChild</span>) {
          node.<span class="hljs-title function_">removeChild</span>(node.<span class="hljs-property">firstChild</span>);
        }

        <span class="hljs-keyword">while</span> (svgNode.<span class="hljs-property">firstChild</span>) {
          node.<span class="hljs-title function_">appendChild</span>(svgNode.<span class="hljs-property">firstChild</span>);
        }

        <span class="hljs-keyword">return</span>;
      }
    }

    node.<span class="hljs-property">innerHTML</span> = html;
  });

  <span class="hljs-comment">/**
   * HTML nodeType values that represent the type of the node
   */</span>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ELEMENT_NODE</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">TEXT_NODE</span> = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">COMMENT_NODE</span> = <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">DOCUMENT_NODE</span> = <span class="hljs-number">9</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">DOCUMENT_FRAGMENT_NODE</span> = <span class="hljs-number">11</span>;

  <span class="hljs-comment">/**
   * Set the textContent property of a node. For text updates, it&#x27;s faster
   * to set the `nodeValue` of the Text node directly instead of using
   * `.textContent` which will remove the existing node and create a new one.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement</span>} <span class="hljs-variable">node</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">text</span>
   * <span class="hljs-doctag">@internal</span>
   */</span>

  <span class="hljs-keyword">var</span> setTextContent = <span class="hljs-keyword">function</span> (<span class="hljs-params">node, text</span>) {
    <span class="hljs-keyword">if</span> (text) {
      <span class="hljs-keyword">var</span> firstChild = node.<span class="hljs-property">firstChild</span>;

      <span class="hljs-keyword">if</span> (firstChild &amp;&amp; firstChild === node.<span class="hljs-property">lastChild</span> &amp;&amp; firstChild.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span>) {
        firstChild.<span class="hljs-property">nodeValue</span> = text;
        <span class="hljs-keyword">return</span>;
      }
    }

    node.<span class="hljs-property">textContent</span> = text;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-104">&#x00a7;</a>
              </div>
              <p>List derived from Gecko source code:
<a href="https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js">https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> shorthandToLonghand = {
    <span class="hljs-attr">animation</span>: [<span class="hljs-string">&#x27;animationDelay&#x27;</span>, <span class="hljs-string">&#x27;animationDirection&#x27;</span>, <span class="hljs-string">&#x27;animationDuration&#x27;</span>, <span class="hljs-string">&#x27;animationFillMode&#x27;</span>, <span class="hljs-string">&#x27;animationIterationCount&#x27;</span>, <span class="hljs-string">&#x27;animationName&#x27;</span>, <span class="hljs-string">&#x27;animationPlayState&#x27;</span>, <span class="hljs-string">&#x27;animationTimingFunction&#x27;</span>],
    <span class="hljs-attr">background</span>: [<span class="hljs-string">&#x27;backgroundAttachment&#x27;</span>, <span class="hljs-string">&#x27;backgroundClip&#x27;</span>, <span class="hljs-string">&#x27;backgroundColor&#x27;</span>, <span class="hljs-string">&#x27;backgroundImage&#x27;</span>, <span class="hljs-string">&#x27;backgroundOrigin&#x27;</span>, <span class="hljs-string">&#x27;backgroundPositionX&#x27;</span>, <span class="hljs-string">&#x27;backgroundPositionY&#x27;</span>, <span class="hljs-string">&#x27;backgroundRepeat&#x27;</span>, <span class="hljs-string">&#x27;backgroundSize&#x27;</span>],
    <span class="hljs-attr">backgroundPosition</span>: [<span class="hljs-string">&#x27;backgroundPositionX&#x27;</span>, <span class="hljs-string">&#x27;backgroundPositionY&#x27;</span>],
    <span class="hljs-attr">border</span>: [<span class="hljs-string">&#x27;borderBottomColor&#x27;</span>, <span class="hljs-string">&#x27;borderBottomStyle&#x27;</span>, <span class="hljs-string">&#x27;borderBottomWidth&#x27;</span>, <span class="hljs-string">&#x27;borderImageOutset&#x27;</span>, <span class="hljs-string">&#x27;borderImageRepeat&#x27;</span>, <span class="hljs-string">&#x27;borderImageSlice&#x27;</span>, <span class="hljs-string">&#x27;borderImageSource&#x27;</span>, <span class="hljs-string">&#x27;borderImageWidth&#x27;</span>, <span class="hljs-string">&#x27;borderLeftColor&#x27;</span>, <span class="hljs-string">&#x27;borderLeftStyle&#x27;</span>, <span class="hljs-string">&#x27;borderLeftWidth&#x27;</span>, <span class="hljs-string">&#x27;borderRightColor&#x27;</span>, <span class="hljs-string">&#x27;borderRightStyle&#x27;</span>, <span class="hljs-string">&#x27;borderRightWidth&#x27;</span>, <span class="hljs-string">&#x27;borderTopColor&#x27;</span>, <span class="hljs-string">&#x27;borderTopStyle&#x27;</span>, <span class="hljs-string">&#x27;borderTopWidth&#x27;</span>],
    <span class="hljs-attr">borderBlockEnd</span>: [<span class="hljs-string">&#x27;borderBlockEndColor&#x27;</span>, <span class="hljs-string">&#x27;borderBlockEndStyle&#x27;</span>, <span class="hljs-string">&#x27;borderBlockEndWidth&#x27;</span>],
    <span class="hljs-attr">borderBlockStart</span>: [<span class="hljs-string">&#x27;borderBlockStartColor&#x27;</span>, <span class="hljs-string">&#x27;borderBlockStartStyle&#x27;</span>, <span class="hljs-string">&#x27;borderBlockStartWidth&#x27;</span>],
    <span class="hljs-attr">borderBottom</span>: [<span class="hljs-string">&#x27;borderBottomColor&#x27;</span>, <span class="hljs-string">&#x27;borderBottomStyle&#x27;</span>, <span class="hljs-string">&#x27;borderBottomWidth&#x27;</span>],
    <span class="hljs-attr">borderColor</span>: [<span class="hljs-string">&#x27;borderBottomColor&#x27;</span>, <span class="hljs-string">&#x27;borderLeftColor&#x27;</span>, <span class="hljs-string">&#x27;borderRightColor&#x27;</span>, <span class="hljs-string">&#x27;borderTopColor&#x27;</span>],
    <span class="hljs-attr">borderImage</span>: [<span class="hljs-string">&#x27;borderImageOutset&#x27;</span>, <span class="hljs-string">&#x27;borderImageRepeat&#x27;</span>, <span class="hljs-string">&#x27;borderImageSlice&#x27;</span>, <span class="hljs-string">&#x27;borderImageSource&#x27;</span>, <span class="hljs-string">&#x27;borderImageWidth&#x27;</span>],
    <span class="hljs-attr">borderInlineEnd</span>: [<span class="hljs-string">&#x27;borderInlineEndColor&#x27;</span>, <span class="hljs-string">&#x27;borderInlineEndStyle&#x27;</span>, <span class="hljs-string">&#x27;borderInlineEndWidth&#x27;</span>],
    <span class="hljs-attr">borderInlineStart</span>: [<span class="hljs-string">&#x27;borderInlineStartColor&#x27;</span>, <span class="hljs-string">&#x27;borderInlineStartStyle&#x27;</span>, <span class="hljs-string">&#x27;borderInlineStartWidth&#x27;</span>],
    <span class="hljs-attr">borderLeft</span>: [<span class="hljs-string">&#x27;borderLeftColor&#x27;</span>, <span class="hljs-string">&#x27;borderLeftStyle&#x27;</span>, <span class="hljs-string">&#x27;borderLeftWidth&#x27;</span>],
    <span class="hljs-attr">borderRadius</span>: [<span class="hljs-string">&#x27;borderBottomLeftRadius&#x27;</span>, <span class="hljs-string">&#x27;borderBottomRightRadius&#x27;</span>, <span class="hljs-string">&#x27;borderTopLeftRadius&#x27;</span>, <span class="hljs-string">&#x27;borderTopRightRadius&#x27;</span>],
    <span class="hljs-attr">borderRight</span>: [<span class="hljs-string">&#x27;borderRightColor&#x27;</span>, <span class="hljs-string">&#x27;borderRightStyle&#x27;</span>, <span class="hljs-string">&#x27;borderRightWidth&#x27;</span>],
    <span class="hljs-attr">borderStyle</span>: [<span class="hljs-string">&#x27;borderBottomStyle&#x27;</span>, <span class="hljs-string">&#x27;borderLeftStyle&#x27;</span>, <span class="hljs-string">&#x27;borderRightStyle&#x27;</span>, <span class="hljs-string">&#x27;borderTopStyle&#x27;</span>],
    <span class="hljs-attr">borderTop</span>: [<span class="hljs-string">&#x27;borderTopColor&#x27;</span>, <span class="hljs-string">&#x27;borderTopStyle&#x27;</span>, <span class="hljs-string">&#x27;borderTopWidth&#x27;</span>],
    <span class="hljs-attr">borderWidth</span>: [<span class="hljs-string">&#x27;borderBottomWidth&#x27;</span>, <span class="hljs-string">&#x27;borderLeftWidth&#x27;</span>, <span class="hljs-string">&#x27;borderRightWidth&#x27;</span>, <span class="hljs-string">&#x27;borderTopWidth&#x27;</span>],
    <span class="hljs-attr">columnRule</span>: [<span class="hljs-string">&#x27;columnRuleColor&#x27;</span>, <span class="hljs-string">&#x27;columnRuleStyle&#x27;</span>, <span class="hljs-string">&#x27;columnRuleWidth&#x27;</span>],
    <span class="hljs-attr">columns</span>: [<span class="hljs-string">&#x27;columnCount&#x27;</span>, <span class="hljs-string">&#x27;columnWidth&#x27;</span>],
    <span class="hljs-attr">flex</span>: [<span class="hljs-string">&#x27;flexBasis&#x27;</span>, <span class="hljs-string">&#x27;flexGrow&#x27;</span>, <span class="hljs-string">&#x27;flexShrink&#x27;</span>],
    <span class="hljs-attr">flexFlow</span>: [<span class="hljs-string">&#x27;flexDirection&#x27;</span>, <span class="hljs-string">&#x27;flexWrap&#x27;</span>],
    <span class="hljs-attr">font</span>: [<span class="hljs-string">&#x27;fontFamily&#x27;</span>, <span class="hljs-string">&#x27;fontFeatureSettings&#x27;</span>, <span class="hljs-string">&#x27;fontKerning&#x27;</span>, <span class="hljs-string">&#x27;fontLanguageOverride&#x27;</span>, <span class="hljs-string">&#x27;fontSize&#x27;</span>, <span class="hljs-string">&#x27;fontSizeAdjust&#x27;</span>, <span class="hljs-string">&#x27;fontStretch&#x27;</span>, <span class="hljs-string">&#x27;fontStyle&#x27;</span>, <span class="hljs-string">&#x27;fontVariant&#x27;</span>, <span class="hljs-string">&#x27;fontVariantAlternates&#x27;</span>, <span class="hljs-string">&#x27;fontVariantCaps&#x27;</span>, <span class="hljs-string">&#x27;fontVariantEastAsian&#x27;</span>, <span class="hljs-string">&#x27;fontVariantLigatures&#x27;</span>, <span class="hljs-string">&#x27;fontVariantNumeric&#x27;</span>, <span class="hljs-string">&#x27;fontVariantPosition&#x27;</span>, <span class="hljs-string">&#x27;fontWeight&#x27;</span>, <span class="hljs-string">&#x27;lineHeight&#x27;</span>],
    <span class="hljs-attr">fontVariant</span>: [<span class="hljs-string">&#x27;fontVariantAlternates&#x27;</span>, <span class="hljs-string">&#x27;fontVariantCaps&#x27;</span>, <span class="hljs-string">&#x27;fontVariantEastAsian&#x27;</span>, <span class="hljs-string">&#x27;fontVariantLigatures&#x27;</span>, <span class="hljs-string">&#x27;fontVariantNumeric&#x27;</span>, <span class="hljs-string">&#x27;fontVariantPosition&#x27;</span>],
    <span class="hljs-attr">gap</span>: [<span class="hljs-string">&#x27;columnGap&#x27;</span>, <span class="hljs-string">&#x27;rowGap&#x27;</span>],
    <span class="hljs-attr">grid</span>: [<span class="hljs-string">&#x27;gridAutoColumns&#x27;</span>, <span class="hljs-string">&#x27;gridAutoFlow&#x27;</span>, <span class="hljs-string">&#x27;gridAutoRows&#x27;</span>, <span class="hljs-string">&#x27;gridTemplateAreas&#x27;</span>, <span class="hljs-string">&#x27;gridTemplateColumns&#x27;</span>, <span class="hljs-string">&#x27;gridTemplateRows&#x27;</span>],
    <span class="hljs-attr">gridArea</span>: [<span class="hljs-string">&#x27;gridColumnEnd&#x27;</span>, <span class="hljs-string">&#x27;gridColumnStart&#x27;</span>, <span class="hljs-string">&#x27;gridRowEnd&#x27;</span>, <span class="hljs-string">&#x27;gridRowStart&#x27;</span>],
    <span class="hljs-attr">gridColumn</span>: [<span class="hljs-string">&#x27;gridColumnEnd&#x27;</span>, <span class="hljs-string">&#x27;gridColumnStart&#x27;</span>],
    <span class="hljs-attr">gridColumnGap</span>: [<span class="hljs-string">&#x27;columnGap&#x27;</span>],
    <span class="hljs-attr">gridGap</span>: [<span class="hljs-string">&#x27;columnGap&#x27;</span>, <span class="hljs-string">&#x27;rowGap&#x27;</span>],
    <span class="hljs-attr">gridRow</span>: [<span class="hljs-string">&#x27;gridRowEnd&#x27;</span>, <span class="hljs-string">&#x27;gridRowStart&#x27;</span>],
    <span class="hljs-attr">gridRowGap</span>: [<span class="hljs-string">&#x27;rowGap&#x27;</span>],
    <span class="hljs-attr">gridTemplate</span>: [<span class="hljs-string">&#x27;gridTemplateAreas&#x27;</span>, <span class="hljs-string">&#x27;gridTemplateColumns&#x27;</span>, <span class="hljs-string">&#x27;gridTemplateRows&#x27;</span>],
    <span class="hljs-attr">listStyle</span>: [<span class="hljs-string">&#x27;listStyleImage&#x27;</span>, <span class="hljs-string">&#x27;listStylePosition&#x27;</span>, <span class="hljs-string">&#x27;listStyleType&#x27;</span>],
    <span class="hljs-attr">margin</span>: [<span class="hljs-string">&#x27;marginBottom&#x27;</span>, <span class="hljs-string">&#x27;marginLeft&#x27;</span>, <span class="hljs-string">&#x27;marginRight&#x27;</span>, <span class="hljs-string">&#x27;marginTop&#x27;</span>],
    <span class="hljs-attr">marker</span>: [<span class="hljs-string">&#x27;markerEnd&#x27;</span>, <span class="hljs-string">&#x27;markerMid&#x27;</span>, <span class="hljs-string">&#x27;markerStart&#x27;</span>],
    <span class="hljs-attr">mask</span>: [<span class="hljs-string">&#x27;maskClip&#x27;</span>, <span class="hljs-string">&#x27;maskComposite&#x27;</span>, <span class="hljs-string">&#x27;maskImage&#x27;</span>, <span class="hljs-string">&#x27;maskMode&#x27;</span>, <span class="hljs-string">&#x27;maskOrigin&#x27;</span>, <span class="hljs-string">&#x27;maskPositionX&#x27;</span>, <span class="hljs-string">&#x27;maskPositionY&#x27;</span>, <span class="hljs-string">&#x27;maskRepeat&#x27;</span>, <span class="hljs-string">&#x27;maskSize&#x27;</span>],
    <span class="hljs-attr">maskPosition</span>: [<span class="hljs-string">&#x27;maskPositionX&#x27;</span>, <span class="hljs-string">&#x27;maskPositionY&#x27;</span>],
    <span class="hljs-attr">outline</span>: [<span class="hljs-string">&#x27;outlineColor&#x27;</span>, <span class="hljs-string">&#x27;outlineStyle&#x27;</span>, <span class="hljs-string">&#x27;outlineWidth&#x27;</span>],
    <span class="hljs-attr">overflow</span>: [<span class="hljs-string">&#x27;overflowX&#x27;</span>, <span class="hljs-string">&#x27;overflowY&#x27;</span>],
    <span class="hljs-attr">padding</span>: [<span class="hljs-string">&#x27;paddingBottom&#x27;</span>, <span class="hljs-string">&#x27;paddingLeft&#x27;</span>, <span class="hljs-string">&#x27;paddingRight&#x27;</span>, <span class="hljs-string">&#x27;paddingTop&#x27;</span>],
    <span class="hljs-attr">placeContent</span>: [<span class="hljs-string">&#x27;alignContent&#x27;</span>, <span class="hljs-string">&#x27;justifyContent&#x27;</span>],
    <span class="hljs-attr">placeItems</span>: [<span class="hljs-string">&#x27;alignItems&#x27;</span>, <span class="hljs-string">&#x27;justifyItems&#x27;</span>],
    <span class="hljs-attr">placeSelf</span>: [<span class="hljs-string">&#x27;alignSelf&#x27;</span>, <span class="hljs-string">&#x27;justifySelf&#x27;</span>],
    <span class="hljs-attr">textDecoration</span>: [<span class="hljs-string">&#x27;textDecorationColor&#x27;</span>, <span class="hljs-string">&#x27;textDecorationLine&#x27;</span>, <span class="hljs-string">&#x27;textDecorationStyle&#x27;</span>],
    <span class="hljs-attr">textEmphasis</span>: [<span class="hljs-string">&#x27;textEmphasisColor&#x27;</span>, <span class="hljs-string">&#x27;textEmphasisStyle&#x27;</span>],
    <span class="hljs-attr">transition</span>: [<span class="hljs-string">&#x27;transitionDelay&#x27;</span>, <span class="hljs-string">&#x27;transitionDuration&#x27;</span>, <span class="hljs-string">&#x27;transitionProperty&#x27;</span>, <span class="hljs-string">&#x27;transitionTimingFunction&#x27;</span>],
    <span class="hljs-attr">wordWrap</span>: [<span class="hljs-string">&#x27;overflowWrap&#x27;</span>]
  };

  <span class="hljs-comment">/**
   * CSS properties which accept numbers but are not in units of &quot;px&quot;.
   */</span>
  <span class="hljs-keyword">var</span> isUnitlessNumber = {
    <span class="hljs-attr">animationIterationCount</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">borderImageOutset</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">borderImageSlice</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">borderImageWidth</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">boxFlex</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">boxFlexGroup</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">boxOrdinalGroup</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">columnCount</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">columns</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">flex</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">flexGrow</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">flexPositive</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">flexShrink</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">flexNegative</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">flexOrder</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridArea</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridRow</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridRowEnd</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridRowSpan</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridRowStart</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridColumn</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridColumnEnd</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridColumnSpan</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">gridColumnStart</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">fontWeight</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">lineClamp</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">lineHeight</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">order</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">orphans</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">tabSize</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">widows</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">zIndex</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">zoom</span>: <span class="hljs-literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-105">&#x00a7;</a>
              </div>
              <p>SVG-related properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-attr">fillOpacity</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">floodOpacity</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">stopOpacity</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">strokeDasharray</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">strokeDashoffset</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">strokeMiterlimit</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">strokeOpacity</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">strokeWidth</span>: <span class="hljs-literal">true</span>
  };
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} prefix vendor-specific prefix, eg: Webkit
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} key style name, eg: transitionDuration
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} style name prefixed with `prefix`, properly camelCased, eg:
   * WebkitTransitionDuration
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prefixKey</span>(<span class="hljs-params">prefix, key</span>) {
    <span class="hljs-keyword">return</span> prefix + key.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + key.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);
  }
  <span class="hljs-comment">/**
   * Support style names that may come passed in prefixed by adding permutations
   * of vendor prefixes.
   */</span>


  <span class="hljs-keyword">var</span> prefixes = [<span class="hljs-string">&#x27;Webkit&#x27;</span>, <span class="hljs-string">&#x27;ms&#x27;</span>, <span class="hljs-string">&#x27;Moz&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>]; <span class="hljs-comment">// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an</span></pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-106">&#x00a7;</a>
              </div>
              <p>infinite loop, because it iterates over the newly added props too.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(isUnitlessNumber).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) {
    prefixes.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) {
      isUnitlessNumber[<span class="hljs-title function_">prefixKey</span>(prefix, prop)] = isUnitlessNumber[prop];
    });
  });

  <span class="hljs-comment">/**
   * Convert a value into the proper css writable value. The style name `name`
   * should be logical (no hyphens), as specified
   * in `CSSProperty.isUnitlessNumber`.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} name CSS property name such as `topMargin`.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} value CSS property value such as `10px`.
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} Normalized style value with dimensions applied.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dangerousStyleValue</span>(<span class="hljs-params">name, value, isCustomProperty</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-107">&#x00a7;</a>
              </div>
              <p>Note that we’ve removed escapeTextForBrowser() calls here since the
whole string will be escaped when the attribute is injected into
the markup. If you provide unsafe user data here they can inject
arbitrary CSS which may be problematic (I couldn’t repro this):
<a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet</a>
<a href="http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/">http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/</a>
This is not an XSS hole but instead a potential CSS injection issue
which has lead to a greater discussion about how we’re going to
trust URLs moving forward. See #2115901</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> isEmpty = value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;boolean&#x27;</span> || value === <span class="hljs-string">&#x27;&#x27;</span>;

    <span class="hljs-keyword">if</span> (isEmpty) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
    }

    <span class="hljs-keyword">if</span> (!isCustomProperty &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; value !== <span class="hljs-number">0</span> &amp;&amp; !(isUnitlessNumber.<span class="hljs-title function_">hasOwnProperty</span>(name) &amp;&amp; isUnitlessNumber[name])) {
      <span class="hljs-keyword">return</span> value + <span class="hljs-string">&#x27;px&#x27;</span>; <span class="hljs-comment">// Presumes implicit &#x27;px&#x27; suffix for unitless numbers</span>
    }

    <span class="hljs-keyword">return</span> (<span class="hljs-string">&#x27;&#x27;</span> + value).<span class="hljs-title function_">trim</span>();
  }

  <span class="hljs-keyword">var</span> uppercasePattern = <span class="hljs-regexp">/([A-Z])/g</span>;
  <span class="hljs-keyword">var</span> msPattern = <span class="hljs-regexp">/^ms-/</span>;
  <span class="hljs-comment">/**
   * Hyphenates a camelcased CSS property name, for example:
   *
   *   &gt; hyphenateStyleName(&#x27;backgroundColor&#x27;)
   *   &lt; &quot;background-color&quot;
   *   &gt; hyphenateStyleName(&#x27;MozTransition&#x27;)
   *   &lt; &quot;-moz-transition&quot;
   *   &gt; hyphenateStyleName(&#x27;msTransition&#x27;)
   *   &lt; &quot;-ms-transition&quot;
   *
   * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
   * is converted to `-ms-`.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hyphenateStyleName</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">return</span> name.<span class="hljs-title function_">replace</span>(uppercasePattern, <span class="hljs-string">&#x27;-$1&#x27;</span>).<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">replace</span>(msPattern, <span class="hljs-string">&#x27;-ms-&#x27;</span>);
  }

  <span class="hljs-keyword">var</span> warnValidStyle = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-108">&#x00a7;</a>
              </div>
              <p>‘msTransform’ is correct, but the other prefixes should be capitalized</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> badVendoredStyleNamePattern = <span class="hljs-regexp">/^(?:webkit|moz|o)[A-Z]/</span>;
    <span class="hljs-keyword">var</span> msPattern$<span class="hljs-number">1</span> = <span class="hljs-regexp">/^-ms-/</span>;
    <span class="hljs-keyword">var</span> hyphenPattern = <span class="hljs-regexp">/-(.)/g</span>; <span class="hljs-comment">// style values shouldn&#x27;t contain a semicolon</span>

    <span class="hljs-keyword">var</span> badStyleValueWithSemicolonPattern = <span class="hljs-regexp">/;\s*$/</span>;
    <span class="hljs-keyword">var</span> warnedStyleNames = {};
    <span class="hljs-keyword">var</span> warnedStyleValues = {};
    <span class="hljs-keyword">var</span> warnedForNaNValue = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> warnedForInfinityValue = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">var</span> camelize = <span class="hljs-keyword">function</span> (<span class="hljs-params">string</span>) {
      <span class="hljs-keyword">return</span> string.<span class="hljs-title function_">replace</span>(hyphenPattern, <span class="hljs-keyword">function</span> (<span class="hljs-params">_, character</span>) {
        <span class="hljs-keyword">return</span> character.<span class="hljs-title function_">toUpperCase</span>();
      });
    };

    <span class="hljs-keyword">var</span> warnHyphenatedStyleName = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
      <span class="hljs-keyword">if</span> (warnedStyleNames.<span class="hljs-title function_">hasOwnProperty</span>(name) &amp;&amp; warnedStyleNames[name]) {
        <span class="hljs-keyword">return</span>;
      }

      warnedStyleNames[name] = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unsupported style property %s. Did you mean %s?&#x27;</span>, name, <span class="hljs-comment">// As Andi Smith suggests</span></pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-109">&#x00a7;</a>
              </div>
              <p>(<a href="http://www.andismith.com/blog/2012/02/modernizr-prefixed/">http://www.andismith.com/blog/2012/02/modernizr-prefixed/</a>), an <code>-ms</code> prefix
is converted to lowercase <code>ms</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">camelize</span>(name.<span class="hljs-title function_">replace</span>(msPattern$<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;ms-&#x27;</span>)));
    };

    <span class="hljs-keyword">var</span> warnBadVendoredStyleName = <span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
      <span class="hljs-keyword">if</span> (warnedStyleNames.<span class="hljs-title function_">hasOwnProperty</span>(name) &amp;&amp; warnedStyleNames[name]) {
        <span class="hljs-keyword">return</span>;
      }

      warnedStyleNames[name] = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unsupported vendor-prefixed style property %s. Did you mean %s?&#x27;</span>, name, name.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + name.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>));
    };

    <span class="hljs-keyword">var</span> warnStyleValueWithSemicolon = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) {
      <span class="hljs-keyword">if</span> (warnedStyleValues.<span class="hljs-title function_">hasOwnProperty</span>(value) &amp;&amp; warnedStyleValues[value]) {
        <span class="hljs-keyword">return</span>;
      }

      warnedStyleValues[value] = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Style property values shouldn&#x27;t contain a semicolon. &quot;</span> + <span class="hljs-string">&#x27;Try &quot;%s: %s&quot; instead.&#x27;</span>, name, value.<span class="hljs-title function_">replace</span>(badStyleValueWithSemicolonPattern, <span class="hljs-string">&#x27;&#x27;</span>));
    };

    <span class="hljs-keyword">var</span> warnStyleValueIsNaN = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) {
      <span class="hljs-keyword">if</span> (warnedForNaNValue) {
        <span class="hljs-keyword">return</span>;
      }

      warnedForNaNValue = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;`NaN` is an invalid value for the `%s` css style property.&#x27;</span>, name);
    };

    <span class="hljs-keyword">var</span> warnStyleValueIsInfinity = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) {
      <span class="hljs-keyword">if</span> (warnedForInfinityValue) {
        <span class="hljs-keyword">return</span>;
      }

      warnedForInfinityValue = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;`Infinity` is an invalid value for the `%s` css style property.&#x27;</span>, name);
    };

    warnValidStyle = <span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) {
      <span class="hljs-keyword">if</span> (name.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;-&#x27;</span>) &gt; -<span class="hljs-number">1</span>) {
        <span class="hljs-title function_">warnHyphenatedStyleName</span>(name);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (badVendoredStyleNamePattern.<span class="hljs-title function_">test</span>(name)) {
        <span class="hljs-title function_">warnBadVendoredStyleName</span>(name);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (badStyleValueWithSemicolonPattern.<span class="hljs-title function_">test</span>(value)) {
        <span class="hljs-title function_">warnStyleValueWithSemicolon</span>(name, value);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isNaN</span>(value)) {
          <span class="hljs-title function_">warnStyleValueIsNaN</span>(name, value);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isFinite</span>(value)) {
          <span class="hljs-title function_">warnStyleValueIsInfinity</span>(name, value);
        }
      }
    };
  }

  <span class="hljs-keyword">var</span> warnValidStyle$<span class="hljs-number">1</span> = warnValidStyle;

  <span class="hljs-comment">/**
   * Operations for dealing with CSS properties.
   */</span>

  <span class="hljs-comment">/**
   * This creates a string that is expected to be equivalent to the style
   * attribute generated by server-side rendering. It by-passes warnings and
   * security checks so it&#x27;s not safe to use this value for anything other than
   * comparison. It is only used in DEV for SSR validation.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createDangerousStringForStyles</span>(<span class="hljs-params">styles</span>) {
    {
      <span class="hljs-keyword">var</span> serialized = <span class="hljs-string">&#x27;&#x27;</span>;
      <span class="hljs-keyword">var</span> delimiter = <span class="hljs-string">&#x27;&#x27;</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> styleName <span class="hljs-keyword">in</span> styles) {
        <span class="hljs-keyword">if</span> (!styles.<span class="hljs-title function_">hasOwnProperty</span>(styleName)) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> styleValue = styles[styleName];

        <span class="hljs-keyword">if</span> (styleValue != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> isCustomProperty = styleName.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;--&#x27;</span>) === <span class="hljs-number">0</span>;
          serialized += delimiter + (isCustomProperty ? styleName : <span class="hljs-title function_">hyphenateStyleName</span>(styleName)) + <span class="hljs-string">&#x27;:&#x27;</span>;
          serialized += <span class="hljs-title function_">dangerousStyleValue</span>(styleName, styleValue, isCustomProperty);
          delimiter = <span class="hljs-string">&#x27;;&#x27;</span>;
        }
      }

      <span class="hljs-keyword">return</span> serialized || <span class="hljs-literal">null</span>;
    }
  }
  <span class="hljs-comment">/**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * &#x27;&#x27; (empty string), the corresponding style property will be unset.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement</span>} <span class="hljs-variable">node</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">styles</span>
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setValueForStyles</span>(<span class="hljs-params">node, styles</span>) {
    <span class="hljs-keyword">var</span> style = node.<span class="hljs-property">style</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> styleName <span class="hljs-keyword">in</span> styles) {
      <span class="hljs-keyword">if</span> (!styles.<span class="hljs-title function_">hasOwnProperty</span>(styleName)) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">var</span> isCustomProperty = styleName.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;--&#x27;</span>) === <span class="hljs-number">0</span>;

      {
        <span class="hljs-keyword">if</span> (!isCustomProperty) {
          <span class="hljs-title function_">warnValidStyle$1</span>(styleName, styles[styleName]);
        }
      }

      <span class="hljs-keyword">var</span> styleValue = <span class="hljs-title function_">dangerousStyleValue</span>(styleName, styles[styleName], isCustomProperty);

      <span class="hljs-keyword">if</span> (styleName === <span class="hljs-string">&#x27;float&#x27;</span>) {
        styleName = <span class="hljs-string">&#x27;cssFloat&#x27;</span>;
      }

      <span class="hljs-keyword">if</span> (isCustomProperty) {
        style.<span class="hljs-title function_">setProperty</span>(styleName, styleValue);
      } <span class="hljs-keyword">else</span> {
        style[styleName] = styleValue;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isValueEmpty</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">return</span> value == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;boolean&#x27;</span> || value === <span class="hljs-string">&#x27;&#x27;</span>;
  }
  <span class="hljs-comment">/**
   * Given {color: &#x27;red&#x27;, overflow: &#x27;hidden&#x27;} returns {
   *   color: &#x27;color&#x27;,
   *   overflowX: &#x27;overflow&#x27;,
   *   overflowY: &#x27;overflow&#x27;,
   * }. This can be read as &quot;the overflowY property was set by the overflow
   * shorthand&quot;. That is, the values are the property that each was derived from.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">expandShorthandMap</span>(<span class="hljs-params">styles</span>) {
    <span class="hljs-keyword">var</span> expanded = {};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> styles) {
      <span class="hljs-keyword">var</span> longhands = shorthandToLonghand[key] || [key];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; longhands.<span class="hljs-property">length</span>; i++) {
        expanded[longhands[i]] = key;
      }
    }

    <span class="hljs-keyword">return</span> expanded;
  }
  <span class="hljs-comment">/**
   * When mixing shorthand and longhand property names, we warn during updates if
   * we expect an incorrect result to occur. In particular, we warn for:
   *
   * Updating a shorthand property (longhand gets overwritten):
   *   {font: &#x27;foo&#x27;, fontVariant: &#x27;bar&#x27;} -&gt; {font: &#x27;baz&#x27;, fontVariant: &#x27;bar&#x27;}
   *   becomes .style.font = &#x27;baz&#x27;
   * Removing a shorthand property (longhand gets lost too):
   *   {font: &#x27;foo&#x27;, fontVariant: &#x27;bar&#x27;} -&gt; {fontVariant: &#x27;bar&#x27;}
   *   becomes .style.font = &#x27;&#x27;
   * Removing a longhand property (should revert to shorthand; doesn&#x27;t):
   *   {font: &#x27;foo&#x27;, fontVariant: &#x27;bar&#x27;} -&gt; {font: &#x27;foo&#x27;}
   *   becomes .style.fontVariant = &#x27;&#x27;
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateShorthandPropertyCollisionInDev</span>(<span class="hljs-params">styleUpdates, nextStyles</span>) {
    {
      <span class="hljs-keyword">if</span> (!nextStyles) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> expandedUpdates = <span class="hljs-title function_">expandShorthandMap</span>(styleUpdates);
      <span class="hljs-keyword">var</span> expandedStyles = <span class="hljs-title function_">expandShorthandMap</span>(nextStyles);
      <span class="hljs-keyword">var</span> warnedAbout = {};

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> expandedUpdates) {
        <span class="hljs-keyword">var</span> originalKey = expandedUpdates[key];
        <span class="hljs-keyword">var</span> correctOriginalKey = expandedStyles[key];

        <span class="hljs-keyword">if</span> (correctOriginalKey &amp;&amp; originalKey !== correctOriginalKey) {
          <span class="hljs-keyword">var</span> warningKey = originalKey + <span class="hljs-string">&#x27;,&#x27;</span> + correctOriginalKey;

          <span class="hljs-keyword">if</span> (warnedAbout[warningKey]) {
            <span class="hljs-keyword">continue</span>;
          }

          warnedAbout[warningKey] = <span class="hljs-literal">true</span>;

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s a style property during rerender (%s) when a &#x27;</span> + <span class="hljs-string">&#x27;conflicting property is set (%s) can lead to styling bugs. To &#x27;</span> + <span class="hljs-string">&quot;avoid this, don&#x27;t mix shorthand and non-shorthand properties &quot;</span> + <span class="hljs-string">&#x27;for the same value; instead, replace the shorthand with &#x27;</span> + <span class="hljs-string">&#x27;separate values.&#x27;</span>, <span class="hljs-title function_">isValueEmpty</span>(styleUpdates[originalKey]) ? <span class="hljs-string">&#x27;Removing&#x27;</span> : <span class="hljs-string">&#x27;Updating&#x27;</span>, originalKey, correctOriginalKey);
        }
      }
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-110">&#x00a7;</a>
              </div>
              <p>For HTML, certain tags should omit their close tag. We keep a list for
those special-case tags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> omittedCloseTags = {
    <span class="hljs-attr">area</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">base</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">br</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">col</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">embed</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">hr</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">img</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">input</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">keygen</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">link</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">meta</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">param</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">source</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">track</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">wbr</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> menuitem&#x27;s close tag should be omitted, but that causes problems.</span>

  };</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-111">&#x00a7;</a>
              </div>
              <p><code>omittedCloseTags</code> except that <code>menuitem</code> should still have its closing tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> voidElementTags = <span class="hljs-title function_">_assign</span>({
    <span class="hljs-attr">menuitem</span>: <span class="hljs-literal">true</span>
  }, omittedCloseTags);

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">HTML</span> = <span class="hljs-string">&#x27;__html&#x27;</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">assertValidProps</span>(<span class="hljs-params">tag, props</span>) {
    <span class="hljs-keyword">if</span> (!props) {
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// Note the use of `==` which checks for null or undefined.</span>


    <span class="hljs-keyword">if</span> (voidElementTags[tag]) {
      <span class="hljs-keyword">if</span> (!(props.<span class="hljs-property">children</span> == <span class="hljs-literal">null</span> &amp;&amp; props.<span class="hljs-property">dangerouslySetInnerHTML</span> == <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(tag + <span class="hljs-string">&quot; is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.&quot;</span>);
        }
      }
    }

    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">dangerouslySetInnerHTML</span> != <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (!(props.<span class="hljs-property">children</span> == <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Can only set one of `children` or `props.dangerouslySetInnerHTML`.&quot;</span>);
        }
      }

      <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> props.<span class="hljs-property">dangerouslySetInnerHTML</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-variable constant_">HTML</span> <span class="hljs-keyword">in</span> props.<span class="hljs-property">dangerouslySetInnerHTML</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.&quot;</span>);
        }
      }
    }

    {
      <span class="hljs-keyword">if</span> (!props.<span class="hljs-property">suppressContentEditableWarning</span> &amp;&amp; props.<span class="hljs-property">contentEditable</span> &amp;&amp; props.<span class="hljs-property">children</span> != <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A component is `contentEditable` and contains `children` managed by &#x27;</span> + <span class="hljs-string">&#x27;React. It is now your responsibility to guarantee that none of &#x27;</span> + <span class="hljs-string">&#x27;those nodes are unexpectedly modified or duplicated. This is &#x27;</span> + <span class="hljs-string">&#x27;probably not intentional.&#x27;</span>);
      }
    }

    <span class="hljs-keyword">if</span> (!(props.<span class="hljs-property">style</span> == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> props.<span class="hljs-property">style</span> === <span class="hljs-string">&#x27;object&#x27;</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + &#x27;em&#x27;}} when using JSX.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isCustomComponent</span>(<span class="hljs-params">tagName, props</span>) {
    <span class="hljs-keyword">if</span> (tagName.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;-&#x27;</span>) === -<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> props.<span class="hljs-property">is</span> === <span class="hljs-string">&#x27;string&#x27;</span>;
    }

    <span class="hljs-keyword">switch</span> (tagName) {</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-112">&#x00a7;</a>
              </div>
              <p>These are reserved SVG and MathML elements.
We don’t mind this list too much because we expect it to never grow.
The alternative is to track the namespace in a few places which is convoluted.
<a href="https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts">https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;annotation-xml&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;color-profile&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;font-face&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;font-face-src&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;font-face-uri&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;font-face-format&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;font-face-name&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;missing-glyph&#x27;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-113">&#x00a7;</a>
              </div>
              <p>When adding attributes to the HTML or SVG allowed attribute list, be sure to
also add them to this module to ensure casing and incorrect name
warnings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> possibleStandardNames = {</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-114">&#x00a7;</a>
              </div>
              <p>HTML</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-attr">accept</span>: <span class="hljs-string">&#x27;accept&#x27;</span>,
    <span class="hljs-attr">acceptcharset</span>: <span class="hljs-string">&#x27;acceptCharset&#x27;</span>,
    <span class="hljs-string">&#x27;accept-charset&#x27;</span>: <span class="hljs-string">&#x27;acceptCharset&#x27;</span>,
    <span class="hljs-attr">accesskey</span>: <span class="hljs-string">&#x27;accessKey&#x27;</span>,
    <span class="hljs-attr">action</span>: <span class="hljs-string">&#x27;action&#x27;</span>,
    <span class="hljs-attr">allowfullscreen</span>: <span class="hljs-string">&#x27;allowFullScreen&#x27;</span>,
    <span class="hljs-attr">alt</span>: <span class="hljs-string">&#x27;alt&#x27;</span>,
    <span class="hljs-attr">as</span>: <span class="hljs-string">&#x27;as&#x27;</span>,
    <span class="hljs-attr">async</span>: <span class="hljs-string">&#x27;async&#x27;</span>,
    <span class="hljs-attr">autocapitalize</span>: <span class="hljs-string">&#x27;autoCapitalize&#x27;</span>,
    <span class="hljs-attr">autocomplete</span>: <span class="hljs-string">&#x27;autoComplete&#x27;</span>,
    <span class="hljs-attr">autocorrect</span>: <span class="hljs-string">&#x27;autoCorrect&#x27;</span>,
    <span class="hljs-attr">autofocus</span>: <span class="hljs-string">&#x27;autoFocus&#x27;</span>,
    <span class="hljs-attr">autoplay</span>: <span class="hljs-string">&#x27;autoPlay&#x27;</span>,
    <span class="hljs-attr">autosave</span>: <span class="hljs-string">&#x27;autoSave&#x27;</span>,
    <span class="hljs-attr">capture</span>: <span class="hljs-string">&#x27;capture&#x27;</span>,
    <span class="hljs-attr">cellpadding</span>: <span class="hljs-string">&#x27;cellPadding&#x27;</span>,
    <span class="hljs-attr">cellspacing</span>: <span class="hljs-string">&#x27;cellSpacing&#x27;</span>,
    <span class="hljs-attr">challenge</span>: <span class="hljs-string">&#x27;challenge&#x27;</span>,
    <span class="hljs-attr">charset</span>: <span class="hljs-string">&#x27;charSet&#x27;</span>,
    <span class="hljs-attr">checked</span>: <span class="hljs-string">&#x27;checked&#x27;</span>,
    <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;children&#x27;</span>,
    <span class="hljs-attr">cite</span>: <span class="hljs-string">&#x27;cite&#x27;</span>,
    <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;className&#x27;</span>,
    <span class="hljs-attr">classid</span>: <span class="hljs-string">&#x27;classID&#x27;</span>,
    <span class="hljs-attr">classname</span>: <span class="hljs-string">&#x27;className&#x27;</span>,
    <span class="hljs-attr">cols</span>: <span class="hljs-string">&#x27;cols&#x27;</span>,
    <span class="hljs-attr">colspan</span>: <span class="hljs-string">&#x27;colSpan&#x27;</span>,
    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;content&#x27;</span>,
    <span class="hljs-attr">contenteditable</span>: <span class="hljs-string">&#x27;contentEditable&#x27;</span>,
    <span class="hljs-attr">contextmenu</span>: <span class="hljs-string">&#x27;contextMenu&#x27;</span>,
    <span class="hljs-attr">controls</span>: <span class="hljs-string">&#x27;controls&#x27;</span>,
    <span class="hljs-attr">controlslist</span>: <span class="hljs-string">&#x27;controlsList&#x27;</span>,
    <span class="hljs-attr">coords</span>: <span class="hljs-string">&#x27;coords&#x27;</span>,
    <span class="hljs-attr">crossorigin</span>: <span class="hljs-string">&#x27;crossOrigin&#x27;</span>,
    <span class="hljs-attr">dangerouslysetinnerhtml</span>: <span class="hljs-string">&#x27;dangerouslySetInnerHTML&#x27;</span>,
    <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;data&#x27;</span>,
    <span class="hljs-attr">datetime</span>: <span class="hljs-string">&#x27;dateTime&#x27;</span>,
    <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;default&#x27;</span>,
    <span class="hljs-attr">defaultchecked</span>: <span class="hljs-string">&#x27;defaultChecked&#x27;</span>,
    <span class="hljs-attr">defaultvalue</span>: <span class="hljs-string">&#x27;defaultValue&#x27;</span>,
    <span class="hljs-attr">defer</span>: <span class="hljs-string">&#x27;defer&#x27;</span>,
    <span class="hljs-attr">dir</span>: <span class="hljs-string">&#x27;dir&#x27;</span>,
    <span class="hljs-attr">disabled</span>: <span class="hljs-string">&#x27;disabled&#x27;</span>,
    <span class="hljs-attr">disablepictureinpicture</span>: <span class="hljs-string">&#x27;disablePictureInPicture&#x27;</span>,
    <span class="hljs-attr">disableremoteplayback</span>: <span class="hljs-string">&#x27;disableRemotePlayback&#x27;</span>,
    <span class="hljs-attr">download</span>: <span class="hljs-string">&#x27;download&#x27;</span>,
    <span class="hljs-attr">draggable</span>: <span class="hljs-string">&#x27;draggable&#x27;</span>,
    <span class="hljs-attr">enctype</span>: <span class="hljs-string">&#x27;encType&#x27;</span>,
    <span class="hljs-attr">enterkeyhint</span>: <span class="hljs-string">&#x27;enterKeyHint&#x27;</span>,
    <span class="hljs-attr">for</span>: <span class="hljs-string">&#x27;htmlFor&#x27;</span>,
    <span class="hljs-attr">form</span>: <span class="hljs-string">&#x27;form&#x27;</span>,
    <span class="hljs-attr">formmethod</span>: <span class="hljs-string">&#x27;formMethod&#x27;</span>,
    <span class="hljs-attr">formaction</span>: <span class="hljs-string">&#x27;formAction&#x27;</span>,
    <span class="hljs-attr">formenctype</span>: <span class="hljs-string">&#x27;formEncType&#x27;</span>,
    <span class="hljs-attr">formnovalidate</span>: <span class="hljs-string">&#x27;formNoValidate&#x27;</span>,
    <span class="hljs-attr">formtarget</span>: <span class="hljs-string">&#x27;formTarget&#x27;</span>,
    <span class="hljs-attr">frameborder</span>: <span class="hljs-string">&#x27;frameBorder&#x27;</span>,
    <span class="hljs-attr">headers</span>: <span class="hljs-string">&#x27;headers&#x27;</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;height&#x27;</span>,
    <span class="hljs-attr">hidden</span>: <span class="hljs-string">&#x27;hidden&#x27;</span>,
    <span class="hljs-attr">high</span>: <span class="hljs-string">&#x27;high&#x27;</span>,
    <span class="hljs-attr">href</span>: <span class="hljs-string">&#x27;href&#x27;</span>,
    <span class="hljs-attr">hreflang</span>: <span class="hljs-string">&#x27;hrefLang&#x27;</span>,
    <span class="hljs-attr">htmlfor</span>: <span class="hljs-string">&#x27;htmlFor&#x27;</span>,
    <span class="hljs-attr">httpequiv</span>: <span class="hljs-string">&#x27;httpEquiv&#x27;</span>,
    <span class="hljs-string">&#x27;http-equiv&#x27;</span>: <span class="hljs-string">&#x27;httpEquiv&#x27;</span>,
    <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;icon&#x27;</span>,
    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;id&#x27;</span>,
    <span class="hljs-attr">innerhtml</span>: <span class="hljs-string">&#x27;innerHTML&#x27;</span>,
    <span class="hljs-attr">inputmode</span>: <span class="hljs-string">&#x27;inputMode&#x27;</span>,
    <span class="hljs-attr">integrity</span>: <span class="hljs-string">&#x27;integrity&#x27;</span>,
    <span class="hljs-attr">is</span>: <span class="hljs-string">&#x27;is&#x27;</span>,
    <span class="hljs-attr">itemid</span>: <span class="hljs-string">&#x27;itemID&#x27;</span>,
    <span class="hljs-attr">itemprop</span>: <span class="hljs-string">&#x27;itemProp&#x27;</span>,
    <span class="hljs-attr">itemref</span>: <span class="hljs-string">&#x27;itemRef&#x27;</span>,
    <span class="hljs-attr">itemscope</span>: <span class="hljs-string">&#x27;itemScope&#x27;</span>,
    <span class="hljs-attr">itemtype</span>: <span class="hljs-string">&#x27;itemType&#x27;</span>,
    <span class="hljs-attr">keyparams</span>: <span class="hljs-string">&#x27;keyParams&#x27;</span>,
    <span class="hljs-attr">keytype</span>: <span class="hljs-string">&#x27;keyType&#x27;</span>,
    <span class="hljs-attr">kind</span>: <span class="hljs-string">&#x27;kind&#x27;</span>,
    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;label&#x27;</span>,
    <span class="hljs-attr">lang</span>: <span class="hljs-string">&#x27;lang&#x27;</span>,
    <span class="hljs-attr">list</span>: <span class="hljs-string">&#x27;list&#x27;</span>,
    <span class="hljs-attr">loop</span>: <span class="hljs-string">&#x27;loop&#x27;</span>,
    <span class="hljs-attr">low</span>: <span class="hljs-string">&#x27;low&#x27;</span>,
    <span class="hljs-attr">manifest</span>: <span class="hljs-string">&#x27;manifest&#x27;</span>,
    <span class="hljs-attr">marginwidth</span>: <span class="hljs-string">&#x27;marginWidth&#x27;</span>,
    <span class="hljs-attr">marginheight</span>: <span class="hljs-string">&#x27;marginHeight&#x27;</span>,
    <span class="hljs-attr">max</span>: <span class="hljs-string">&#x27;max&#x27;</span>,
    <span class="hljs-attr">maxlength</span>: <span class="hljs-string">&#x27;maxLength&#x27;</span>,
    <span class="hljs-attr">media</span>: <span class="hljs-string">&#x27;media&#x27;</span>,
    <span class="hljs-attr">mediagroup</span>: <span class="hljs-string">&#x27;mediaGroup&#x27;</span>,
    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;method&#x27;</span>,
    <span class="hljs-attr">min</span>: <span class="hljs-string">&#x27;min&#x27;</span>,
    <span class="hljs-attr">minlength</span>: <span class="hljs-string">&#x27;minLength&#x27;</span>,
    <span class="hljs-attr">multiple</span>: <span class="hljs-string">&#x27;multiple&#x27;</span>,
    <span class="hljs-attr">muted</span>: <span class="hljs-string">&#x27;muted&#x27;</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;name&#x27;</span>,
    <span class="hljs-attr">nomodule</span>: <span class="hljs-string">&#x27;noModule&#x27;</span>,
    <span class="hljs-attr">nonce</span>: <span class="hljs-string">&#x27;nonce&#x27;</span>,
    <span class="hljs-attr">novalidate</span>: <span class="hljs-string">&#x27;noValidate&#x27;</span>,
    <span class="hljs-attr">open</span>: <span class="hljs-string">&#x27;open&#x27;</span>,
    <span class="hljs-attr">optimum</span>: <span class="hljs-string">&#x27;optimum&#x27;</span>,
    <span class="hljs-attr">pattern</span>: <span class="hljs-string">&#x27;pattern&#x27;</span>,
    <span class="hljs-attr">placeholder</span>: <span class="hljs-string">&#x27;placeholder&#x27;</span>,
    <span class="hljs-attr">playsinline</span>: <span class="hljs-string">&#x27;playsInline&#x27;</span>,
    <span class="hljs-attr">poster</span>: <span class="hljs-string">&#x27;poster&#x27;</span>,
    <span class="hljs-attr">preload</span>: <span class="hljs-string">&#x27;preload&#x27;</span>,
    <span class="hljs-attr">profile</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,
    <span class="hljs-attr">radiogroup</span>: <span class="hljs-string">&#x27;radioGroup&#x27;</span>,
    <span class="hljs-attr">readonly</span>: <span class="hljs-string">&#x27;readOnly&#x27;</span>,
    <span class="hljs-attr">referrerpolicy</span>: <span class="hljs-string">&#x27;referrerPolicy&#x27;</span>,
    <span class="hljs-attr">rel</span>: <span class="hljs-string">&#x27;rel&#x27;</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-string">&#x27;required&#x27;</span>,
    <span class="hljs-attr">reversed</span>: <span class="hljs-string">&#x27;reversed&#x27;</span>,
    <span class="hljs-attr">role</span>: <span class="hljs-string">&#x27;role&#x27;</span>,
    <span class="hljs-attr">rows</span>: <span class="hljs-string">&#x27;rows&#x27;</span>,
    <span class="hljs-attr">rowspan</span>: <span class="hljs-string">&#x27;rowSpan&#x27;</span>,
    <span class="hljs-attr">sandbox</span>: <span class="hljs-string">&#x27;sandbox&#x27;</span>,
    <span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;scope&#x27;</span>,
    <span class="hljs-attr">scoped</span>: <span class="hljs-string">&#x27;scoped&#x27;</span>,
    <span class="hljs-attr">scrolling</span>: <span class="hljs-string">&#x27;scrolling&#x27;</span>,
    <span class="hljs-attr">seamless</span>: <span class="hljs-string">&#x27;seamless&#x27;</span>,
    <span class="hljs-attr">selected</span>: <span class="hljs-string">&#x27;selected&#x27;</span>,
    <span class="hljs-attr">shape</span>: <span class="hljs-string">&#x27;shape&#x27;</span>,
    <span class="hljs-attr">size</span>: <span class="hljs-string">&#x27;size&#x27;</span>,
    <span class="hljs-attr">sizes</span>: <span class="hljs-string">&#x27;sizes&#x27;</span>,
    <span class="hljs-attr">span</span>: <span class="hljs-string">&#x27;span&#x27;</span>,
    <span class="hljs-attr">spellcheck</span>: <span class="hljs-string">&#x27;spellCheck&#x27;</span>,
    <span class="hljs-attr">src</span>: <span class="hljs-string">&#x27;src&#x27;</span>,
    <span class="hljs-attr">srcdoc</span>: <span class="hljs-string">&#x27;srcDoc&#x27;</span>,
    <span class="hljs-attr">srclang</span>: <span class="hljs-string">&#x27;srcLang&#x27;</span>,
    <span class="hljs-attr">srcset</span>: <span class="hljs-string">&#x27;srcSet&#x27;</span>,
    <span class="hljs-attr">start</span>: <span class="hljs-string">&#x27;start&#x27;</span>,
    <span class="hljs-attr">step</span>: <span class="hljs-string">&#x27;step&#x27;</span>,
    <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;style&#x27;</span>,
    <span class="hljs-attr">summary</span>: <span class="hljs-string">&#x27;summary&#x27;</span>,
    <span class="hljs-attr">tabindex</span>: <span class="hljs-string">&#x27;tabIndex&#x27;</span>,
    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;target&#x27;</span>,
    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;title&#x27;</span>,
    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;type&#x27;</span>,
    <span class="hljs-attr">usemap</span>: <span class="hljs-string">&#x27;useMap&#x27;</span>,
    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;value&#x27;</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;width&#x27;</span>,
    <span class="hljs-attr">wmode</span>: <span class="hljs-string">&#x27;wmode&#x27;</span>,
    <span class="hljs-attr">wrap</span>: <span class="hljs-string">&#x27;wrap&#x27;</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-115">&#x00a7;</a>
              </div>
              <p>SVG</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-attr">about</span>: <span class="hljs-string">&#x27;about&#x27;</span>,
    <span class="hljs-attr">accentheight</span>: <span class="hljs-string">&#x27;accentHeight&#x27;</span>,
    <span class="hljs-string">&#x27;accent-height&#x27;</span>: <span class="hljs-string">&#x27;accentHeight&#x27;</span>,
    <span class="hljs-attr">accumulate</span>: <span class="hljs-string">&#x27;accumulate&#x27;</span>,
    <span class="hljs-attr">additive</span>: <span class="hljs-string">&#x27;additive&#x27;</span>,
    <span class="hljs-attr">alignmentbaseline</span>: <span class="hljs-string">&#x27;alignmentBaseline&#x27;</span>,
    <span class="hljs-string">&#x27;alignment-baseline&#x27;</span>: <span class="hljs-string">&#x27;alignmentBaseline&#x27;</span>,
    <span class="hljs-attr">allowreorder</span>: <span class="hljs-string">&#x27;allowReorder&#x27;</span>,
    <span class="hljs-attr">alphabetic</span>: <span class="hljs-string">&#x27;alphabetic&#x27;</span>,
    <span class="hljs-attr">amplitude</span>: <span class="hljs-string">&#x27;amplitude&#x27;</span>,
    <span class="hljs-attr">arabicform</span>: <span class="hljs-string">&#x27;arabicForm&#x27;</span>,
    <span class="hljs-string">&#x27;arabic-form&#x27;</span>: <span class="hljs-string">&#x27;arabicForm&#x27;</span>,
    <span class="hljs-attr">ascent</span>: <span class="hljs-string">&#x27;ascent&#x27;</span>,
    <span class="hljs-attr">attributename</span>: <span class="hljs-string">&#x27;attributeName&#x27;</span>,
    <span class="hljs-attr">attributetype</span>: <span class="hljs-string">&#x27;attributeType&#x27;</span>,
    <span class="hljs-attr">autoreverse</span>: <span class="hljs-string">&#x27;autoReverse&#x27;</span>,
    <span class="hljs-attr">azimuth</span>: <span class="hljs-string">&#x27;azimuth&#x27;</span>,
    <span class="hljs-attr">basefrequency</span>: <span class="hljs-string">&#x27;baseFrequency&#x27;</span>,
    <span class="hljs-attr">baselineshift</span>: <span class="hljs-string">&#x27;baselineShift&#x27;</span>,
    <span class="hljs-string">&#x27;baseline-shift&#x27;</span>: <span class="hljs-string">&#x27;baselineShift&#x27;</span>,
    <span class="hljs-attr">baseprofile</span>: <span class="hljs-string">&#x27;baseProfile&#x27;</span>,
    <span class="hljs-attr">bbox</span>: <span class="hljs-string">&#x27;bbox&#x27;</span>,
    <span class="hljs-attr">begin</span>: <span class="hljs-string">&#x27;begin&#x27;</span>,
    <span class="hljs-attr">bias</span>: <span class="hljs-string">&#x27;bias&#x27;</span>,
    <span class="hljs-attr">by</span>: <span class="hljs-string">&#x27;by&#x27;</span>,
    <span class="hljs-attr">calcmode</span>: <span class="hljs-string">&#x27;calcMode&#x27;</span>,
    <span class="hljs-attr">capheight</span>: <span class="hljs-string">&#x27;capHeight&#x27;</span>,
    <span class="hljs-string">&#x27;cap-height&#x27;</span>: <span class="hljs-string">&#x27;capHeight&#x27;</span>,
    <span class="hljs-attr">clip</span>: <span class="hljs-string">&#x27;clip&#x27;</span>,
    <span class="hljs-attr">clippath</span>: <span class="hljs-string">&#x27;clipPath&#x27;</span>,
    <span class="hljs-string">&#x27;clip-path&#x27;</span>: <span class="hljs-string">&#x27;clipPath&#x27;</span>,
    <span class="hljs-attr">clippathunits</span>: <span class="hljs-string">&#x27;clipPathUnits&#x27;</span>,
    <span class="hljs-attr">cliprule</span>: <span class="hljs-string">&#x27;clipRule&#x27;</span>,
    <span class="hljs-string">&#x27;clip-rule&#x27;</span>: <span class="hljs-string">&#x27;clipRule&#x27;</span>,
    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;color&#x27;</span>,
    <span class="hljs-attr">colorinterpolation</span>: <span class="hljs-string">&#x27;colorInterpolation&#x27;</span>,
    <span class="hljs-string">&#x27;color-interpolation&#x27;</span>: <span class="hljs-string">&#x27;colorInterpolation&#x27;</span>,
    <span class="hljs-attr">colorinterpolationfilters</span>: <span class="hljs-string">&#x27;colorInterpolationFilters&#x27;</span>,
    <span class="hljs-string">&#x27;color-interpolation-filters&#x27;</span>: <span class="hljs-string">&#x27;colorInterpolationFilters&#x27;</span>,
    <span class="hljs-attr">colorprofile</span>: <span class="hljs-string">&#x27;colorProfile&#x27;</span>,
    <span class="hljs-string">&#x27;color-profile&#x27;</span>: <span class="hljs-string">&#x27;colorProfile&#x27;</span>,
    <span class="hljs-attr">colorrendering</span>: <span class="hljs-string">&#x27;colorRendering&#x27;</span>,
    <span class="hljs-string">&#x27;color-rendering&#x27;</span>: <span class="hljs-string">&#x27;colorRendering&#x27;</span>,
    <span class="hljs-attr">contentscripttype</span>: <span class="hljs-string">&#x27;contentScriptType&#x27;</span>,
    <span class="hljs-attr">contentstyletype</span>: <span class="hljs-string">&#x27;contentStyleType&#x27;</span>,
    <span class="hljs-attr">cursor</span>: <span class="hljs-string">&#x27;cursor&#x27;</span>,
    <span class="hljs-attr">cx</span>: <span class="hljs-string">&#x27;cx&#x27;</span>,
    <span class="hljs-attr">cy</span>: <span class="hljs-string">&#x27;cy&#x27;</span>,
    <span class="hljs-attr">d</span>: <span class="hljs-string">&#x27;d&#x27;</span>,
    <span class="hljs-attr">datatype</span>: <span class="hljs-string">&#x27;datatype&#x27;</span>,
    <span class="hljs-attr">decelerate</span>: <span class="hljs-string">&#x27;decelerate&#x27;</span>,
    <span class="hljs-attr">descent</span>: <span class="hljs-string">&#x27;descent&#x27;</span>,
    <span class="hljs-attr">diffuseconstant</span>: <span class="hljs-string">&#x27;diffuseConstant&#x27;</span>,
    <span class="hljs-attr">direction</span>: <span class="hljs-string">&#x27;direction&#x27;</span>,
    <span class="hljs-attr">display</span>: <span class="hljs-string">&#x27;display&#x27;</span>,
    <span class="hljs-attr">divisor</span>: <span class="hljs-string">&#x27;divisor&#x27;</span>,
    <span class="hljs-attr">dominantbaseline</span>: <span class="hljs-string">&#x27;dominantBaseline&#x27;</span>,
    <span class="hljs-string">&#x27;dominant-baseline&#x27;</span>: <span class="hljs-string">&#x27;dominantBaseline&#x27;</span>,
    <span class="hljs-attr">dur</span>: <span class="hljs-string">&#x27;dur&#x27;</span>,
    <span class="hljs-attr">dx</span>: <span class="hljs-string">&#x27;dx&#x27;</span>,
    <span class="hljs-attr">dy</span>: <span class="hljs-string">&#x27;dy&#x27;</span>,
    <span class="hljs-attr">edgemode</span>: <span class="hljs-string">&#x27;edgeMode&#x27;</span>,
    <span class="hljs-attr">elevation</span>: <span class="hljs-string">&#x27;elevation&#x27;</span>,
    <span class="hljs-attr">enablebackground</span>: <span class="hljs-string">&#x27;enableBackground&#x27;</span>,
    <span class="hljs-string">&#x27;enable-background&#x27;</span>: <span class="hljs-string">&#x27;enableBackground&#x27;</span>,
    <span class="hljs-attr">end</span>: <span class="hljs-string">&#x27;end&#x27;</span>,
    <span class="hljs-attr">exponent</span>: <span class="hljs-string">&#x27;exponent&#x27;</span>,
    <span class="hljs-attr">externalresourcesrequired</span>: <span class="hljs-string">&#x27;externalResourcesRequired&#x27;</span>,
    <span class="hljs-attr">fill</span>: <span class="hljs-string">&#x27;fill&#x27;</span>,
    <span class="hljs-attr">fillopacity</span>: <span class="hljs-string">&#x27;fillOpacity&#x27;</span>,
    <span class="hljs-string">&#x27;fill-opacity&#x27;</span>: <span class="hljs-string">&#x27;fillOpacity&#x27;</span>,
    <span class="hljs-attr">fillrule</span>: <span class="hljs-string">&#x27;fillRule&#x27;</span>,
    <span class="hljs-string">&#x27;fill-rule&#x27;</span>: <span class="hljs-string">&#x27;fillRule&#x27;</span>,
    <span class="hljs-attr">filter</span>: <span class="hljs-string">&#x27;filter&#x27;</span>,
    <span class="hljs-attr">filterres</span>: <span class="hljs-string">&#x27;filterRes&#x27;</span>,
    <span class="hljs-attr">filterunits</span>: <span class="hljs-string">&#x27;filterUnits&#x27;</span>,
    <span class="hljs-attr">floodopacity</span>: <span class="hljs-string">&#x27;floodOpacity&#x27;</span>,
    <span class="hljs-string">&#x27;flood-opacity&#x27;</span>: <span class="hljs-string">&#x27;floodOpacity&#x27;</span>,
    <span class="hljs-attr">floodcolor</span>: <span class="hljs-string">&#x27;floodColor&#x27;</span>,
    <span class="hljs-string">&#x27;flood-color&#x27;</span>: <span class="hljs-string">&#x27;floodColor&#x27;</span>,
    <span class="hljs-attr">focusable</span>: <span class="hljs-string">&#x27;focusable&#x27;</span>,
    <span class="hljs-attr">fontfamily</span>: <span class="hljs-string">&#x27;fontFamily&#x27;</span>,
    <span class="hljs-string">&#x27;font-family&#x27;</span>: <span class="hljs-string">&#x27;fontFamily&#x27;</span>,
    <span class="hljs-attr">fontsize</span>: <span class="hljs-string">&#x27;fontSize&#x27;</span>,
    <span class="hljs-string">&#x27;font-size&#x27;</span>: <span class="hljs-string">&#x27;fontSize&#x27;</span>,
    <span class="hljs-attr">fontsizeadjust</span>: <span class="hljs-string">&#x27;fontSizeAdjust&#x27;</span>,
    <span class="hljs-string">&#x27;font-size-adjust&#x27;</span>: <span class="hljs-string">&#x27;fontSizeAdjust&#x27;</span>,
    <span class="hljs-attr">fontstretch</span>: <span class="hljs-string">&#x27;fontStretch&#x27;</span>,
    <span class="hljs-string">&#x27;font-stretch&#x27;</span>: <span class="hljs-string">&#x27;fontStretch&#x27;</span>,
    <span class="hljs-attr">fontstyle</span>: <span class="hljs-string">&#x27;fontStyle&#x27;</span>,
    <span class="hljs-string">&#x27;font-style&#x27;</span>: <span class="hljs-string">&#x27;fontStyle&#x27;</span>,
    <span class="hljs-attr">fontvariant</span>: <span class="hljs-string">&#x27;fontVariant&#x27;</span>,
    <span class="hljs-string">&#x27;font-variant&#x27;</span>: <span class="hljs-string">&#x27;fontVariant&#x27;</span>,
    <span class="hljs-attr">fontweight</span>: <span class="hljs-string">&#x27;fontWeight&#x27;</span>,
    <span class="hljs-string">&#x27;font-weight&#x27;</span>: <span class="hljs-string">&#x27;fontWeight&#x27;</span>,
    <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;format&#x27;</span>,
    <span class="hljs-attr">from</span>: <span class="hljs-string">&#x27;from&#x27;</span>,
    <span class="hljs-attr">fx</span>: <span class="hljs-string">&#x27;fx&#x27;</span>,
    <span class="hljs-attr">fy</span>: <span class="hljs-string">&#x27;fy&#x27;</span>,
    <span class="hljs-attr">g1</span>: <span class="hljs-string">&#x27;g1&#x27;</span>,
    <span class="hljs-attr">g2</span>: <span class="hljs-string">&#x27;g2&#x27;</span>,
    <span class="hljs-attr">glyphname</span>: <span class="hljs-string">&#x27;glyphName&#x27;</span>,
    <span class="hljs-string">&#x27;glyph-name&#x27;</span>: <span class="hljs-string">&#x27;glyphName&#x27;</span>,
    <span class="hljs-attr">glyphorientationhorizontal</span>: <span class="hljs-string">&#x27;glyphOrientationHorizontal&#x27;</span>,
    <span class="hljs-string">&#x27;glyph-orientation-horizontal&#x27;</span>: <span class="hljs-string">&#x27;glyphOrientationHorizontal&#x27;</span>,
    <span class="hljs-attr">glyphorientationvertical</span>: <span class="hljs-string">&#x27;glyphOrientationVertical&#x27;</span>,
    <span class="hljs-string">&#x27;glyph-orientation-vertical&#x27;</span>: <span class="hljs-string">&#x27;glyphOrientationVertical&#x27;</span>,
    <span class="hljs-attr">glyphref</span>: <span class="hljs-string">&#x27;glyphRef&#x27;</span>,
    <span class="hljs-attr">gradienttransform</span>: <span class="hljs-string">&#x27;gradientTransform&#x27;</span>,
    <span class="hljs-attr">gradientunits</span>: <span class="hljs-string">&#x27;gradientUnits&#x27;</span>,
    <span class="hljs-attr">hanging</span>: <span class="hljs-string">&#x27;hanging&#x27;</span>,
    <span class="hljs-attr">horizadvx</span>: <span class="hljs-string">&#x27;horizAdvX&#x27;</span>,
    <span class="hljs-string">&#x27;horiz-adv-x&#x27;</span>: <span class="hljs-string">&#x27;horizAdvX&#x27;</span>,
    <span class="hljs-attr">horizoriginx</span>: <span class="hljs-string">&#x27;horizOriginX&#x27;</span>,
    <span class="hljs-string">&#x27;horiz-origin-x&#x27;</span>: <span class="hljs-string">&#x27;horizOriginX&#x27;</span>,
    <span class="hljs-attr">ideographic</span>: <span class="hljs-string">&#x27;ideographic&#x27;</span>,
    <span class="hljs-attr">imagerendering</span>: <span class="hljs-string">&#x27;imageRendering&#x27;</span>,
    <span class="hljs-string">&#x27;image-rendering&#x27;</span>: <span class="hljs-string">&#x27;imageRendering&#x27;</span>,
    <span class="hljs-attr">in2</span>: <span class="hljs-string">&#x27;in2&#x27;</span>,
    <span class="hljs-attr">in</span>: <span class="hljs-string">&#x27;in&#x27;</span>,
    <span class="hljs-attr">inlist</span>: <span class="hljs-string">&#x27;inlist&#x27;</span>,
    <span class="hljs-attr">intercept</span>: <span class="hljs-string">&#x27;intercept&#x27;</span>,
    <span class="hljs-attr">k1</span>: <span class="hljs-string">&#x27;k1&#x27;</span>,
    <span class="hljs-attr">k2</span>: <span class="hljs-string">&#x27;k2&#x27;</span>,
    <span class="hljs-attr">k3</span>: <span class="hljs-string">&#x27;k3&#x27;</span>,
    <span class="hljs-attr">k4</span>: <span class="hljs-string">&#x27;k4&#x27;</span>,
    <span class="hljs-attr">k</span>: <span class="hljs-string">&#x27;k&#x27;</span>,
    <span class="hljs-attr">kernelmatrix</span>: <span class="hljs-string">&#x27;kernelMatrix&#x27;</span>,
    <span class="hljs-attr">kernelunitlength</span>: <span class="hljs-string">&#x27;kernelUnitLength&#x27;</span>,
    <span class="hljs-attr">kerning</span>: <span class="hljs-string">&#x27;kerning&#x27;</span>,
    <span class="hljs-attr">keypoints</span>: <span class="hljs-string">&#x27;keyPoints&#x27;</span>,
    <span class="hljs-attr">keysplines</span>: <span class="hljs-string">&#x27;keySplines&#x27;</span>,
    <span class="hljs-attr">keytimes</span>: <span class="hljs-string">&#x27;keyTimes&#x27;</span>,
    <span class="hljs-attr">lengthadjust</span>: <span class="hljs-string">&#x27;lengthAdjust&#x27;</span>,
    <span class="hljs-attr">letterspacing</span>: <span class="hljs-string">&#x27;letterSpacing&#x27;</span>,
    <span class="hljs-string">&#x27;letter-spacing&#x27;</span>: <span class="hljs-string">&#x27;letterSpacing&#x27;</span>,
    <span class="hljs-attr">lightingcolor</span>: <span class="hljs-string">&#x27;lightingColor&#x27;</span>,
    <span class="hljs-string">&#x27;lighting-color&#x27;</span>: <span class="hljs-string">&#x27;lightingColor&#x27;</span>,
    <span class="hljs-attr">limitingconeangle</span>: <span class="hljs-string">&#x27;limitingConeAngle&#x27;</span>,
    <span class="hljs-attr">local</span>: <span class="hljs-string">&#x27;local&#x27;</span>,
    <span class="hljs-attr">markerend</span>: <span class="hljs-string">&#x27;markerEnd&#x27;</span>,
    <span class="hljs-string">&#x27;marker-end&#x27;</span>: <span class="hljs-string">&#x27;markerEnd&#x27;</span>,
    <span class="hljs-attr">markerheight</span>: <span class="hljs-string">&#x27;markerHeight&#x27;</span>,
    <span class="hljs-attr">markermid</span>: <span class="hljs-string">&#x27;markerMid&#x27;</span>,
    <span class="hljs-string">&#x27;marker-mid&#x27;</span>: <span class="hljs-string">&#x27;markerMid&#x27;</span>,
    <span class="hljs-attr">markerstart</span>: <span class="hljs-string">&#x27;markerStart&#x27;</span>,
    <span class="hljs-string">&#x27;marker-start&#x27;</span>: <span class="hljs-string">&#x27;markerStart&#x27;</span>,
    <span class="hljs-attr">markerunits</span>: <span class="hljs-string">&#x27;markerUnits&#x27;</span>,
    <span class="hljs-attr">markerwidth</span>: <span class="hljs-string">&#x27;markerWidth&#x27;</span>,
    <span class="hljs-attr">mask</span>: <span class="hljs-string">&#x27;mask&#x27;</span>,
    <span class="hljs-attr">maskcontentunits</span>: <span class="hljs-string">&#x27;maskContentUnits&#x27;</span>,
    <span class="hljs-attr">maskunits</span>: <span class="hljs-string">&#x27;maskUnits&#x27;</span>,
    <span class="hljs-attr">mathematical</span>: <span class="hljs-string">&#x27;mathematical&#x27;</span>,
    <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;mode&#x27;</span>,
    <span class="hljs-attr">numoctaves</span>: <span class="hljs-string">&#x27;numOctaves&#x27;</span>,
    <span class="hljs-attr">offset</span>: <span class="hljs-string">&#x27;offset&#x27;</span>,
    <span class="hljs-attr">opacity</span>: <span class="hljs-string">&#x27;opacity&#x27;</span>,
    <span class="hljs-attr">operator</span>: <span class="hljs-string">&#x27;operator&#x27;</span>,
    <span class="hljs-attr">order</span>: <span class="hljs-string">&#x27;order&#x27;</span>,
    <span class="hljs-attr">orient</span>: <span class="hljs-string">&#x27;orient&#x27;</span>,
    <span class="hljs-attr">orientation</span>: <span class="hljs-string">&#x27;orientation&#x27;</span>,
    <span class="hljs-attr">origin</span>: <span class="hljs-string">&#x27;origin&#x27;</span>,
    <span class="hljs-attr">overflow</span>: <span class="hljs-string">&#x27;overflow&#x27;</span>,
    <span class="hljs-attr">overlineposition</span>: <span class="hljs-string">&#x27;overlinePosition&#x27;</span>,
    <span class="hljs-string">&#x27;overline-position&#x27;</span>: <span class="hljs-string">&#x27;overlinePosition&#x27;</span>,
    <span class="hljs-attr">overlinethickness</span>: <span class="hljs-string">&#x27;overlineThickness&#x27;</span>,
    <span class="hljs-string">&#x27;overline-thickness&#x27;</span>: <span class="hljs-string">&#x27;overlineThickness&#x27;</span>,
    <span class="hljs-attr">paintorder</span>: <span class="hljs-string">&#x27;paintOrder&#x27;</span>,
    <span class="hljs-string">&#x27;paint-order&#x27;</span>: <span class="hljs-string">&#x27;paintOrder&#x27;</span>,
    <span class="hljs-attr">panose1</span>: <span class="hljs-string">&#x27;panose1&#x27;</span>,
    <span class="hljs-string">&#x27;panose-1&#x27;</span>: <span class="hljs-string">&#x27;panose1&#x27;</span>,
    <span class="hljs-attr">pathlength</span>: <span class="hljs-string">&#x27;pathLength&#x27;</span>,
    <span class="hljs-attr">patterncontentunits</span>: <span class="hljs-string">&#x27;patternContentUnits&#x27;</span>,
    <span class="hljs-attr">patterntransform</span>: <span class="hljs-string">&#x27;patternTransform&#x27;</span>,
    <span class="hljs-attr">patternunits</span>: <span class="hljs-string">&#x27;patternUnits&#x27;</span>,
    <span class="hljs-attr">pointerevents</span>: <span class="hljs-string">&#x27;pointerEvents&#x27;</span>,
    <span class="hljs-string">&#x27;pointer-events&#x27;</span>: <span class="hljs-string">&#x27;pointerEvents&#x27;</span>,
    <span class="hljs-attr">points</span>: <span class="hljs-string">&#x27;points&#x27;</span>,
    <span class="hljs-attr">pointsatx</span>: <span class="hljs-string">&#x27;pointsAtX&#x27;</span>,
    <span class="hljs-attr">pointsaty</span>: <span class="hljs-string">&#x27;pointsAtY&#x27;</span>,
    <span class="hljs-attr">pointsatz</span>: <span class="hljs-string">&#x27;pointsAtZ&#x27;</span>,
    <span class="hljs-attr">prefix</span>: <span class="hljs-string">&#x27;prefix&#x27;</span>,
    <span class="hljs-attr">preservealpha</span>: <span class="hljs-string">&#x27;preserveAlpha&#x27;</span>,
    <span class="hljs-attr">preserveaspectratio</span>: <span class="hljs-string">&#x27;preserveAspectRatio&#x27;</span>,
    <span class="hljs-attr">primitiveunits</span>: <span class="hljs-string">&#x27;primitiveUnits&#x27;</span>,
    <span class="hljs-attr">property</span>: <span class="hljs-string">&#x27;property&#x27;</span>,
    <span class="hljs-attr">r</span>: <span class="hljs-string">&#x27;r&#x27;</span>,
    <span class="hljs-attr">radius</span>: <span class="hljs-string">&#x27;radius&#x27;</span>,
    <span class="hljs-attr">refx</span>: <span class="hljs-string">&#x27;refX&#x27;</span>,
    <span class="hljs-attr">refy</span>: <span class="hljs-string">&#x27;refY&#x27;</span>,
    <span class="hljs-attr">renderingintent</span>: <span class="hljs-string">&#x27;renderingIntent&#x27;</span>,
    <span class="hljs-string">&#x27;rendering-intent&#x27;</span>: <span class="hljs-string">&#x27;renderingIntent&#x27;</span>,
    <span class="hljs-attr">repeatcount</span>: <span class="hljs-string">&#x27;repeatCount&#x27;</span>,
    <span class="hljs-attr">repeatdur</span>: <span class="hljs-string">&#x27;repeatDur&#x27;</span>,
    <span class="hljs-attr">requiredextensions</span>: <span class="hljs-string">&#x27;requiredExtensions&#x27;</span>,
    <span class="hljs-attr">requiredfeatures</span>: <span class="hljs-string">&#x27;requiredFeatures&#x27;</span>,
    <span class="hljs-attr">resource</span>: <span class="hljs-string">&#x27;resource&#x27;</span>,
    <span class="hljs-attr">restart</span>: <span class="hljs-string">&#x27;restart&#x27;</span>,
    <span class="hljs-attr">result</span>: <span class="hljs-string">&#x27;result&#x27;</span>,
    <span class="hljs-attr">results</span>: <span class="hljs-string">&#x27;results&#x27;</span>,
    <span class="hljs-attr">rotate</span>: <span class="hljs-string">&#x27;rotate&#x27;</span>,
    <span class="hljs-attr">rx</span>: <span class="hljs-string">&#x27;rx&#x27;</span>,
    <span class="hljs-attr">ry</span>: <span class="hljs-string">&#x27;ry&#x27;</span>,
    <span class="hljs-attr">scale</span>: <span class="hljs-string">&#x27;scale&#x27;</span>,
    <span class="hljs-attr">security</span>: <span class="hljs-string">&#x27;security&#x27;</span>,
    <span class="hljs-attr">seed</span>: <span class="hljs-string">&#x27;seed&#x27;</span>,
    <span class="hljs-attr">shaperendering</span>: <span class="hljs-string">&#x27;shapeRendering&#x27;</span>,
    <span class="hljs-string">&#x27;shape-rendering&#x27;</span>: <span class="hljs-string">&#x27;shapeRendering&#x27;</span>,
    <span class="hljs-attr">slope</span>: <span class="hljs-string">&#x27;slope&#x27;</span>,
    <span class="hljs-attr">spacing</span>: <span class="hljs-string">&#x27;spacing&#x27;</span>,
    <span class="hljs-attr">specularconstant</span>: <span class="hljs-string">&#x27;specularConstant&#x27;</span>,
    <span class="hljs-attr">specularexponent</span>: <span class="hljs-string">&#x27;specularExponent&#x27;</span>,
    <span class="hljs-attr">speed</span>: <span class="hljs-string">&#x27;speed&#x27;</span>,
    <span class="hljs-attr">spreadmethod</span>: <span class="hljs-string">&#x27;spreadMethod&#x27;</span>,
    <span class="hljs-attr">startoffset</span>: <span class="hljs-string">&#x27;startOffset&#x27;</span>,
    <span class="hljs-attr">stddeviation</span>: <span class="hljs-string">&#x27;stdDeviation&#x27;</span>,
    <span class="hljs-attr">stemh</span>: <span class="hljs-string">&#x27;stemh&#x27;</span>,
    <span class="hljs-attr">stemv</span>: <span class="hljs-string">&#x27;stemv&#x27;</span>,
    <span class="hljs-attr">stitchtiles</span>: <span class="hljs-string">&#x27;stitchTiles&#x27;</span>,
    <span class="hljs-attr">stopcolor</span>: <span class="hljs-string">&#x27;stopColor&#x27;</span>,
    <span class="hljs-string">&#x27;stop-color&#x27;</span>: <span class="hljs-string">&#x27;stopColor&#x27;</span>,
    <span class="hljs-attr">stopopacity</span>: <span class="hljs-string">&#x27;stopOpacity&#x27;</span>,
    <span class="hljs-string">&#x27;stop-opacity&#x27;</span>: <span class="hljs-string">&#x27;stopOpacity&#x27;</span>,
    <span class="hljs-attr">strikethroughposition</span>: <span class="hljs-string">&#x27;strikethroughPosition&#x27;</span>,
    <span class="hljs-string">&#x27;strikethrough-position&#x27;</span>: <span class="hljs-string">&#x27;strikethroughPosition&#x27;</span>,
    <span class="hljs-attr">strikethroughthickness</span>: <span class="hljs-string">&#x27;strikethroughThickness&#x27;</span>,
    <span class="hljs-string">&#x27;strikethrough-thickness&#x27;</span>: <span class="hljs-string">&#x27;strikethroughThickness&#x27;</span>,
    <span class="hljs-attr">string</span>: <span class="hljs-string">&#x27;string&#x27;</span>,
    <span class="hljs-attr">stroke</span>: <span class="hljs-string">&#x27;stroke&#x27;</span>,
    <span class="hljs-attr">strokedasharray</span>: <span class="hljs-string">&#x27;strokeDasharray&#x27;</span>,
    <span class="hljs-string">&#x27;stroke-dasharray&#x27;</span>: <span class="hljs-string">&#x27;strokeDasharray&#x27;</span>,
    <span class="hljs-attr">strokedashoffset</span>: <span class="hljs-string">&#x27;strokeDashoffset&#x27;</span>,
    <span class="hljs-string">&#x27;stroke-dashoffset&#x27;</span>: <span class="hljs-string">&#x27;strokeDashoffset&#x27;</span>,
    <span class="hljs-attr">strokelinecap</span>: <span class="hljs-string">&#x27;strokeLinecap&#x27;</span>,
    <span class="hljs-string">&#x27;stroke-linecap&#x27;</span>: <span class="hljs-string">&#x27;strokeLinecap&#x27;</span>,
    <span class="hljs-attr">strokelinejoin</span>: <span class="hljs-string">&#x27;strokeLinejoin&#x27;</span>,
    <span class="hljs-string">&#x27;stroke-linejoin&#x27;</span>: <span class="hljs-string">&#x27;strokeLinejoin&#x27;</span>,
    <span class="hljs-attr">strokemiterlimit</span>: <span class="hljs-string">&#x27;strokeMiterlimit&#x27;</span>,
    <span class="hljs-string">&#x27;stroke-miterlimit&#x27;</span>: <span class="hljs-string">&#x27;strokeMiterlimit&#x27;</span>,
    <span class="hljs-attr">strokewidth</span>: <span class="hljs-string">&#x27;strokeWidth&#x27;</span>,
    <span class="hljs-string">&#x27;stroke-width&#x27;</span>: <span class="hljs-string">&#x27;strokeWidth&#x27;</span>,
    <span class="hljs-attr">strokeopacity</span>: <span class="hljs-string">&#x27;strokeOpacity&#x27;</span>,
    <span class="hljs-string">&#x27;stroke-opacity&#x27;</span>: <span class="hljs-string">&#x27;strokeOpacity&#x27;</span>,
    <span class="hljs-attr">suppresscontenteditablewarning</span>: <span class="hljs-string">&#x27;suppressContentEditableWarning&#x27;</span>,
    <span class="hljs-attr">suppresshydrationwarning</span>: <span class="hljs-string">&#x27;suppressHydrationWarning&#x27;</span>,
    <span class="hljs-attr">surfacescale</span>: <span class="hljs-string">&#x27;surfaceScale&#x27;</span>,
    <span class="hljs-attr">systemlanguage</span>: <span class="hljs-string">&#x27;systemLanguage&#x27;</span>,
    <span class="hljs-attr">tablevalues</span>: <span class="hljs-string">&#x27;tableValues&#x27;</span>,
    <span class="hljs-attr">targetx</span>: <span class="hljs-string">&#x27;targetX&#x27;</span>,
    <span class="hljs-attr">targety</span>: <span class="hljs-string">&#x27;targetY&#x27;</span>,
    <span class="hljs-attr">textanchor</span>: <span class="hljs-string">&#x27;textAnchor&#x27;</span>,
    <span class="hljs-string">&#x27;text-anchor&#x27;</span>: <span class="hljs-string">&#x27;textAnchor&#x27;</span>,
    <span class="hljs-attr">textdecoration</span>: <span class="hljs-string">&#x27;textDecoration&#x27;</span>,
    <span class="hljs-string">&#x27;text-decoration&#x27;</span>: <span class="hljs-string">&#x27;textDecoration&#x27;</span>,
    <span class="hljs-attr">textlength</span>: <span class="hljs-string">&#x27;textLength&#x27;</span>,
    <span class="hljs-attr">textrendering</span>: <span class="hljs-string">&#x27;textRendering&#x27;</span>,
    <span class="hljs-string">&#x27;text-rendering&#x27;</span>: <span class="hljs-string">&#x27;textRendering&#x27;</span>,
    <span class="hljs-attr">to</span>: <span class="hljs-string">&#x27;to&#x27;</span>,
    <span class="hljs-attr">transform</span>: <span class="hljs-string">&#x27;transform&#x27;</span>,
    <span class="hljs-attr">typeof</span>: <span class="hljs-string">&#x27;typeof&#x27;</span>,
    <span class="hljs-attr">u1</span>: <span class="hljs-string">&#x27;u1&#x27;</span>,
    <span class="hljs-attr">u2</span>: <span class="hljs-string">&#x27;u2&#x27;</span>,
    <span class="hljs-attr">underlineposition</span>: <span class="hljs-string">&#x27;underlinePosition&#x27;</span>,
    <span class="hljs-string">&#x27;underline-position&#x27;</span>: <span class="hljs-string">&#x27;underlinePosition&#x27;</span>,
    <span class="hljs-attr">underlinethickness</span>: <span class="hljs-string">&#x27;underlineThickness&#x27;</span>,
    <span class="hljs-string">&#x27;underline-thickness&#x27;</span>: <span class="hljs-string">&#x27;underlineThickness&#x27;</span>,
    <span class="hljs-attr">unicode</span>: <span class="hljs-string">&#x27;unicode&#x27;</span>,
    <span class="hljs-attr">unicodebidi</span>: <span class="hljs-string">&#x27;unicodeBidi&#x27;</span>,
    <span class="hljs-string">&#x27;unicode-bidi&#x27;</span>: <span class="hljs-string">&#x27;unicodeBidi&#x27;</span>,
    <span class="hljs-attr">unicoderange</span>: <span class="hljs-string">&#x27;unicodeRange&#x27;</span>,
    <span class="hljs-string">&#x27;unicode-range&#x27;</span>: <span class="hljs-string">&#x27;unicodeRange&#x27;</span>,
    <span class="hljs-attr">unitsperem</span>: <span class="hljs-string">&#x27;unitsPerEm&#x27;</span>,
    <span class="hljs-string">&#x27;units-per-em&#x27;</span>: <span class="hljs-string">&#x27;unitsPerEm&#x27;</span>,
    <span class="hljs-attr">unselectable</span>: <span class="hljs-string">&#x27;unselectable&#x27;</span>,
    <span class="hljs-attr">valphabetic</span>: <span class="hljs-string">&#x27;vAlphabetic&#x27;</span>,
    <span class="hljs-string">&#x27;v-alphabetic&#x27;</span>: <span class="hljs-string">&#x27;vAlphabetic&#x27;</span>,
    <span class="hljs-attr">values</span>: <span class="hljs-string">&#x27;values&#x27;</span>,
    <span class="hljs-attr">vectoreffect</span>: <span class="hljs-string">&#x27;vectorEffect&#x27;</span>,
    <span class="hljs-string">&#x27;vector-effect&#x27;</span>: <span class="hljs-string">&#x27;vectorEffect&#x27;</span>,
    <span class="hljs-attr">version</span>: <span class="hljs-string">&#x27;version&#x27;</span>,
    <span class="hljs-attr">vertadvy</span>: <span class="hljs-string">&#x27;vertAdvY&#x27;</span>,
    <span class="hljs-string">&#x27;vert-adv-y&#x27;</span>: <span class="hljs-string">&#x27;vertAdvY&#x27;</span>,
    <span class="hljs-attr">vertoriginx</span>: <span class="hljs-string">&#x27;vertOriginX&#x27;</span>,
    <span class="hljs-string">&#x27;vert-origin-x&#x27;</span>: <span class="hljs-string">&#x27;vertOriginX&#x27;</span>,
    <span class="hljs-attr">vertoriginy</span>: <span class="hljs-string">&#x27;vertOriginY&#x27;</span>,
    <span class="hljs-string">&#x27;vert-origin-y&#x27;</span>: <span class="hljs-string">&#x27;vertOriginY&#x27;</span>,
    <span class="hljs-attr">vhanging</span>: <span class="hljs-string">&#x27;vHanging&#x27;</span>,
    <span class="hljs-string">&#x27;v-hanging&#x27;</span>: <span class="hljs-string">&#x27;vHanging&#x27;</span>,
    <span class="hljs-attr">videographic</span>: <span class="hljs-string">&#x27;vIdeographic&#x27;</span>,
    <span class="hljs-string">&#x27;v-ideographic&#x27;</span>: <span class="hljs-string">&#x27;vIdeographic&#x27;</span>,
    <span class="hljs-attr">viewbox</span>: <span class="hljs-string">&#x27;viewBox&#x27;</span>,
    <span class="hljs-attr">viewtarget</span>: <span class="hljs-string">&#x27;viewTarget&#x27;</span>,
    <span class="hljs-attr">visibility</span>: <span class="hljs-string">&#x27;visibility&#x27;</span>,
    <span class="hljs-attr">vmathematical</span>: <span class="hljs-string">&#x27;vMathematical&#x27;</span>,
    <span class="hljs-string">&#x27;v-mathematical&#x27;</span>: <span class="hljs-string">&#x27;vMathematical&#x27;</span>,
    <span class="hljs-attr">vocab</span>: <span class="hljs-string">&#x27;vocab&#x27;</span>,
    <span class="hljs-attr">widths</span>: <span class="hljs-string">&#x27;widths&#x27;</span>,
    <span class="hljs-attr">wordspacing</span>: <span class="hljs-string">&#x27;wordSpacing&#x27;</span>,
    <span class="hljs-string">&#x27;word-spacing&#x27;</span>: <span class="hljs-string">&#x27;wordSpacing&#x27;</span>,
    <span class="hljs-attr">writingmode</span>: <span class="hljs-string">&#x27;writingMode&#x27;</span>,
    <span class="hljs-string">&#x27;writing-mode&#x27;</span>: <span class="hljs-string">&#x27;writingMode&#x27;</span>,
    <span class="hljs-attr">x1</span>: <span class="hljs-string">&#x27;x1&#x27;</span>,
    <span class="hljs-attr">x2</span>: <span class="hljs-string">&#x27;x2&#x27;</span>,
    <span class="hljs-attr">x</span>: <span class="hljs-string">&#x27;x&#x27;</span>,
    <span class="hljs-attr">xchannelselector</span>: <span class="hljs-string">&#x27;xChannelSelector&#x27;</span>,
    <span class="hljs-attr">xheight</span>: <span class="hljs-string">&#x27;xHeight&#x27;</span>,
    <span class="hljs-string">&#x27;x-height&#x27;</span>: <span class="hljs-string">&#x27;xHeight&#x27;</span>,
    <span class="hljs-attr">xlinkactuate</span>: <span class="hljs-string">&#x27;xlinkActuate&#x27;</span>,
    <span class="hljs-string">&#x27;xlink:actuate&#x27;</span>: <span class="hljs-string">&#x27;xlinkActuate&#x27;</span>,
    <span class="hljs-attr">xlinkarcrole</span>: <span class="hljs-string">&#x27;xlinkArcrole&#x27;</span>,
    <span class="hljs-string">&#x27;xlink:arcrole&#x27;</span>: <span class="hljs-string">&#x27;xlinkArcrole&#x27;</span>,
    <span class="hljs-attr">xlinkhref</span>: <span class="hljs-string">&#x27;xlinkHref&#x27;</span>,
    <span class="hljs-string">&#x27;xlink:href&#x27;</span>: <span class="hljs-string">&#x27;xlinkHref&#x27;</span>,
    <span class="hljs-attr">xlinkrole</span>: <span class="hljs-string">&#x27;xlinkRole&#x27;</span>,
    <span class="hljs-string">&#x27;xlink:role&#x27;</span>: <span class="hljs-string">&#x27;xlinkRole&#x27;</span>,
    <span class="hljs-attr">xlinkshow</span>: <span class="hljs-string">&#x27;xlinkShow&#x27;</span>,
    <span class="hljs-string">&#x27;xlink:show&#x27;</span>: <span class="hljs-string">&#x27;xlinkShow&#x27;</span>,
    <span class="hljs-attr">xlinktitle</span>: <span class="hljs-string">&#x27;xlinkTitle&#x27;</span>,
    <span class="hljs-string">&#x27;xlink:title&#x27;</span>: <span class="hljs-string">&#x27;xlinkTitle&#x27;</span>,
    <span class="hljs-attr">xlinktype</span>: <span class="hljs-string">&#x27;xlinkType&#x27;</span>,
    <span class="hljs-string">&#x27;xlink:type&#x27;</span>: <span class="hljs-string">&#x27;xlinkType&#x27;</span>,
    <span class="hljs-attr">xmlbase</span>: <span class="hljs-string">&#x27;xmlBase&#x27;</span>,
    <span class="hljs-string">&#x27;xml:base&#x27;</span>: <span class="hljs-string">&#x27;xmlBase&#x27;</span>,
    <span class="hljs-attr">xmllang</span>: <span class="hljs-string">&#x27;xmlLang&#x27;</span>,
    <span class="hljs-string">&#x27;xml:lang&#x27;</span>: <span class="hljs-string">&#x27;xmlLang&#x27;</span>,
    <span class="hljs-attr">xmlns</span>: <span class="hljs-string">&#x27;xmlns&#x27;</span>,
    <span class="hljs-string">&#x27;xml:space&#x27;</span>: <span class="hljs-string">&#x27;xmlSpace&#x27;</span>,
    <span class="hljs-attr">xmlnsxlink</span>: <span class="hljs-string">&#x27;xmlnsXlink&#x27;</span>,
    <span class="hljs-string">&#x27;xmlns:xlink&#x27;</span>: <span class="hljs-string">&#x27;xmlnsXlink&#x27;</span>,
    <span class="hljs-attr">xmlspace</span>: <span class="hljs-string">&#x27;xmlSpace&#x27;</span>,
    <span class="hljs-attr">y1</span>: <span class="hljs-string">&#x27;y1&#x27;</span>,
    <span class="hljs-attr">y2</span>: <span class="hljs-string">&#x27;y2&#x27;</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-string">&#x27;y&#x27;</span>,
    <span class="hljs-attr">ychannelselector</span>: <span class="hljs-string">&#x27;yChannelSelector&#x27;</span>,
    <span class="hljs-attr">z</span>: <span class="hljs-string">&#x27;z&#x27;</span>,
    <span class="hljs-attr">zoomandpan</span>: <span class="hljs-string">&#x27;zoomAndPan&#x27;</span>
  };

  <span class="hljs-keyword">var</span> ariaProperties = {
    <span class="hljs-string">&#x27;aria-current&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-116">&#x00a7;</a>
              </div>
              <p>state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-details&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-disabled&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-117">&#x00a7;</a>
              </div>
              <p>state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-hidden&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-118">&#x00a7;</a>
              </div>
              <p>state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-invalid&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-119">&#x00a7;</a>
              </div>
              <p>state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-keyshortcuts&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-label&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-roledescription&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-120">&#x00a7;</a>
              </div>
              <p>Widget Attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-autocomplete&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-checked&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-expanded&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-haspopup&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-level&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-modal&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-multiline&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-multiselectable&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-orientation&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-placeholder&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-pressed&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-readonly&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-required&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-selected&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-sort&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-valuemax&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-valuemin&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-valuenow&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-valuetext&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-121">&#x00a7;</a>
              </div>
              <p>Live Region Attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-atomic&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-busy&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-live&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-relevant&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-122">&#x00a7;</a>
              </div>
              <p>Drag-and-Drop Attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-dropeffect&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-grabbed&#x27;</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-123">&#x00a7;</a>
              </div>
              <p>Relationship Attributes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-string">&#x27;aria-activedescendant&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-colcount&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-colindex&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-colspan&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-controls&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-describedby&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-errormessage&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-flowto&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-labelledby&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-owns&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-posinset&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-rowcount&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-rowindex&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-rowspan&#x27;</span>: <span class="hljs-number">0</span>,
    <span class="hljs-string">&#x27;aria-setsize&#x27;</span>: <span class="hljs-number">0</span>
  };

  <span class="hljs-keyword">var</span> warnedProperties = {};
  <span class="hljs-keyword">var</span> rARIA = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;^(aria)-[&#x27;</span> + <span class="hljs-variable constant_">ATTRIBUTE_NAME_CHAR</span> + <span class="hljs-string">&#x27;]*$&#x27;</span>);
  <span class="hljs-keyword">var</span> rARIACamel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;^(aria)[A-Z][&#x27;</span> + <span class="hljs-variable constant_">ATTRIBUTE_NAME_CHAR</span> + <span class="hljs-string">&#x27;]*$&#x27;</span>);
  <span class="hljs-keyword">var</span> hasOwnProperty$<span class="hljs-number">1</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateProperty</span>(<span class="hljs-params">tagName, name</span>) {
    {
      <span class="hljs-keyword">if</span> (hasOwnProperty$<span class="hljs-number">1.</span><span class="hljs-title function_">call</span>(warnedProperties, name) &amp;&amp; warnedProperties[name]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (rARIACamel.<span class="hljs-title function_">test</span>(name)) {
        <span class="hljs-keyword">var</span> ariaName = <span class="hljs-string">&#x27;aria-&#x27;</span> + name.<span class="hljs-title function_">slice</span>(<span class="hljs-number">4</span>).<span class="hljs-title function_">toLowerCase</span>();
        <span class="hljs-keyword">var</span> correctName = ariaProperties.<span class="hljs-title function_">hasOwnProperty</span>(ariaName) ? ariaName : <span class="hljs-literal">null</span>; <span class="hljs-comment">// If this is an aria-* attribute, but is not listed in the known DOM</span></pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-124">&#x00a7;</a>
              </div>
              <p>DOM properties, then it is an invalid aria-* attribute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (correctName == <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.&#x27;</span>, name);

          warnedProperties[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// aria-* attributes should be lowercase; suggest the lowercase version.</span>


        <span class="hljs-keyword">if</span> (name !== correctName) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid ARIA attribute `%s`. Did you mean `%s`?&#x27;</span>, name, correctName);

          warnedProperties[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">if</span> (rARIA.<span class="hljs-title function_">test</span>(name)) {
        <span class="hljs-keyword">var</span> lowerCasedName = name.<span class="hljs-title function_">toLowerCase</span>();
        <span class="hljs-keyword">var</span> standardName = ariaProperties.<span class="hljs-title function_">hasOwnProperty</span>(lowerCasedName) ? lowerCasedName : <span class="hljs-literal">null</span>; <span class="hljs-comment">// If this is an aria-* attribute, but is not listed in the known DOM</span></pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-125">&#x00a7;</a>
              </div>
              <p>DOM properties, then it is an invalid aria-* attribute.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (standardName == <span class="hljs-literal">null</span>) {
          warnedProperties[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        } <span class="hljs-comment">// aria-* attributes should be lowercase; suggest the lowercase version.</span>


        <span class="hljs-keyword">if</span> (name !== standardName) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unknown ARIA attribute `%s`. Did you mean `%s`?&#x27;</span>, name, standardName);

          warnedProperties[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnInvalidARIAProps</span>(<span class="hljs-params">type, props</span>) {
    {
      <span class="hljs-keyword">var</span> invalidProps = [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> props) {
        <span class="hljs-keyword">var</span> isValid = <span class="hljs-title function_">validateProperty</span>(type, key);

        <span class="hljs-keyword">if</span> (!isValid) {
          invalidProps.<span class="hljs-title function_">push</span>(key);
        }
      }

      <span class="hljs-keyword">var</span> unknownPropString = invalidProps.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;`&#x27;</span> + prop + <span class="hljs-string">&#x27;`&#x27;</span>;
      }).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>);

      <span class="hljs-keyword">if</span> (invalidProps.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid aria prop %s on &lt;%s&gt; tag. &#x27;</span> + <span class="hljs-string">&#x27;For details, see https://reactjs.org/link/invalid-aria-props&#x27;</span>, unknownPropString, type);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (invalidProps.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid aria props %s on &lt;%s&gt; tag. &#x27;</span> + <span class="hljs-string">&#x27;For details, see https://reactjs.org/link/invalid-aria-props&#x27;</span>, unknownPropString, type);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateProperties</span>(<span class="hljs-params">type, props</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCustomComponent</span>(type, props)) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-title function_">warnInvalidARIAProps</span>(type, props);
  }

  <span class="hljs-keyword">var</span> didWarnValueNull = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateProperties$1</span>(<span class="hljs-params">type, props</span>) {
    {
      <span class="hljs-keyword">if</span> (type !== <span class="hljs-string">&#x27;input&#x27;</span> &amp;&amp; type !== <span class="hljs-string">&#x27;textarea&#x27;</span> &amp;&amp; type !== <span class="hljs-string">&#x27;select&#x27;</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (props != <span class="hljs-literal">null</span> &amp;&amp; props.<span class="hljs-property">value</span> === <span class="hljs-literal">null</span> &amp;&amp; !didWarnValueNull) {
        didWarnValueNull = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;select&#x27;</span> &amp;&amp; props.<span class="hljs-property">multiple</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;`value` prop on `%s` should not be null. &#x27;</span> + <span class="hljs-string">&#x27;Consider using an empty array when `multiple` is set to `true` &#x27;</span> + <span class="hljs-string">&#x27;to clear the component or `undefined` for uncontrolled components.&#x27;</span>, type);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;`value` prop on `%s` should not be null. &#x27;</span> + <span class="hljs-string">&#x27;Consider using an empty string to clear the component or `undefined` &#x27;</span> + <span class="hljs-string">&#x27;for uncontrolled components.&#x27;</span>, type);
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> validateProperty$<span class="hljs-number">1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };

  {
    <span class="hljs-keyword">var</span> warnedProperties$<span class="hljs-number">1</span> = {};
    <span class="hljs-keyword">var</span> _hasOwnProperty = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>;
    <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">EVENT_NAME_REGEX</span> = <span class="hljs-regexp">/^on./</span>;
    <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">INVALID_EVENT_NAME_REGEX</span> = <span class="hljs-regexp">/^on[^A-Z]/</span>;
    <span class="hljs-keyword">var</span> rARIA$<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;^(aria)-[&#x27;</span> + <span class="hljs-variable constant_">ATTRIBUTE_NAME_CHAR</span> + <span class="hljs-string">&#x27;]*$&#x27;</span>);
    <span class="hljs-keyword">var</span> rARIACamel$<span class="hljs-number">1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;^(aria)[A-Z][&#x27;</span> + <span class="hljs-variable constant_">ATTRIBUTE_NAME_CHAR</span> + <span class="hljs-string">&#x27;]*$&#x27;</span>);

    validateProperty$<span class="hljs-number">1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">tagName, name, value, eventRegistry</span>) {
      <span class="hljs-keyword">if</span> (_hasOwnProperty.<span class="hljs-title function_">call</span>(warnedProperties$<span class="hljs-number">1</span>, name) &amp;&amp; warnedProperties$<span class="hljs-number">1</span>[name]) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">var</span> lowerCasedName = name.<span class="hljs-title function_">toLowerCase</span>();

      <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">&#x27;onfocusin&#x27;</span> || lowerCasedName === <span class="hljs-string">&#x27;onfocusout&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React uses onFocus and onBlur instead of onFocusIn and onFocusOut. &#x27;</span> + <span class="hljs-string">&#x27;All React events are normalized to bubble, so onFocusIn and onFocusOut &#x27;</span> + <span class="hljs-string">&#x27;are not needed/supported by React.&#x27;</span>);

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-comment">// We can&#x27;t rely on the event system being injected on the server.</span>


      <span class="hljs-keyword">if</span> (eventRegistry != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> registrationNameDependencies = eventRegistry.<span class="hljs-property">registrationNameDependencies</span>,
          possibleRegistrationNames = eventRegistry.<span class="hljs-property">possibleRegistrationNames</span>;

        <span class="hljs-keyword">if</span> (registrationNameDependencies.<span class="hljs-title function_">hasOwnProperty</span>(name)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">var</span> registrationName = possibleRegistrationNames.<span class="hljs-title function_">hasOwnProperty</span>(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (registrationName != <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid event handler property `%s`. Did you mean `%s`?&#x27;</span>, name, registrationName);

          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">EVENT_NAME_REGEX</span>.<span class="hljs-title function_">test</span>(name)) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unknown event handler property `%s`. It will be ignored.&#x27;</span>, name);

          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">EVENT_NAME_REGEX</span>.<span class="hljs-title function_">test</span>(name)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-126">&#x00a7;</a>
              </div>
              <p>If no event plugins have been injected, we are in a server environment.
So we can’t tell if the event name is correct for sure, but we can filter
out known bad ones like <code>onclick</code>. We can’t suggest a specific replacement though.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-variable constant_">INVALID_EVENT_NAME_REGEX</span>.<span class="hljs-title function_">test</span>(name)) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid event handler property `%s`. &#x27;</span> + <span class="hljs-string">&#x27;React events use the camelCase naming convention, for example `onClick`.&#x27;</span>, name);
        }

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-comment">// Let the ARIA attribute hook validate ARIA attributes</span>


      <span class="hljs-keyword">if</span> (rARIA$<span class="hljs-number">1.</span><span class="hljs-title function_">test</span>(name) || rARIACamel$<span class="hljs-number">1.</span><span class="hljs-title function_">test</span>(name)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">&#x27;innerhtml&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Directly setting property `innerHTML` is not permitted. &#x27;</span> + <span class="hljs-string">&#x27;For more information, lookup documentation on `dangerouslySetInnerHTML`.&#x27;</span>);

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">&#x27;aria&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The `aria` attribute is reserved for future use in React. &#x27;</span> + <span class="hljs-string">&#x27;Pass individual `aria-` attributes instead.&#x27;</span>);

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (lowerCasedName === <span class="hljs-string">&#x27;is&#x27;</span> &amp;&amp; value !== <span class="hljs-literal">null</span> &amp;&amp; value !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;string&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Received a `%s` for a string attribute `is`. If this is expected, cast &#x27;</span> + <span class="hljs-string">&#x27;the value to a string.&#x27;</span>, <span class="hljs-keyword">typeof</span> value);

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(value)) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Received NaN for the `%s` attribute. If this is expected, cast &#x27;</span> + <span class="hljs-string">&#x27;the value to a string.&#x27;</span>, name);

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">var</span> propertyInfo = <span class="hljs-title function_">getPropertyInfo</span>(name);
      <span class="hljs-keyword">var</span> isReserved = propertyInfo !== <span class="hljs-literal">null</span> &amp;&amp; propertyInfo.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">RESERVED</span>; <span class="hljs-comment">// Known attributes should match the casing specified in the property config.</span>

      <span class="hljs-keyword">if</span> (possibleStandardNames.<span class="hljs-title function_">hasOwnProperty</span>(lowerCasedName)) {
        <span class="hljs-keyword">var</span> standardName = possibleStandardNames[lowerCasedName];

        <span class="hljs-keyword">if</span> (standardName !== name) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid DOM property `%s`. Did you mean `%s`?&#x27;</span>, name, standardName);

          warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved &amp;&amp; name !== lowerCasedName) {</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-127">&#x00a7;</a>
              </div>
              <p>Unknown attributes should have lowercase casing since that’s how they
will be cased anyway with server rendering.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React does not recognize the `%s` prop on a DOM element. If you &#x27;</span> + <span class="hljs-string">&#x27;intentionally want it to appear in the DOM as a custom &#x27;</span> + <span class="hljs-string">&#x27;attribute, spell it as lowercase `%s` instead. &#x27;</span> + <span class="hljs-string">&#x27;If you accidentally passed it from a parent component, remove &#x27;</span> + <span class="hljs-string">&#x27;it from the DOM element.&#x27;</span>, name, lowerCasedName);

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;boolean&#x27;</span> &amp;&amp; <span class="hljs-title function_">shouldRemoveAttributeWithWarning</span>(name, value, propertyInfo, <span class="hljs-literal">false</span>)) {
        <span class="hljs-keyword">if</span> (value) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Received `%s` for a non-boolean attribute `%s`.\n\n&#x27;</span> + <span class="hljs-string">&#x27;If you want to write it to the DOM, pass a string instead: &#x27;</span> + <span class="hljs-string">&#x27;%s=&quot;%s&quot; or %s={value.toString()}.&#x27;</span>, value, name, name, value, name);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Received `%s` for a non-boolean attribute `%s`.\n\n&#x27;</span> + <span class="hljs-string">&#x27;If you want to write it to the DOM, pass a string instead: &#x27;</span> + <span class="hljs-string">&#x27;%s=&quot;%s&quot; or %s={value.toString()}.\n\n&#x27;</span> + <span class="hljs-string">&#x27;If you used to conditionally omit it with %s={condition &amp;&amp; value}, &#x27;</span> + <span class="hljs-string">&#x27;pass %s={condition ? value : undefined} instead.&#x27;</span>, value, name, name, value, name, name, name);
        }

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-comment">// Now that we&#x27;ve validated casing, do not validate</span></pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-128">&#x00a7;</a>
              </div>
              <p>data types for reserved props</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (isReserved) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      } <span class="hljs-comment">// Warn when a known attribute is a bad type</span>


      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldRemoveAttributeWithWarning</span>(name, value, propertyInfo, <span class="hljs-literal">false</span>)) {
        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-comment">// Warn when passing the strings &#x27;false&#x27; or &#x27;true&#x27; into a boolean prop</span>


      <span class="hljs-keyword">if</span> ((value === <span class="hljs-string">&#x27;false&#x27;</span> || value === <span class="hljs-string">&#x27;true&#x27;</span>) &amp;&amp; propertyInfo !== <span class="hljs-literal">null</span> &amp;&amp; propertyInfo.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">BOOLEAN</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Received the string `%s` for the boolean attribute `%s`. &#x27;</span> + <span class="hljs-string">&#x27;%s &#x27;</span> + <span class="hljs-string">&#x27;Did you mean %s={%s}?&#x27;</span>, value, name, value === <span class="hljs-string">&#x27;false&#x27;</span> ? <span class="hljs-string">&#x27;The browser will interpret it as a truthy value.&#x27;</span> : <span class="hljs-string">&#x27;Although this works, it will not work as expected if you pass the string &quot;false&quot;.&#x27;</span>, name, value);

        warnedProperties$<span class="hljs-number">1</span>[name] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };
  }

  <span class="hljs-keyword">var</span> warnUnknownProperties = <span class="hljs-keyword">function</span> (<span class="hljs-params">type, props, eventRegistry</span>) {
    {
      <span class="hljs-keyword">var</span> unknownProps = [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> props) {
        <span class="hljs-keyword">var</span> isValid = <span class="hljs-title function_">validateProperty$1</span>(type, key, props[key], eventRegistry);

        <span class="hljs-keyword">if</span> (!isValid) {
          unknownProps.<span class="hljs-title function_">push</span>(key);
        }
      }

      <span class="hljs-keyword">var</span> unknownPropString = unknownProps.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;`&#x27;</span> + prop + <span class="hljs-string">&#x27;`&#x27;</span>;
      }).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>);

      <span class="hljs-keyword">if</span> (unknownProps.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid value for prop %s on &lt;%s&gt; tag. Either remove it from the element, &#x27;</span> + <span class="hljs-string">&#x27;or pass a string or number value to keep it in the DOM. &#x27;</span> + <span class="hljs-string">&#x27;For details, see https://reactjs.org/link/attribute-behavior &#x27;</span>, unknownPropString, type);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unknownProps.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Invalid values for props %s on &lt;%s&gt; tag. Either remove them from the element, &#x27;</span> + <span class="hljs-string">&#x27;or pass a string or number value to keep them in the DOM. &#x27;</span> + <span class="hljs-string">&#x27;For details, see https://reactjs.org/link/attribute-behavior &#x27;</span>, unknownPropString, type);
      }
    }
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateProperties$2</span>(<span class="hljs-params">type, props, eventRegistry</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isCustomComponent</span>(type, props)) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-title function_">warnUnknownProperties</span>(type, props, eventRegistry);
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">IS_EVENT_HANDLE_NON_MANAGED_NODE</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">IS_NON_DELEGATED</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">IS_REPLAYED</span> = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-129">&#x00a7;</a>
              </div>
              <p>set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
we call willDeferLaterForLegacyFBSupport, thus not bailing out
will result in endless cycles like an infinite loop.
We also don’t want to defer during event replaying.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS</span> = <span class="hljs-variable constant_">IS_EVENT_HANDLE_NON_MANAGED_NODE</span> | <span class="hljs-variable constant_">IS_NON_DELEGATED</span> | <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>;

  <span class="hljs-comment">/**
   * Gets the target node from a native browser event by accounting for
   * inconsistencies in browser DOM APIs.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} nativeEvent Native browser event.
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">DOMEventTarget</span>} Target node.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEventTarget</span>(<span class="hljs-params">nativeEvent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-130">&#x00a7;</a>
              </div>
              <p>Fallback to nativeEvent.srcElement for IE9
<a href="https://github.com/facebook/react/issues/12506">https://github.com/facebook/react/issues/12506</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> target = nativeEvent.<span class="hljs-property">target</span> || nativeEvent.<span class="hljs-property">srcElement</span> || <span class="hljs-variable language_">window</span>; <span class="hljs-comment">// Normalize SVG &lt;use&gt; element events #4963</span>

    <span class="hljs-keyword">if</span> (target.<span class="hljs-property">correspondingUseElement</span>) {
      target = target.<span class="hljs-property">correspondingUseElement</span>;
    } <span class="hljs-comment">// Safari may fire events on text nodes (Node.TEXT_NODE is 3).</span></pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-131">&#x00a7;</a>
              </div>
              <p>@see <a href="http://www.quirksmode.org/js/events_properties.html">http://www.quirksmode.org/js/events_properties.html</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">return</span> target.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span> ? target.<span class="hljs-property">parentNode</span> : target;
  }

  <span class="hljs-keyword">var</span> restoreImpl = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> restoreTarget = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> restoreQueue = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreStateOfTarget</span>(<span class="hljs-params">target</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-132">&#x00a7;</a>
              </div>
              <p>We perform this translation at the end of the event loop so that we
always receive the correct fiber here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> internalInstance = <span class="hljs-title function_">getInstanceFromNode</span>(target);

    <span class="hljs-keyword">if</span> (!internalInstance) {</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-133">&#x00a7;</a>
              </div>
              <p>Unmounted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> restoreImpl === <span class="hljs-string">&#x27;function&#x27;</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }

    <span class="hljs-keyword">var</span> stateNode = internalInstance.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// Guard against Fiber being unmounted.</span>

    <span class="hljs-keyword">if</span> (stateNode) {
      <span class="hljs-keyword">var</span> _props = <span class="hljs-title function_">getFiberCurrentPropsFromNode</span>(stateNode);

      <span class="hljs-title function_">restoreImpl</span>(internalInstance.<span class="hljs-property">stateNode</span>, internalInstance.<span class="hljs-property">type</span>, _props);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setRestoreImplementation</span>(<span class="hljs-params">impl</span>) {
    restoreImpl = impl;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueueStateRestore</span>(<span class="hljs-params">target</span>) {
    <span class="hljs-keyword">if</span> (restoreTarget) {
      <span class="hljs-keyword">if</span> (restoreQueue) {
        restoreQueue.<span class="hljs-title function_">push</span>(target);
      } <span class="hljs-keyword">else</span> {
        restoreQueue = [target];
      }
    } <span class="hljs-keyword">else</span> {
      restoreTarget = target;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">needsStateRestore</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> restoreTarget !== <span class="hljs-literal">null</span> || restoreQueue !== <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreStateIfNeeded</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!restoreTarget) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> target = restoreTarget;
    <span class="hljs-keyword">var</span> queuedTargets = restoreQueue;
    restoreTarget = <span class="hljs-literal">null</span>;
    restoreQueue = <span class="hljs-literal">null</span>;
    <span class="hljs-title function_">restoreStateOfTarget</span>(target);

    <span class="hljs-keyword">if</span> (queuedTargets) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; queuedTargets.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-title function_">restoreStateOfTarget</span>(queuedTargets[i]);
      }
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-134">&#x00a7;</a>
              </div>
              <p>the renderer. Such as when we’re dispatching events or if third party
libraries need to call batchedUpdates. Eventually, this API will go away when
everything is batched by default. We’ll then have a similar API to opt-out of
scheduled work and instead do synchronous work.
Defaults</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> batchedUpdatesImpl = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, bookkeeping</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(bookkeeping);
  };

  <span class="hljs-keyword">var</span> discreteUpdatesImpl = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, a, b, c, d</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a, b, c, d);
  };

  <span class="hljs-keyword">var</span> flushDiscreteUpdatesImpl = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };

  <span class="hljs-keyword">var</span> batchedEventUpdatesImpl = batchedUpdatesImpl;
  <span class="hljs-keyword">var</span> isInsideEventHandler = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> isBatchingEventUpdates = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">finishEventHandler</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-135">&#x00a7;</a>
              </div>
              <p>Here we wait until all updates have propagated, which is important
when using controlled components within layers:
<a href="https://github.com/facebook/react/issues/1698">https://github.com/facebook/react/issues/1698</a>
Then we restore state of any controlled component.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> controlledComponentsHavePendingUpdates = <span class="hljs-title function_">needsStateRestore</span>();

    <span class="hljs-keyword">if</span> (controlledComponentsHavePendingUpdates) {</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-136">&#x00a7;</a>
              </div>
              <p>If a controlled event was fired, we may need to restore the state of
the DOM node back to the controlled value. This is necessary when React
bails out of the update without touching the DOM.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">flushDiscreteUpdatesImpl</span>();
      <span class="hljs-title function_">restoreStateIfNeeded</span>();
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedUpdates</span>(<span class="hljs-params">fn, bookkeeping</span>) {
    <span class="hljs-keyword">if</span> (isInsideEventHandler) {</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-137">&#x00a7;</a>
              </div>
              <p>If we are currently inside another batch, we need to wait until it
fully completes before restoring state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(bookkeeping);
    }

    isInsideEventHandler = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">batchedUpdatesImpl</span>(fn, bookkeeping);
    } <span class="hljs-keyword">finally</span> {
      isInsideEventHandler = <span class="hljs-literal">false</span>;
      <span class="hljs-title function_">finishEventHandler</span>();
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedEventUpdates</span>(<span class="hljs-params">fn, a, b</span>) {
    <span class="hljs-keyword">if</span> (isBatchingEventUpdates) {</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-138">&#x00a7;</a>
              </div>
              <p>If we are currently inside another batch, we need to wait until it
fully completes before restoring state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a, b);
    }

    isBatchingEventUpdates = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">batchedEventUpdatesImpl</span>(fn, a, b);
    } <span class="hljs-keyword">finally</span> {
      isBatchingEventUpdates = <span class="hljs-literal">false</span>;
      <span class="hljs-title function_">finishEventHandler</span>();
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">discreteUpdates</span>(<span class="hljs-params">fn, a, b, c, d</span>) {
    <span class="hljs-keyword">var</span> prevIsInsideEventHandler = isInsideEventHandler;
    isInsideEventHandler = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">discreteUpdatesImpl</span>(fn, a, b, c, d);
    } <span class="hljs-keyword">finally</span> {
      isInsideEventHandler = prevIsInsideEventHandler;

      <span class="hljs-keyword">if</span> (!isInsideEventHandler) {
        <span class="hljs-title function_">finishEventHandler</span>();
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushDiscreteUpdatesIfNeeded</span>(<span class="hljs-params">timeStamp</span>) {
    {
      <span class="hljs-keyword">if</span> (!isInsideEventHandler) {
        <span class="hljs-title function_">flushDiscreteUpdatesImpl</span>();
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setBatchingImplementation</span>(<span class="hljs-params">_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl</span>) {
    batchedUpdatesImpl = _batchedUpdatesImpl;
    discreteUpdatesImpl = _discreteUpdatesImpl;
    flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
    batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isInteractive</span>(<span class="hljs-params">tag</span>) {
    <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;button&#x27;</span> || tag === <span class="hljs-string">&#x27;input&#x27;</span> || tag === <span class="hljs-string">&#x27;select&#x27;</span> || tag === <span class="hljs-string">&#x27;textarea&#x27;</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldPreventMouseEvent</span>(<span class="hljs-params">name, type, props</span>) {
    <span class="hljs-keyword">switch</span> (name) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onClick&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onClickCapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onDoubleClick&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onDoubleClickCapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onMouseDown&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onMouseDownCapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onMouseMove&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onMouseMoveCapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onMouseUp&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onMouseUpCapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;onMouseEnter&#x27;</span>:
        <span class="hljs-keyword">return</span> !!(props.<span class="hljs-property">disabled</span> &amp;&amp; <span class="hljs-title function_">isInteractive</span>(type));

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} inst The instance, which is the source of events.
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} registrationName Name of listener (e.g. `onClick`).
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?function</span>} The stored callback.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getListener</span>(<span class="hljs-params">inst, registrationName</span>) {
    <span class="hljs-keyword">var</span> stateNode = inst.<span class="hljs-property">stateNode</span>;

    <span class="hljs-keyword">if</span> (stateNode === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-139">&#x00a7;</a>
              </div>
              <p>Work in progress (ex: onload events in incremental mode).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> props = <span class="hljs-title function_">getFiberCurrentPropsFromNode</span>(stateNode);

    <span class="hljs-keyword">if</span> (props === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-140">&#x00a7;</a>
              </div>
              <p>Work in progress.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> listener = props[registrationName];

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldPreventMouseEvent</span>(registrationName, inst.<span class="hljs-property">type</span>, props)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (!(!listener || <span class="hljs-keyword">typeof</span> listener === <span class="hljs-string">&#x27;function&#x27;</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected `&quot;</span> + registrationName + <span class="hljs-string">&quot;` listener to be a function, instead got a value of `&quot;</span> + <span class="hljs-keyword">typeof</span> listener + <span class="hljs-string">&quot;` type.&quot;</span>);
      }
    }

    <span class="hljs-keyword">return</span> listener;
  }

  <span class="hljs-keyword">var</span> passiveBrowserEventsSupported = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Check if browser support events with passive listeners</span></pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-141">&#x00a7;</a>
              </div>
              <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support">https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">if</span> (canUseDOM) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> options = {}; <span class="hljs-comment">// $FlowFixMe: Ignore Flow complaining about needing a value</span>

      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(options, <span class="hljs-string">&#x27;passive&#x27;</span>, {
        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          passiveBrowserEventsSupported = <span class="hljs-literal">true</span>;
        }
      });
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;test&#x27;</span>, options, options);
      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;test&#x27;</span>, options, options);
    } <span class="hljs-keyword">catch</span> (e) {
      passiveBrowserEventsSupported = <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeGuardedCallbackProd</span>(<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) {
    <span class="hljs-keyword">var</span> funcArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">3</span>);

    <span class="hljs-keyword">try</span> {
      func.<span class="hljs-title function_">apply</span>(context, funcArgs);
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(error);
    }
  }

  <span class="hljs-keyword">var</span> invokeGuardedCallbackImpl = invokeGuardedCallbackProd;

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-142">&#x00a7;</a>
              </div>
              <p>In DEV mode, we swap out invokeGuardedCallback for a special version
that plays more nicely with the browser’s DevTools. The idea is to preserve
“Pause on exceptions” behavior. Because React wraps all user-provided
functions in invokeGuardedCallback, and the production version of
invokeGuardedCallback uses a try-catch, all user exceptions are treated
like caught exceptions, and the DevTools won’t pause unless the developer
takes the extra step of enabling pause on caught exceptions. This is
unintuitive, though, because even though React has caught the error, from
the developer’s perspective, the error is uncaught.</p>
<p>To preserve the expected “Pause on exceptions” behavior, we don’t use a
try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
DOM node, and call the user-provided callback from inside an event handler
for that fake event. If the callback throws, the error is “captured” using
a global event handler. But because the error happens in a different
event loop context, it does not interrupt the normal program flow.
Effectively, this gives us try-catch behavior without actually using
try-catch. Neat!
Check that the browser supports the APIs we need to implement our special
DEV version of invokeGuardedCallback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">dispatchEvent</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">createEvent</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">var</span> fakeNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;react&#x27;</span>);

      invokeGuardedCallbackImpl = <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeGuardedCallbackDev</span>(<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-143">&#x00a7;</a>
              </div>
              <p>If document doesn’t exist we know for sure we will crash in this method
when we call document.createEvent(). However this can cause confusing
errors: <a href="https://github.com/facebookincubator/create-react-app/issues/3482">https://github.com/facebookincubator/create-react-app/issues/3482</a>
So we preemptively throw with a better message instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">document</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.&quot;</span>);
          }
        }

        <span class="hljs-keyword">var</span> evt = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createEvent</span>(<span class="hljs-string">&#x27;Event&#x27;</span>);
        <span class="hljs-keyword">var</span> didCall = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Keeps track of whether the user-provided callback threw an error. We</span></pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-144">&#x00a7;</a>
              </div>
              <p>set this to true at the beginning, then set it to false right after
calling the function. If the function errors, <code>didError</code> will never be
set to false. This strategy works even if the browser is flaky and
fails to call our global error handler, because it doesn’t rely on
the error event at all.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> didError = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Keeps track of the value of window.event so that we can reset it</span></pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-145">&#x00a7;</a>
              </div>
              <p>during the callback to let user code access window.event in the
browsers that support it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> windowEvent = <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>; <span class="hljs-comment">// Keeps track of the descriptor of window.event to restore it after event</span></pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-146">&#x00a7;</a>
              </div>
              <p>dispatching: <a href="https://github.com/facebook/react/issues/13688">https://github.com/facebook/react/issues/13688</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> windowEventDescriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-variable language_">window</span>, <span class="hljs-string">&#x27;event&#x27;</span>);

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreAfterDispatch</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-147">&#x00a7;</a>
              </div>
              <p>We immediately remove the callback from event listeners so that
nested <code>invokeGuardedCallback</code> calls do not clash. Otherwise, a
nested call would trigger the fake event handlers of any call higher
in the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          fakeNode.<span class="hljs-title function_">removeEventListener</span>(evtType, callCallback, <span class="hljs-literal">false</span>); <span class="hljs-comment">// We check for window.hasOwnProperty(&#x27;event&#x27;) to prevent the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-148">&#x00a7;</a>
              </div>
              <p>window.event assignment in both IE &lt;= 10 as they throw an error
“Member not found” in strict mode, and in Firefox which does not
support window.event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;event&#x27;</span>)) {
            <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span> = windowEvent;
          }
        } <span class="hljs-comment">// Create an event handler for our fake event. We will synchronously</span></pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-149">&#x00a7;</a>
              </div>
              <p>dispatch our fake event using <code>dispatchEvent</code>. Inside the handler, we
call the user-provided callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-keyword">var</span> funcArgs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">3</span>);

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">callCallback</span>(<span class="hljs-params"></span>) {
          didCall = <span class="hljs-literal">true</span>;
          <span class="hljs-title function_">restoreAfterDispatch</span>();
          func.<span class="hljs-title function_">apply</span>(context, funcArgs);
          didError = <span class="hljs-literal">false</span>;
        } <span class="hljs-comment">// Create a global error event handler. We use this to capture the value</span></pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-150">&#x00a7;</a>
              </div>
              <p>that was thrown. It’s possible that this error handler will fire more
than once; for example, if non-React code also calls <code>dispatchEvent</code>
and a handler for that event throws. We should be resilient to most of
those cases. Even if our error event handler fires more than once, the
last error event is always used. If the callback actually does error,
we know that the last error event is the correct one, because it’s not
possible for anything else to have happened in between our callback
erroring and the code that follows the <code>dispatchEvent</code> call below. If
the callback doesn’t error, but the error event was fired, we know to
ignore it because <code>didError</code> will be false, as described above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-keyword">var</span> error; <span class="hljs-comment">// Use this to track whether the error event is ever called.</span>

        <span class="hljs-keyword">var</span> didSetError = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> isCrossOriginError = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleWindowError</span>(<span class="hljs-params">event</span>) {
          error = event.<span class="hljs-property">error</span>;
          didSetError = <span class="hljs-literal">true</span>;

          <span class="hljs-keyword">if</span> (error === <span class="hljs-literal">null</span> &amp;&amp; event.<span class="hljs-property">colno</span> === <span class="hljs-number">0</span> &amp;&amp; event.<span class="hljs-property">lineno</span> === <span class="hljs-number">0</span>) {
            isCrossOriginError = <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">if</span> (event.<span class="hljs-property">defaultPrevented</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-151">&#x00a7;</a>
              </div>
              <p>Some other error handler has prevented default.
Browsers silence the error report if this happens.
We’ll remember this to later decide whether to log it or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;object&#x27;</span>) {
              <span class="hljs-keyword">try</span> {
                error.<span class="hljs-property">_suppressLogging</span> = <span class="hljs-literal">true</span>;
              } <span class="hljs-keyword">catch</span> (inner) {<span class="hljs-comment">// Ignore.</span>
              }
            }
          }
        } <span class="hljs-comment">// Create a fake event type.</span>


        <span class="hljs-keyword">var</span> evtType = <span class="hljs-string">&quot;react-&quot;</span> + (name ? name : <span class="hljs-string">&#x27;invokeguardedcallback&#x27;</span>); <span class="hljs-comment">// Attach our event handlers</span>

        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, handleWindowError);
        fakeNode.<span class="hljs-title function_">addEventListener</span>(evtType, callCallback, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Synchronously dispatch our fake event. If the user-provided function</span></pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-152">&#x00a7;</a>
              </div>
              <p>errors, it will trigger our global error handler.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        evt.<span class="hljs-title function_">initEvent</span>(evtType, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
        fakeNode.<span class="hljs-title function_">dispatchEvent</span>(evt);

        <span class="hljs-keyword">if</span> (windowEventDescriptor) {
          <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-variable language_">window</span>, <span class="hljs-string">&#x27;event&#x27;</span>, windowEventDescriptor);
        }

        <span class="hljs-keyword">if</span> (didCall &amp;&amp; didError) {
          <span class="hljs-keyword">if</span> (!didSetError) {</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-153">&#x00a7;</a>
              </div>
              <p>The callback errored, but the error event never fired.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;An error was thrown inside one of your components, but React &#x27;</span> + <span class="hljs-string">&quot;doesn&#x27;t know what it was. This is likely due to browser &quot;</span> + <span class="hljs-string">&#x27;flakiness. React does its best to preserve the &quot;Pause on &#x27;</span> + <span class="hljs-string">&#x27;exceptions&quot; behavior of the DevTools, which requires some &#x27;</span> + <span class="hljs-string">&quot;DEV-mode only tricks. It&#x27;s possible that these don&#x27;t work in &quot;</span> + <span class="hljs-string">&#x27;your browser. Try triggering the error in production mode, &#x27;</span> + <span class="hljs-string">&#x27;or switching to a modern browser. If you suspect that this is &#x27;</span> + <span class="hljs-string">&#x27;actually an issue with React, please file an issue.&#x27;</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCrossOriginError) {
            error = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;A cross-origin error was thrown. React doesn&#x27;t have access to &quot;</span> + <span class="hljs-string">&#x27;the actual error object in development. &#x27;</span> + <span class="hljs-string">&#x27;See https://reactjs.org/link/crossorigin-error for more information.&#x27;</span>);
          }

          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">onError</span>(error);
        } <span class="hljs-comment">// Remove our event listeners</span>


        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, handleWindowError);

        <span class="hljs-keyword">if</span> (!didCall) {</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-154">&#x00a7;</a>
              </div>
              <p>Something went really wrong, and our event was not dispatched.
<a href="https://github.com/facebook/react/issues/16734">https://github.com/facebook/react/issues/16734</a>
<a href="https://github.com/facebook/react/issues/16585">https://github.com/facebook/react/issues/16585</a>
Fall back to the production implementation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">restoreAfterDispatch</span>();
          <span class="hljs-keyword">return</span> invokeGuardedCallbackProd.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
        }
      };
    }
  }

  <span class="hljs-keyword">var</span> invokeGuardedCallbackImpl$<span class="hljs-number">1</span> = invokeGuardedCallbackImpl;

  <span class="hljs-keyword">var</span> hasError = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> caughtError = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Used by event system to capture/rethrow the first error.</span>

  <span class="hljs-keyword">var</span> hasRethrowError = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> rethrowError = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> reporter = {
    <span class="hljs-attr">onError</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) {
      hasError = <span class="hljs-literal">true</span>;
      caughtError = error;
    }
  };
  <span class="hljs-comment">/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don&#x27;t
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} name of the guard to use for logging or debugging
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} func The function to invoke
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} context The context to use when calling the function
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">...*</span>} args Arguments for function
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) {
    hasError = <span class="hljs-literal">false</span>;
    caughtError = <span class="hljs-literal">null</span>;
    invokeGuardedCallbackImpl$<span class="hljs-number">1.</span><span class="hljs-title function_">apply</span>(reporter, <span class="hljs-variable language_">arguments</span>);
  }
  <span class="hljs-comment">/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * <span class="hljs-doctag">TODO:</span> See if caughtError and rethrowError can be unified.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">String</span>} name of the guard to use for logging or debugging
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">Function</span>} func The function to invoke
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">*</span>} context The context to use when calling the function
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">...*</span>} args Arguments for function
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokeGuardedCallbackAndCatchFirstError</span>(<span class="hljs-params">name, func, context, a, b, c, d, e, f</span>) {
    invokeGuardedCallback.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);

    <span class="hljs-keyword">if</span> (hasError) {
      <span class="hljs-keyword">var</span> error = <span class="hljs-title function_">clearCaughtError</span>();

      <span class="hljs-keyword">if</span> (!hasRethrowError) {
        hasRethrowError = <span class="hljs-literal">true</span>;
        rethrowError = error;
      }
    }
  }
  <span class="hljs-comment">/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rethrowCaughtError</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (hasRethrowError) {
      <span class="hljs-keyword">var</span> error = rethrowError;
      hasRethrowError = <span class="hljs-literal">false</span>;
      rethrowError = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">throw</span> error;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasCaughtError</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> hasError;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clearCaughtError</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (hasError) {
      <span class="hljs-keyword">var</span> error = caughtError;
      hasError = <span class="hljs-literal">false</span>;
      caughtError = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> error;
    } <span class="hljs-keyword">else</span> {
      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactInternals</span>$<span class="hljs-number">1</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>;
  <span class="hljs-keyword">var</span> _ReactInternals$Sched = <span class="hljs-title class_">ReactInternals</span>$<span class="hljs-number">1.</span><span class="hljs-title class_">Scheduler</span>,
    unstable_cancelCallback = _ReactInternals$Sched.<span class="hljs-property">unstable_cancelCallback</span>,
    unstable_now = _ReactInternals$Sched.<span class="hljs-property">unstable_now</span>,
    unstable_scheduleCallback = _ReactInternals$Sched.<span class="hljs-property">unstable_scheduleCallback</span>,
    unstable_shouldYield = _ReactInternals$Sched.<span class="hljs-property">unstable_shouldYield</span>,
    unstable_requestPaint = _ReactInternals$Sched.<span class="hljs-property">unstable_requestPaint</span>,
    unstable_getFirstCallbackNode = _ReactInternals$Sched.<span class="hljs-property">unstable_getFirstCallbackNode</span>,
    unstable_runWithPriority = _ReactInternals$Sched.<span class="hljs-property">unstable_runWithPriority</span>,
    unstable_next = _ReactInternals$Sched.<span class="hljs-property">unstable_next</span>,
    unstable_continueExecution = _ReactInternals$Sched.<span class="hljs-property">unstable_continueExecution</span>,
    unstable_pauseExecution = _ReactInternals$Sched.<span class="hljs-property">unstable_pauseExecution</span>,
    unstable_getCurrentPriorityLevel = _ReactInternals$Sched.<span class="hljs-property">unstable_getCurrentPriorityLevel</span>,
    unstable_ImmediatePriority = _ReactInternals$Sched.<span class="hljs-property">unstable_ImmediatePriority</span>,
    unstable_UserBlockingPriority = _ReactInternals$Sched.<span class="hljs-property">unstable_UserBlockingPriority</span>,
    unstable_NormalPriority = _ReactInternals$Sched.<span class="hljs-property">unstable_NormalPriority</span>,
    unstable_LowPriority = _ReactInternals$Sched.<span class="hljs-property">unstable_LowPriority</span>,
    unstable_IdlePriority = _ReactInternals$Sched.<span class="hljs-property">unstable_IdlePriority</span>,
    unstable_forceFrameRate = _ReactInternals$Sched.<span class="hljs-property">unstable_forceFrameRate</span>,
    unstable_flushAllWithoutAsserting = _ReactInternals$Sched.<span class="hljs-property">unstable_flushAllWithoutAsserting</span>;

  <span class="hljs-comment">/**
   * `ReactInstanceMap` maintains a mapping from a public facing stateful
   * instance (key) and the internal representation (value). This allows public
   * methods to accept the user facing instance as an argument and map them back
   * to internal methods.
   *
   * Note that this module is currently shared and assumed to be stateless.
   * If this becomes an actual Map, that will break.
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">return</span> key.<span class="hljs-property">_reactInternals</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">has</span>(<span class="hljs-params">key</span>) {
    <span class="hljs-keyword">return</span> key.<span class="hljs-property">_reactInternals</span> !== <span class="hljs-literal">undefined</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) {
    key.<span class="hljs-property">_reactInternals</span> = value;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-155">&#x00a7;</a>
              </div>
              <p>Don’t change these two values. They’re used by React Dev Tools.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoFlags</span> =
    <span class="hljs-comment">/*                      */</span>
    <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">PerformedWork</span> =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">1</span>; <span class="hljs-comment">// You can change the rest (and add more).</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Placement</span> =
    <span class="hljs-comment">/*                    */</span>
    <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Update</span> =
    <span class="hljs-comment">/*                       */</span>
    <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">PlacementAndUpdate</span> =
    <span class="hljs-comment">/*           */</span>
    <span class="hljs-number">6</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Deletion</span> =
    <span class="hljs-comment">/*                     */</span>
    <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ContentReset</span> =
    <span class="hljs-comment">/*                 */</span>
    <span class="hljs-number">16</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Callback</span> =
    <span class="hljs-comment">/*                     */</span>
    <span class="hljs-number">32</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DidCapture</span> =
    <span class="hljs-comment">/*                   */</span>
    <span class="hljs-number">64</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Ref</span> =
    <span class="hljs-comment">/*                          */</span>
    <span class="hljs-number">128</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Snapshot</span> =
    <span class="hljs-comment">/*                     */</span>
    <span class="hljs-number">256</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Passive</span> =
    <span class="hljs-comment">/*                      */</span>
    <span class="hljs-number">512</span>; <span class="hljs-comment">// TODO (effects) Remove this bit once the new reconciler is synced to the old.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">PassiveUnmountPendingDev</span> =
    <span class="hljs-comment">/*     */</span>
    <span class="hljs-number">8192</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Hydrating</span> =
    <span class="hljs-comment">/*                    */</span>
    <span class="hljs-number">1024</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HydratingAndUpdate</span> =
    <span class="hljs-comment">/*           */</span>
    <span class="hljs-number">1028</span>; <span class="hljs-comment">// Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LifecycleEffectMask</span> =
    <span class="hljs-comment">/*          */</span>
    <span class="hljs-number">932</span>; <span class="hljs-comment">// Union of all host effects</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HostEffectMask</span> =
    <span class="hljs-comment">/*               */</span>
    <span class="hljs-number">2047</span>; <span class="hljs-comment">// These are not really side effects, but we still reuse this field.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Incomplete</span> =
    <span class="hljs-comment">/*                   */</span>
    <span class="hljs-number">2048</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ShouldCapture</span> =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">4096</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ForceUpdateForLegacySuspense</span> =
    <span class="hljs-comment">/* */</span>
    <span class="hljs-number">16384</span>; <span class="hljs-comment">// Static tags describe aspects of a fiber that are not specific to a render,</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentOwner</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentOwner</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNearestMountedFiber</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> node = fiber;
    <span class="hljs-keyword">var</span> nearestMounted = fiber;

    <span class="hljs-keyword">if</span> (!fiber.<span class="hljs-property">alternate</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-156">&#x00a7;</a>
              </div>
              <p>If there is no alternate, this might be a new tree that isn’t inserted
yet. If it is, then it will have a pending insertion effect on it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> nextNode = node;

      <span class="hljs-keyword">do</span> {
        node = nextNode;

        <span class="hljs-keyword">if</span> ((node.<span class="hljs-property">flags</span> &amp; (<span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">Hydrating</span>)) !== <span class="hljs-title class_">NoFlags</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-157">&#x00a7;</a>
              </div>
              <p>This is an insertion or in-progress hydration. The nearest possible
mounted fiber is the parent but we need to continue to figure out
if that one is still mounted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          nearestMounted = node.<span class="hljs-property">return</span>;
        }

        nextNode = node.<span class="hljs-property">return</span>;
      } <span class="hljs-keyword">while</span> (nextNode);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">while</span> (node.<span class="hljs-property">return</span>) {
        node = node.<span class="hljs-property">return</span>;
      }
    }

    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-158">&#x00a7;</a>
              </div>
              <p>TODO: Check if this was a nested HostRoot when used with
renderContainerIntoSubtree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> nearestMounted;
    } <span class="hljs-comment">// If we didn&#x27;t hit the root, that means that we&#x27;re in an disconnected tree</span></pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-159">&#x00a7;</a>
              </div>
              <p>that has been unmounted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSuspenseInstanceFromFiber</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span>) {
      <span class="hljs-keyword">var</span> suspenseState = fiber.<span class="hljs-property">memoizedState</span>;

      <span class="hljs-keyword">if</span> (suspenseState === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> current = fiber.<span class="hljs-property">alternate</span>;

        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
          suspenseState = current.<span class="hljs-property">memoizedState</span>;
        }
      }

      <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> suspenseState.<span class="hljs-property">dehydrated</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getContainerFromFiber</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">return</span> fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span> ? fiber.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span> : <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isFiberMounted</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getNearestMountedFiber</span>(fiber) === fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isMounted</span>(<span class="hljs-params">component</span>) {
    {
      <span class="hljs-keyword">var</span> owner = <span class="hljs-title class_">ReactCurrentOwner</span>.<span class="hljs-property">current</span>;

      <span class="hljs-keyword">if</span> (owner !== <span class="hljs-literal">null</span> &amp;&amp; owner.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) {
        <span class="hljs-keyword">var</span> ownerFiber = owner;
        <span class="hljs-keyword">var</span> instance = ownerFiber.<span class="hljs-property">stateNode</span>;

        <span class="hljs-keyword">if</span> (!instance.<span class="hljs-property">_warnedAboutRefsInRender</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s is accessing isMounted inside its render() function. &#x27;</span> + <span class="hljs-string">&#x27;render() should be a pure function of props and state. It should &#x27;</span> + <span class="hljs-string">&#x27;never access something that requires stale data from the previous &#x27;</span> + <span class="hljs-string">&#x27;render, such as refs. Move this logic to componentDidMount and &#x27;</span> + <span class="hljs-string">&#x27;componentDidUpdate instead.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(ownerFiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;A component&#x27;</span>);
        }

        instance.<span class="hljs-property">_warnedAboutRefsInRender</span> = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">get</span>(component);

    <span class="hljs-keyword">if</span> (!fiber) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getNearestMountedFiber</span>(fiber) === fiber;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">assertIsMounted</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">if</span> (!(<span class="hljs-title function_">getNearestMountedFiber</span>(fiber) === fiber)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unable to find node on an unmounted component.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findCurrentFiberUsingSlowPath</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (!alternate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-160">&#x00a7;</a>
              </div>
              <p>If there is no alternate, then we only need to check if it is mounted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> nearestMounted = <span class="hljs-title function_">getNearestMountedFiber</span>(fiber);

      <span class="hljs-keyword">if</span> (!(nearestMounted !== <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unable to find node on an unmounted component.&quot;</span>);
        }
      }

      <span class="hljs-keyword">if</span> (nearestMounted !== fiber) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> fiber;
    } <span class="hljs-comment">// If we have two possible branches, we&#x27;ll walk backwards up to the root</span></pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-161">&#x00a7;</a>
              </div>
              <p>to see what path the root points to. On the way we may hit one of the
special cases and we’ll deal with them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> a = fiber;
    <span class="hljs-keyword">var</span> b = alternate;

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">var</span> parentA = a.<span class="hljs-property">return</span>;

      <span class="hljs-keyword">if</span> (parentA === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-162">&#x00a7;</a>
              </div>
              <p>We’re at the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">var</span> parentB = parentA.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (parentB === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-163">&#x00a7;</a>
              </div>
              <p>There is no alternate. This is an unusual case. Currently, it only
happens when a Suspense component is hidden. An extra fragment fiber
is inserted in between the Suspense fiber and its children. Skip
over this extra fragment fiber and proceed to the next parent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> nextParent = parentA.<span class="hljs-property">return</span>;

        <span class="hljs-keyword">if</span> (nextParent !== <span class="hljs-literal">null</span>) {
          a = b = nextParent;
          <span class="hljs-keyword">continue</span>;
        } <span class="hljs-comment">// If there&#x27;s no parent, we&#x27;re at the root.</span>


        <span class="hljs-keyword">break</span>;
      } <span class="hljs-comment">// If both copies of the parent fiber point to the same child, we can</span></pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-164">&#x00a7;</a>
              </div>
              <p>assume that the child is current. This happens when we bailout on low
priority: the bailed out fiber’s child reuses the current child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (parentA.<span class="hljs-property">child</span> === parentB.<span class="hljs-property">child</span>) {
        <span class="hljs-keyword">var</span> child = parentA.<span class="hljs-property">child</span>;

        <span class="hljs-keyword">while</span> (child) {
          <span class="hljs-keyword">if</span> (child === a) {</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-165">&#x00a7;</a>
              </div>
              <p>We’ve determined that A is the current branch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title function_">assertIsMounted</span>(parentA);
            <span class="hljs-keyword">return</span> fiber;
          }

          <span class="hljs-keyword">if</span> (child === b) {</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-166">&#x00a7;</a>
              </div>
              <p>We’ve determined that B is the current branch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title function_">assertIsMounted</span>(parentA);
            <span class="hljs-keyword">return</span> alternate;
          }

          child = child.<span class="hljs-property">sibling</span>;
        } <span class="hljs-comment">// We should never have an alternate for any mounting node. So the only</span></pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-167">&#x00a7;</a>
              </div>
              <p>way this could possibly happen is if this was unmounted, if at all.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unable to find node on an unmounted component.&quot;</span>);
          }
        }
      }

      <span class="hljs-keyword">if</span> (a.<span class="hljs-property">return</span> !== b.<span class="hljs-property">return</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-168">&#x00a7;</a>
              </div>
              <p>The return pointer of A and the return pointer of B point to different
fibers. We assume that return pointers never criss-cross, so A must
belong to the child set of A.return, and B must belong to the child
set of B.return.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        a = parentA;
        b = parentB;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-169">&#x00a7;</a>
              </div>
              <p>The return pointers point to the same fiber. We’ll have to use the
default, slow path: scan the child sets of each parent alternate to see
which child belongs to which set.</p>
<p>Search parent A’s child set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> didFindChild = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">var</span> _child = parentA.<span class="hljs-property">child</span>;

        <span class="hljs-keyword">while</span> (_child) {
          <span class="hljs-keyword">if</span> (_child === a) {
            didFindChild = <span class="hljs-literal">true</span>;
            a = parentA;
            b = parentB;
            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">if</span> (_child === b) {
            didFindChild = <span class="hljs-literal">true</span>;
            b = parentA;
            a = parentB;
            <span class="hljs-keyword">break</span>;
          }

          _child = _child.<span class="hljs-property">sibling</span>;
        }

        <span class="hljs-keyword">if</span> (!didFindChild) {</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-170">&#x00a7;</a>
              </div>
              <p>Search parent B’s child set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          _child = parentB.<span class="hljs-property">child</span>;

          <span class="hljs-keyword">while</span> (_child) {
            <span class="hljs-keyword">if</span> (_child === a) {
              didFindChild = <span class="hljs-literal">true</span>;
              a = parentB;
              b = parentA;
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">if</span> (_child === b) {
              didFindChild = <span class="hljs-literal">true</span>;
              b = parentB;
              a = parentA;
              <span class="hljs-keyword">break</span>;
            }

            _child = _child.<span class="hljs-property">sibling</span>;
          }

          <span class="hljs-keyword">if</span> (!didFindChild) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.&quot;</span>);
            }
          }
        }
      }

      <span class="hljs-keyword">if</span> (!(a.<span class="hljs-property">alternate</span> === b)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Return fibers should always be each others&#x27; alternates. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }
    } <span class="hljs-comment">// If the root is not a host container, we&#x27;re in a disconnected tree. I.e.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-171">&#x00a7;</a>
              </div>
              <p>unmounted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (!(a.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unable to find node on an unmounted component.&quot;</span>);
      }
    }

    <span class="hljs-keyword">if</span> (a.<span class="hljs-property">stateNode</span>.<span class="hljs-property">current</span> === a) {</pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-172">&#x00a7;</a>
              </div>
              <p>We’ve determined that A is the current branch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> fiber;
    } <span class="hljs-comment">// Otherwise B has to be current branch.</span>


    <span class="hljs-keyword">return</span> alternate;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findCurrentHostFiber</span>(<span class="hljs-params">parent</span>) {
    <span class="hljs-keyword">var</span> currentParent = <span class="hljs-title function_">findCurrentFiberUsingSlowPath</span>(parent);

    <span class="hljs-keyword">if</span> (!currentParent) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// Next we&#x27;ll drill down this component to find the first HostComponent/Text.</span>


    <span class="hljs-keyword">var</span> node = currentParent;

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span> || node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span>) {
        <span class="hljs-keyword">return</span> node;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span>) {
        node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
        node = node.<span class="hljs-property">child</span>;
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (node === currentParent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">while</span> (!node.<span class="hljs-property">sibling</span>) {
        <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">return</span> || node.<span class="hljs-property">return</span> === currentParent) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        node = node.<span class="hljs-property">return</span>;
      }

      node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
      node = node.<span class="hljs-property">sibling</span>;
    } <span class="hljs-comment">// Flow needs the return null here, but ESLint complains about it.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-173">&#x00a7;</a>
              </div>
              <p>eslint-disable-next-line no-unreachable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findCurrentHostFiberWithNoPortals</span>(<span class="hljs-params">parent</span>) {
    <span class="hljs-keyword">var</span> currentParent = <span class="hljs-title function_">findCurrentFiberUsingSlowPath</span>(parent);

    <span class="hljs-keyword">if</span> (!currentParent) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// Next we&#x27;ll drill down this component to find the first HostComponent/Text.</span>


    <span class="hljs-keyword">var</span> node = currentParent;

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span> || node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span> || enableFundamentalAPI) {
        <span class="hljs-keyword">return</span> node;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> &amp;&amp; node.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostPortal</span>) {
        node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
        node = node.<span class="hljs-property">child</span>;
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (node === currentParent) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">while</span> (!node.<span class="hljs-property">sibling</span>) {
        <span class="hljs-keyword">if</span> (!node.<span class="hljs-property">return</span> || node.<span class="hljs-property">return</span> === currentParent) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        node = node.<span class="hljs-property">return</span>;
      }

      node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
      node = node.<span class="hljs-property">sibling</span>;
    } <span class="hljs-comment">// Flow needs the return null here, but ESLint complains about it.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-174">&#x00a7;</a>
              </div>
              <p>eslint-disable-next-line no-unreachable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">doesFiberContain</span>(<span class="hljs-params">parentFiber, childFiber</span>) {
    <span class="hljs-keyword">var</span> node = childFiber;
    <span class="hljs-keyword">var</span> parentFiberAlternate = parentFiber.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (node === parentFiber || node === parentFiberAlternate) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      node = node.<span class="hljs-property">return</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">var</span> attemptSynchronousHydration;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setAttemptSynchronousHydration</span>(<span class="hljs-params">fn</span>) {
    attemptSynchronousHydration = fn;
  }
  <span class="hljs-keyword">var</span> attemptUserBlockingHydration;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setAttemptUserBlockingHydration</span>(<span class="hljs-params">fn</span>) {
    attemptUserBlockingHydration = fn;
  }
  <span class="hljs-keyword">var</span> attemptContinuousHydration;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setAttemptContinuousHydration</span>(<span class="hljs-params">fn</span>) {
    attemptContinuousHydration = fn;
  }
  <span class="hljs-keyword">var</span> attemptHydrationAtCurrentPriority;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setAttemptHydrationAtCurrentPriority</span>(<span class="hljs-params">fn</span>) {
    attemptHydrationAtCurrentPriority = fn;
  }
  <span class="hljs-keyword">var</span> getCurrentUpdatePriority;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setGetCurrentUpdatePriority</span>(<span class="hljs-params">fn</span>) {
    getCurrentUpdatePriority = fn;
  }
  <span class="hljs-keyword">var</span> attemptHydrationAtPriority;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setAttemptHydrationAtPriority</span>(<span class="hljs-params">fn</span>) {
    attemptHydrationAtPriority = fn;
  } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Upgrade this definition once we&#x27;re on a newer version of Flow that</span>
  <span class="hljs-keyword">var</span> hasScheduledReplayAttempt = <span class="hljs-literal">false</span>; <span class="hljs-comment">// The queue of discrete events to be replayed.</span>

  <span class="hljs-keyword">var</span> queuedDiscreteEvents = []; <span class="hljs-comment">// Indicates if any continuous event targets are non-null for early bailout.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-175">&#x00a7;</a>
              </div>
              <p>if the last target was dehydrated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> queuedFocus = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> queuedDrag = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> queuedMouse = <span class="hljs-literal">null</span>; <span class="hljs-comment">// For pointer events there can be one latest event per pointerId.</span>

  <span class="hljs-keyword">var</span> queuedPointers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">var</span> queuedPointerCaptures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// We could consider replaying selectionchange and touchmoves too.</span>

  <span class="hljs-keyword">var</span> queuedExplicitHydrationTargets = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasQueuedDiscreteEvents</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> queuedDiscreteEvents.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">var</span> discreteReplayableEvents = [<span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-string">&#x27;touchcancel&#x27;</span>, <span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-string">&#x27;auxclick&#x27;</span>, <span class="hljs-string">&#x27;dblclick&#x27;</span>, <span class="hljs-string">&#x27;pointercancel&#x27;</span>, <span class="hljs-string">&#x27;pointerdown&#x27;</span>, <span class="hljs-string">&#x27;pointerup&#x27;</span>, <span class="hljs-string">&#x27;dragend&#x27;</span>, <span class="hljs-string">&#x27;dragstart&#x27;</span>, <span class="hljs-string">&#x27;drop&#x27;</span>, <span class="hljs-string">&#x27;compositionend&#x27;</span>, <span class="hljs-string">&#x27;compositionstart&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;textInput&#x27;</span>, <span class="hljs-comment">// Intentionally camelCase</span>
    <span class="hljs-string">&#x27;copy&#x27;</span>, <span class="hljs-string">&#x27;cut&#x27;</span>, <span class="hljs-string">&#x27;paste&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-string">&#x27;reset&#x27;</span>, <span class="hljs-string">&#x27;submit&#x27;</span>];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isReplayableDiscreteEvent</span>(<span class="hljs-params">eventType</span>) {
    <span class="hljs-keyword">return</span> discreteReplayableEvents.<span class="hljs-title function_">indexOf</span>(eventType) &gt; -<span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createQueuedReplayableEvent</span>(<span class="hljs-params">blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">blockedOn</span>: blockedOn,
      <span class="hljs-attr">domEventName</span>: domEventName,
      <span class="hljs-attr">eventSystemFlags</span>: eventSystemFlags | <span class="hljs-variable constant_">IS_REPLAYED</span>,
      <span class="hljs-attr">nativeEvent</span>: nativeEvent,
      <span class="hljs-attr">targetContainers</span>: [targetContainer]
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">queueDiscreteEvent</span>(<span class="hljs-params">blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) {
    <span class="hljs-keyword">var</span> queuedEvent = <span class="hljs-title function_">createQueuedReplayableEvent</span>(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
    queuedDiscreteEvents.<span class="hljs-title function_">push</span>(queuedEvent);

    {
      <span class="hljs-keyword">if</span> (queuedDiscreteEvents.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-176">&#x00a7;</a>
              </div>
              <p>If this was the first discrete event, we might be able to
synchronously unblock it so that preventDefault still works.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">while</span> (queuedEvent.<span class="hljs-property">blockedOn</span> !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> _fiber = <span class="hljs-title function_">getInstanceFromNode</span>(queuedEvent.<span class="hljs-property">blockedOn</span>);

          <span class="hljs-keyword">if</span> (_fiber === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-title function_">attemptSynchronousHydration</span>(_fiber);

          <span class="hljs-keyword">if</span> (queuedEvent.<span class="hljs-property">blockedOn</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-177">&#x00a7;</a>
              </div>
              <p>We got unblocked by hydration. Let’s try again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title function_">replayUnblockedEvents</span>(); <span class="hljs-comment">// If we&#x27;re reblocked, on an inner boundary, we might need</span></pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-178">&#x00a7;</a>
              </div>
              <p>to attempt hydrating that one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">continue</span>;
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-179">&#x00a7;</a>
              </div>
              <p>We’re still blocked from hydration, we have to give up
and replay later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">break</span>;
          }
        }
      }
    }
  } <span class="hljs-comment">// Resets the replaying for this type of continuous event to no event.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clearIfContinuousEvent</span>(<span class="hljs-params">domEventName, nativeEvent</span>) {
    <span class="hljs-keyword">switch</span> (domEventName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusin&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusout&#x27;</span>:
        queuedFocus = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragenter&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragleave&#x27;</span>:
        queuedDrag = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseover&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseout&#x27;</span>:
        queuedMouse = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointerover&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointerout&#x27;</span>:
        {
          <span class="hljs-keyword">var</span> pointerId = nativeEvent.<span class="hljs-property">pointerId</span>;
          queuedPointers.<span class="hljs-title function_">delete</span>(pointerId);
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;gotpointercapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;lostpointercapture&#x27;</span>:
        {
          <span class="hljs-keyword">var</span> _pointerId = nativeEvent.<span class="hljs-property">pointerId</span>;
          queuedPointerCaptures.<span class="hljs-title function_">delete</span>(_pointerId);
          <span class="hljs-keyword">break</span>;
        }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateOrCreateContinuousQueuedReplayableEvent</span>(<span class="hljs-params">existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) {
    <span class="hljs-keyword">if</span> (existingQueuedEvent === <span class="hljs-literal">null</span> || existingQueuedEvent.<span class="hljs-property">nativeEvent</span> !== nativeEvent) {
      <span class="hljs-keyword">var</span> queuedEvent = <span class="hljs-title function_">createQueuedReplayableEvent</span>(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);

      <span class="hljs-keyword">if</span> (blockedOn !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> _fiber2 = <span class="hljs-title function_">getInstanceFromNode</span>(blockedOn);

        <span class="hljs-keyword">if</span> (_fiber2 !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-180">&#x00a7;</a>
              </div>
              <p>Attempt to increase the priority of this target.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">attemptContinuousHydration</span>(_fiber2);
        }
      }

      <span class="hljs-keyword">return</span> queuedEvent;
    } <span class="hljs-comment">// If we have already queued this exact event, then it&#x27;s because</span></pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-181">&#x00a7;</a>
              </div>
              <p>the different event systems have different DOM event listeners.
We can accumulate the flags, and the targetContainers, and
store a single event to be replayed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    existingQueuedEvent.<span class="hljs-property">eventSystemFlags</span> |= eventSystemFlags;
    <span class="hljs-keyword">var</span> targetContainers = existingQueuedEvent.<span class="hljs-property">targetContainers</span>;

    <span class="hljs-keyword">if</span> (targetContainer !== <span class="hljs-literal">null</span> &amp;&amp; targetContainers.<span class="hljs-title function_">indexOf</span>(targetContainer) === -<span class="hljs-number">1</span>) {
      targetContainers.<span class="hljs-title function_">push</span>(targetContainer);
    }

    <span class="hljs-keyword">return</span> existingQueuedEvent;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">queueIfContinuousEvent</span>(<span class="hljs-params">blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-182">&#x00a7;</a>
              </div>
              <p>These set relatedTarget to null because the replayed event will be treated as if we
moved from outside the window (no target) onto the target once it hydrates.
Instead of mutating we could clone the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">switch</span> (domEventName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusin&#x27;</span>:
        {
          <span class="hljs-keyword">var</span> focusEvent = nativeEvent;
          queuedFocus = <span class="hljs-title function_">accumulateOrCreateContinuousQueuedReplayableEvent</span>(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragenter&#x27;</span>:
        {
          <span class="hljs-keyword">var</span> dragEvent = nativeEvent;
          queuedDrag = <span class="hljs-title function_">accumulateOrCreateContinuousQueuedReplayableEvent</span>(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseover&#x27;</span>:
        {
          <span class="hljs-keyword">var</span> mouseEvent = nativeEvent;
          queuedMouse = <span class="hljs-title function_">accumulateOrCreateContinuousQueuedReplayableEvent</span>(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointerover&#x27;</span>:
        {
          <span class="hljs-keyword">var</span> pointerEvent = nativeEvent;
          <span class="hljs-keyword">var</span> pointerId = pointerEvent.<span class="hljs-property">pointerId</span>;
          queuedPointers.<span class="hljs-title function_">set</span>(pointerId, <span class="hljs-title function_">accumulateOrCreateContinuousQueuedReplayableEvent</span>(queuedPointers.<span class="hljs-title function_">get</span>(pointerId) || <span class="hljs-literal">null</span>, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;gotpointercapture&#x27;</span>:
        {
          <span class="hljs-keyword">var</span> _pointerEvent = nativeEvent;
          <span class="hljs-keyword">var</span> _pointerId2 = _pointerEvent.<span class="hljs-property">pointerId</span>;
          queuedPointerCaptures.<span class="hljs-title function_">set</span>(_pointerId2, <span class="hljs-title function_">accumulateOrCreateContinuousQueuedReplayableEvent</span>(queuedPointerCaptures.<span class="hljs-title function_">get</span>(_pointerId2) || <span class="hljs-literal">null</span>, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  } <span class="hljs-comment">// Check if this target is unblocked. Returns true if it&#x27;s unblocked.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptExplicitHydrationTarget</span>(<span class="hljs-params">queuedTarget</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-183">&#x00a7;</a>
              </div>
              <p>TODO: This function shares a lot of logic with attemptToDispatchEvent.
Try to unify them. It’s a bit tricky since it would require two return
values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> targetInst = <span class="hljs-title function_">getClosestInstanceFromNode</span>(queuedTarget.<span class="hljs-property">target</span>);

    <span class="hljs-keyword">if</span> (targetInst !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> nearestMounted = <span class="hljs-title function_">getNearestMountedFiber</span>(targetInst);

      <span class="hljs-keyword">if</span> (nearestMounted !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> tag = nearestMounted.<span class="hljs-property">tag</span>;

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">SuspenseComponent</span>) {
          <span class="hljs-keyword">var</span> instance = <span class="hljs-title function_">getSuspenseInstanceFromFiber</span>(nearestMounted);

          <span class="hljs-keyword">if</span> (instance !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-184">&#x00a7;</a>
              </div>
              <p>We’re blocked on hydrating this boundary.
Increase its priority.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            queuedTarget.<span class="hljs-property">blockedOn</span> = instance;
            <span class="hljs-title function_">attemptHydrationAtPriority</span>(queuedTarget.<span class="hljs-property">lanePriority</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
              <span class="hljs-title function_">unstable_runWithPriority</span>(queuedTarget.<span class="hljs-property">priority</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                <span class="hljs-title function_">attemptHydrationAtCurrentPriority</span>(nearestMounted);
              });
            });
            <span class="hljs-keyword">return</span>;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostRoot</span>) {
          <span class="hljs-keyword">var</span> root = nearestMounted.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (root.<span class="hljs-property">hydrate</span>) {
            queuedTarget.<span class="hljs-property">blockedOn</span> = <span class="hljs-title function_">getContainerFromFiber</span>(nearestMounted); <span class="hljs-comment">// We don&#x27;t currently have a way to increase the priority of</span></pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-185">&#x00a7;</a>
              </div>
              <p>a root other than sync.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">return</span>;
          }
        }
      }
    }

    queuedTarget.<span class="hljs-property">blockedOn</span> = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">queueExplicitHydrationTarget</span>(<span class="hljs-params">target</span>) {
    {
      <span class="hljs-keyword">var</span> schedulerPriority = <span class="hljs-title function_">unstable_getCurrentPriorityLevel</span>();
      <span class="hljs-keyword">var</span> updateLanePriority = <span class="hljs-title function_">getCurrentUpdatePriority</span>();
      <span class="hljs-keyword">var</span> queuedTarget = {
        <span class="hljs-attr">blockedOn</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">target</span>: target,
        <span class="hljs-attr">priority</span>: schedulerPriority,
        <span class="hljs-attr">lanePriority</span>: updateLanePriority
      };
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">for</span> (; i &lt; queuedExplicitHydrationTargets.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">if</span> (schedulerPriority &lt;= queuedExplicitHydrationTargets[i].<span class="hljs-property">priority</span>) {
          <span class="hljs-keyword">break</span>;
        }
      }

      queuedExplicitHydrationTargets.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">0</span>, queuedTarget);

      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) {
        <span class="hljs-title function_">attemptExplicitHydrationTarget</span>(queuedTarget);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptReplayContinuousQueuedEvent</span>(<span class="hljs-params">queuedEvent</span>) {
    <span class="hljs-keyword">if</span> (queuedEvent.<span class="hljs-property">blockedOn</span> !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> targetContainers = queuedEvent.<span class="hljs-property">targetContainers</span>;

    <span class="hljs-keyword">while</span> (targetContainers.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> targetContainer = targetContainers[<span class="hljs-number">0</span>];
      <span class="hljs-keyword">var</span> nextBlockedOn = <span class="hljs-title function_">attemptToDispatchEvent</span>(queuedEvent.<span class="hljs-property">domEventName</span>, queuedEvent.<span class="hljs-property">eventSystemFlags</span>, targetContainer, queuedEvent.<span class="hljs-property">nativeEvent</span>);

      <span class="hljs-keyword">if</span> (nextBlockedOn !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-186">&#x00a7;</a>
              </div>
              <p>We’re still blocked. Try again later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> _fiber3 = <span class="hljs-title function_">getInstanceFromNode</span>(nextBlockedOn);

        <span class="hljs-keyword">if</span> (_fiber3 !== <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">attemptContinuousHydration</span>(_fiber3);
        }

        queuedEvent.<span class="hljs-property">blockedOn</span> = nextBlockedOn;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-comment">// This target container was successfully dispatched. Try the next.</span>


      targetContainers.<span class="hljs-title function_">shift</span>();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptReplayContinuousQueuedEventInMap</span>(<span class="hljs-params">queuedEvent, key, map</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">attemptReplayContinuousQueuedEvent</span>(queuedEvent)) {
      map.<span class="hljs-title function_">delete</span>(key);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">replayUnblockedEvents</span>(<span class="hljs-params"></span>) {
    hasScheduledReplayAttempt = <span class="hljs-literal">false</span>; <span class="hljs-comment">// First replay discrete events.</span>

    <span class="hljs-keyword">while</span> (queuedDiscreteEvents.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> nextDiscreteEvent = queuedDiscreteEvents[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">if</span> (nextDiscreteEvent.<span class="hljs-property">blockedOn</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-187">&#x00a7;</a>
              </div>
              <p>We’re still blocked.
Increase the priority of this boundary to unblock
the next discrete event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> _fiber4 = <span class="hljs-title function_">getInstanceFromNode</span>(nextDiscreteEvent.<span class="hljs-property">blockedOn</span>);

        <span class="hljs-keyword">if</span> (_fiber4 !== <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">attemptUserBlockingHydration</span>(_fiber4);
        }

        <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">var</span> targetContainers = nextDiscreteEvent.<span class="hljs-property">targetContainers</span>;

      <span class="hljs-keyword">while</span> (targetContainers.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> targetContainer = targetContainers[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> nextBlockedOn = <span class="hljs-title function_">attemptToDispatchEvent</span>(nextDiscreteEvent.<span class="hljs-property">domEventName</span>, nextDiscreteEvent.<span class="hljs-property">eventSystemFlags</span>, targetContainer, nextDiscreteEvent.<span class="hljs-property">nativeEvent</span>);

        <span class="hljs-keyword">if</span> (nextBlockedOn !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-188">&#x00a7;</a>
              </div>
              <p>We’re still blocked. Try again later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          nextDiscreteEvent.<span class="hljs-property">blockedOn</span> = nextBlockedOn;
          <span class="hljs-keyword">break</span>;
        } <span class="hljs-comment">// This target container was successfully dispatched. Try the next.</span>


        targetContainers.<span class="hljs-title function_">shift</span>();
      }

      <span class="hljs-keyword">if</span> (nextDiscreteEvent.<span class="hljs-property">blockedOn</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-189">&#x00a7;</a>
              </div>
              <p>We’ve successfully replayed the first event. Let’s try the next one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        queuedDiscreteEvents.<span class="hljs-title function_">shift</span>();
      }
    } <span class="hljs-comment">// Next replay any continuous events.</span>


    <span class="hljs-keyword">if</span> (queuedFocus !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">attemptReplayContinuousQueuedEvent</span>(queuedFocus)) {
      queuedFocus = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (queuedDrag !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">attemptReplayContinuousQueuedEvent</span>(queuedDrag)) {
      queuedDrag = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (queuedMouse !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">attemptReplayContinuousQueuedEvent</span>(queuedMouse)) {
      queuedMouse = <span class="hljs-literal">null</span>;
    }

    queuedPointers.<span class="hljs-title function_">forEach</span>(attemptReplayContinuousQueuedEventInMap);
    queuedPointerCaptures.<span class="hljs-title function_">forEach</span>(attemptReplayContinuousQueuedEventInMap);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleCallbackIfUnblocked</span>(<span class="hljs-params">queuedEvent, unblocked</span>) {
    <span class="hljs-keyword">if</span> (queuedEvent.<span class="hljs-property">blockedOn</span> === unblocked) {
      queuedEvent.<span class="hljs-property">blockedOn</span> = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (!hasScheduledReplayAttempt) {
        hasScheduledReplayAttempt = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Schedule a callback to attempt replaying as many events as are</span></pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-190">&#x00a7;</a>
              </div>
              <p>now unblocked. This first might not actually be unblocked yet.
We could check it early to avoid scheduling an unnecessary callback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">unstable_scheduleCallback</span>(unstable_NormalPriority, replayUnblockedEvents);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">retryIfBlockedOn</span>(<span class="hljs-params">unblocked</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-191">&#x00a7;</a>
              </div>
              <p>Mark anything that was blocked on this as no longer blocked
and eligible for a replay.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (queuedDiscreteEvents.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-title function_">scheduleCallbackIfUnblocked</span>(queuedDiscreteEvents[<span class="hljs-number">0</span>], unblocked); <span class="hljs-comment">// This is a exponential search for each boundary that commits. I think it&#x27;s</span></pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-192">&#x00a7;</a>
              </div>
              <p>worth it because we expect very few discrete events to queue up and once
we are actually fully unblocked it will be fast to replay them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; queuedDiscreteEvents.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">var</span> queuedEvent = queuedDiscreteEvents[i];

        <span class="hljs-keyword">if</span> (queuedEvent.<span class="hljs-property">blockedOn</span> === unblocked) {
          queuedEvent.<span class="hljs-property">blockedOn</span> = <span class="hljs-literal">null</span>;
        }
      }
    }

    <span class="hljs-keyword">if</span> (queuedFocus !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">scheduleCallbackIfUnblocked</span>(queuedFocus, unblocked);
    }

    <span class="hljs-keyword">if</span> (queuedDrag !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">scheduleCallbackIfUnblocked</span>(queuedDrag, unblocked);
    }

    <span class="hljs-keyword">if</span> (queuedMouse !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">scheduleCallbackIfUnblocked</span>(queuedMouse, unblocked);
    }

    <span class="hljs-keyword">var</span> unblock = <span class="hljs-keyword">function</span> (<span class="hljs-params">queuedEvent</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">scheduleCallbackIfUnblocked</span>(queuedEvent, unblocked);
    };

    queuedPointers.<span class="hljs-title function_">forEach</span>(unblock);
    queuedPointerCaptures.<span class="hljs-title function_">forEach</span>(unblock);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; queuedExplicitHydrationTargets.<span class="hljs-property">length</span>; _i++) {
      <span class="hljs-keyword">var</span> queuedTarget = queuedExplicitHydrationTargets[_i];

      <span class="hljs-keyword">if</span> (queuedTarget.<span class="hljs-property">blockedOn</span> === unblocked) {
        queuedTarget.<span class="hljs-property">blockedOn</span> = <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-keyword">while</span> (queuedExplicitHydrationTargets.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> nextExplicitTarget = queuedExplicitHydrationTargets[<span class="hljs-number">0</span>];

      <span class="hljs-keyword">if</span> (nextExplicitTarget.<span class="hljs-property">blockedOn</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-193">&#x00a7;</a>
              </div>
              <p>We’re still blocked.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">break</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">attemptExplicitHydrationTarget</span>(nextExplicitTarget);

        <span class="hljs-keyword">if</span> (nextExplicitTarget.<span class="hljs-property">blockedOn</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-194">&#x00a7;</a>
              </div>
              <p>We’re unblocked.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          queuedExplicitHydrationTargets.<span class="hljs-title function_">shift</span>();
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DiscreteEvent</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">UserBlockingEvent</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ContinuousEvent</span> = <span class="hljs-number">2</span>;

  <span class="hljs-comment">/**
   * Generate a mapping of standard vendor prefixes using the defined style property and event name.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">styleProp</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">object</span>}
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">makePrefixMap</span>(<span class="hljs-params">styleProp, eventName</span>) {
    <span class="hljs-keyword">var</span> prefixes = {};
    prefixes[styleProp.<span class="hljs-title function_">toLowerCase</span>()] = eventName.<span class="hljs-title function_">toLowerCase</span>();
    prefixes[<span class="hljs-string">&#x27;Webkit&#x27;</span> + styleProp] = <span class="hljs-string">&#x27;webkit&#x27;</span> + eventName;
    prefixes[<span class="hljs-string">&#x27;Moz&#x27;</span> + styleProp] = <span class="hljs-string">&#x27;moz&#x27;</span> + eventName;
    <span class="hljs-keyword">return</span> prefixes;
  }
  <span class="hljs-comment">/**
   * A list of event names to a configurable list of vendor prefixes.
   */</span>


  <span class="hljs-keyword">var</span> vendorPrefixes = {
    <span class="hljs-attr">animationend</span>: <span class="hljs-title function_">makePrefixMap</span>(<span class="hljs-string">&#x27;Animation&#x27;</span>, <span class="hljs-string">&#x27;AnimationEnd&#x27;</span>),
    <span class="hljs-attr">animationiteration</span>: <span class="hljs-title function_">makePrefixMap</span>(<span class="hljs-string">&#x27;Animation&#x27;</span>, <span class="hljs-string">&#x27;AnimationIteration&#x27;</span>),
    <span class="hljs-attr">animationstart</span>: <span class="hljs-title function_">makePrefixMap</span>(<span class="hljs-string">&#x27;Animation&#x27;</span>, <span class="hljs-string">&#x27;AnimationStart&#x27;</span>),
    <span class="hljs-attr">transitionend</span>: <span class="hljs-title function_">makePrefixMap</span>(<span class="hljs-string">&#x27;Transition&#x27;</span>, <span class="hljs-string">&#x27;TransitionEnd&#x27;</span>)
  };
  <span class="hljs-comment">/**
   * Event names that have already been detected and prefixed (if applicable).
   */</span>

  <span class="hljs-keyword">var</span> prefixedEventNames = {};
  <span class="hljs-comment">/**
   * Element to check for prefixes on.
   */</span>

  <span class="hljs-keyword">var</span> style = {};
  <span class="hljs-comment">/**
   * Bootstrap if a DOM exists.
   */</span>

  <span class="hljs-keyword">if</span> (canUseDOM) {
    style = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>).<span class="hljs-property">style</span>; <span class="hljs-comment">// On some platforms, in particular some releases of Android 4.x,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-195">&#x00a7;</a>
              </div>
              <p>the un-prefixed “animation” and “transition” properties are defined on the
style object but the events that fire will still be prefixed, so we need
to check if the un-prefixed events are usable, and if not remove them from the map.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;AnimationEvent&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)) {
      <span class="hljs-keyword">delete</span> vendorPrefixes.<span class="hljs-property">animationend</span>.<span class="hljs-property">animation</span>;
      <span class="hljs-keyword">delete</span> vendorPrefixes.<span class="hljs-property">animationiteration</span>.<span class="hljs-property">animation</span>;
      <span class="hljs-keyword">delete</span> vendorPrefixes.<span class="hljs-property">animationstart</span>.<span class="hljs-property">animation</span>;
    } <span class="hljs-comment">// Same as above</span>


    <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;TransitionEvent&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>)) {
      <span class="hljs-keyword">delete</span> vendorPrefixes.<span class="hljs-property">transitionend</span>.<span class="hljs-property">transition</span>;
    }
  }
  <span class="hljs-comment">/**
   * Attempts to determine the correct vendor prefixed event name.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} <span class="hljs-variable">eventName</span>
   * <span class="hljs-doctag">@returns</span> {<span class="hljs-type">string</span>}
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getVendorPrefixedEventName</span>(<span class="hljs-params">eventName</span>) {
    <span class="hljs-keyword">if</span> (prefixedEventNames[eventName]) {
      <span class="hljs-keyword">return</span> prefixedEventNames[eventName];
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!vendorPrefixes[eventName]) {
      <span class="hljs-keyword">return</span> eventName;
    }

    <span class="hljs-keyword">var</span> prefixMap = vendorPrefixes[eventName];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> styleProp <span class="hljs-keyword">in</span> prefixMap) {
      <span class="hljs-keyword">if</span> (prefixMap.<span class="hljs-title function_">hasOwnProperty</span>(styleProp) &amp;&amp; styleProp <span class="hljs-keyword">in</span> style) {
        <span class="hljs-keyword">return</span> prefixedEventNames[eventName] = prefixMap[styleProp];
      }
    }

    <span class="hljs-keyword">return</span> eventName;
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ANIMATION_END</span> = <span class="hljs-title function_">getVendorPrefixedEventName</span>(<span class="hljs-string">&#x27;animationend&#x27;</span>);
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ANIMATION_ITERATION</span> = <span class="hljs-title function_">getVendorPrefixedEventName</span>(<span class="hljs-string">&#x27;animationiteration&#x27;</span>);
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ANIMATION_START</span> = <span class="hljs-title function_">getVendorPrefixedEventName</span>(<span class="hljs-string">&#x27;animationstart&#x27;</span>);
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">TRANSITION_END</span> = <span class="hljs-title function_">getVendorPrefixedEventName</span>(<span class="hljs-string">&#x27;transitionend&#x27;</span>);

  <span class="hljs-keyword">var</span> topLevelEventsToReactNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">var</span> eventPriorities = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// We store most of the events in this module in pairs of two strings so we can re-use</span></pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-196">&#x00a7;</a>
              </div>
              <p>the code required to apply the same logic for event prioritization and that of the
SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
duplication (for which there would be quite a bit). For the events that are not needed
for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
array of top level events.
Lastly, we ignore prettier so we can keep the formatting sane.
prettier-ignore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> discreteEventPairsForSimpleEventPlugin = [<span class="hljs-string">&#x27;cancel&#x27;</span>, <span class="hljs-string">&#x27;cancel&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-string">&#x27;contextMenu&#x27;</span>, <span class="hljs-string">&#x27;copy&#x27;</span>, <span class="hljs-string">&#x27;copy&#x27;</span>, <span class="hljs-string">&#x27;cut&#x27;</span>, <span class="hljs-string">&#x27;cut&#x27;</span>, <span class="hljs-string">&#x27;auxclick&#x27;</span>, <span class="hljs-string">&#x27;auxClick&#x27;</span>, <span class="hljs-string">&#x27;dblclick&#x27;</span>, <span class="hljs-string">&#x27;doubleClick&#x27;</span>, <span class="hljs-comment">// Careful!</span>
    <span class="hljs-string">&#x27;dragend&#x27;</span>, <span class="hljs-string">&#x27;dragEnd&#x27;</span>, <span class="hljs-string">&#x27;dragstart&#x27;</span>, <span class="hljs-string">&#x27;dragStart&#x27;</span>, <span class="hljs-string">&#x27;drop&#x27;</span>, <span class="hljs-string">&#x27;drop&#x27;</span>, <span class="hljs-string">&#x27;focusin&#x27;</span>, <span class="hljs-string">&#x27;focus&#x27;</span>, <span class="hljs-comment">// Careful!</span>
    <span class="hljs-string">&#x27;focusout&#x27;</span>, <span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-comment">// Careful!</span>
    <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;invalid&#x27;</span>, <span class="hljs-string">&#x27;invalid&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keyDown&#x27;</span>, <span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-string">&#x27;keyPress&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;keyUp&#x27;</span>, <span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-string">&#x27;mouseDown&#x27;</span>, <span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-string">&#x27;mouseUp&#x27;</span>, <span class="hljs-string">&#x27;paste&#x27;</span>, <span class="hljs-string">&#x27;paste&#x27;</span>, <span class="hljs-string">&#x27;pause&#x27;</span>, <span class="hljs-string">&#x27;pause&#x27;</span>, <span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;pointercancel&#x27;</span>, <span class="hljs-string">&#x27;pointerCancel&#x27;</span>, <span class="hljs-string">&#x27;pointerdown&#x27;</span>, <span class="hljs-string">&#x27;pointerDown&#x27;</span>, <span class="hljs-string">&#x27;pointerup&#x27;</span>, <span class="hljs-string">&#x27;pointerUp&#x27;</span>, <span class="hljs-string">&#x27;ratechange&#x27;</span>, <span class="hljs-string">&#x27;rateChange&#x27;</span>, <span class="hljs-string">&#x27;reset&#x27;</span>, <span class="hljs-string">&#x27;reset&#x27;</span>, <span class="hljs-string">&#x27;seeked&#x27;</span>, <span class="hljs-string">&#x27;seeked&#x27;</span>, <span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-string">&#x27;submit&#x27;</span>, <span class="hljs-string">&#x27;touchcancel&#x27;</span>, <span class="hljs-string">&#x27;touchCancel&#x27;</span>, <span class="hljs-string">&#x27;touchend&#x27;</span>, <span class="hljs-string">&#x27;touchEnd&#x27;</span>, <span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-string">&#x27;touchStart&#x27;</span>, <span class="hljs-string">&#x27;volumechange&#x27;</span>, <span class="hljs-string">&#x27;volumeChange&#x27;</span>];
  <span class="hljs-keyword">var</span> otherDiscreteEvents = [<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-string">&#x27;selectionchange&#x27;</span>, <span class="hljs-string">&#x27;textInput&#x27;</span>, <span class="hljs-string">&#x27;compositionstart&#x27;</span>, <span class="hljs-string">&#x27;compositionend&#x27;</span>, <span class="hljs-string">&#x27;compositionupdate&#x27;</span>];


  <span class="hljs-keyword">var</span> userBlockingPairsForSimpleEventPlugin = [<span class="hljs-string">&#x27;drag&#x27;</span>, <span class="hljs-string">&#x27;drag&#x27;</span>, <span class="hljs-string">&#x27;dragenter&#x27;</span>, <span class="hljs-string">&#x27;dragEnter&#x27;</span>, <span class="hljs-string">&#x27;dragexit&#x27;</span>, <span class="hljs-string">&#x27;dragExit&#x27;</span>, <span class="hljs-string">&#x27;dragleave&#x27;</span>, <span class="hljs-string">&#x27;dragLeave&#x27;</span>, <span class="hljs-string">&#x27;dragover&#x27;</span>, <span class="hljs-string">&#x27;dragOver&#x27;</span>, <span class="hljs-string">&#x27;mousemove&#x27;</span>, <span class="hljs-string">&#x27;mouseMove&#x27;</span>, <span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-string">&#x27;mouseOut&#x27;</span>, <span class="hljs-string">&#x27;mouseover&#x27;</span>, <span class="hljs-string">&#x27;mouseOver&#x27;</span>, <span class="hljs-string">&#x27;pointermove&#x27;</span>, <span class="hljs-string">&#x27;pointerMove&#x27;</span>, <span class="hljs-string">&#x27;pointerout&#x27;</span>, <span class="hljs-string">&#x27;pointerOut&#x27;</span>, <span class="hljs-string">&#x27;pointerover&#x27;</span>, <span class="hljs-string">&#x27;pointerOver&#x27;</span>, <span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-string">&#x27;toggle&#x27;</span>, <span class="hljs-string">&#x27;toggle&#x27;</span>, <span class="hljs-string">&#x27;touchmove&#x27;</span>, <span class="hljs-string">&#x27;touchMove&#x27;</span>, <span class="hljs-string">&#x27;wheel&#x27;</span>, <span class="hljs-string">&#x27;wheel&#x27;</span>]; <span class="hljs-comment">// prettier-ignore</span>

  <span class="hljs-keyword">var</span> continuousPairsForSimpleEventPlugin = [<span class="hljs-string">&#x27;abort&#x27;</span>, <span class="hljs-string">&#x27;abort&#x27;</span>, <span class="hljs-variable constant_">ANIMATION_END</span>, <span class="hljs-string">&#x27;animationEnd&#x27;</span>, <span class="hljs-variable constant_">ANIMATION_ITERATION</span>, <span class="hljs-string">&#x27;animationIteration&#x27;</span>, <span class="hljs-variable constant_">ANIMATION_START</span>, <span class="hljs-string">&#x27;animationStart&#x27;</span>, <span class="hljs-string">&#x27;canplay&#x27;</span>, <span class="hljs-string">&#x27;canPlay&#x27;</span>, <span class="hljs-string">&#x27;canplaythrough&#x27;</span>, <span class="hljs-string">&#x27;canPlayThrough&#x27;</span>, <span class="hljs-string">&#x27;durationchange&#x27;</span>, <span class="hljs-string">&#x27;durationChange&#x27;</span>, <span class="hljs-string">&#x27;emptied&#x27;</span>, <span class="hljs-string">&#x27;emptied&#x27;</span>, <span class="hljs-string">&#x27;encrypted&#x27;</span>, <span class="hljs-string">&#x27;encrypted&#x27;</span>, <span class="hljs-string">&#x27;ended&#x27;</span>, <span class="hljs-string">&#x27;ended&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;gotpointercapture&#x27;</span>, <span class="hljs-string">&#x27;gotPointerCapture&#x27;</span>, <span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-string">&#x27;loadeddata&#x27;</span>, <span class="hljs-string">&#x27;loadedData&#x27;</span>, <span class="hljs-string">&#x27;loadedmetadata&#x27;</span>, <span class="hljs-string">&#x27;loadedMetadata&#x27;</span>, <span class="hljs-string">&#x27;loadstart&#x27;</span>, <span class="hljs-string">&#x27;loadStart&#x27;</span>, <span class="hljs-string">&#x27;lostpointercapture&#x27;</span>, <span class="hljs-string">&#x27;lostPointerCapture&#x27;</span>, <span class="hljs-string">&#x27;playing&#x27;</span>, <span class="hljs-string">&#x27;playing&#x27;</span>, <span class="hljs-string">&#x27;progress&#x27;</span>, <span class="hljs-string">&#x27;progress&#x27;</span>, <span class="hljs-string">&#x27;seeking&#x27;</span>, <span class="hljs-string">&#x27;seeking&#x27;</span>, <span class="hljs-string">&#x27;stalled&#x27;</span>, <span class="hljs-string">&#x27;stalled&#x27;</span>, <span class="hljs-string">&#x27;suspend&#x27;</span>, <span class="hljs-string">&#x27;suspend&#x27;</span>, <span class="hljs-string">&#x27;timeupdate&#x27;</span>, <span class="hljs-string">&#x27;timeUpdate&#x27;</span>, <span class="hljs-variable constant_">TRANSITION_END</span>, <span class="hljs-string">&#x27;transitionEnd&#x27;</span>, <span class="hljs-string">&#x27;waiting&#x27;</span>, <span class="hljs-string">&#x27;waiting&#x27;</span>];
  <span class="hljs-comment">/**
   * Turns
   * [&#x27;abort&#x27;, ...]
   *
   * into
   *
   * topLevelEventsToReactNames = new Map([
   *   [&#x27;abort&#x27;, &#x27;onAbort&#x27;],
   * ]);
   *
   * and registers them.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerSimplePluginEventsAndSetTheirPriorities</span>(<span class="hljs-params">eventTypes, priority</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-197">&#x00a7;</a>
              </div>
              <p>As the event types are in pairs of two, we need to iterate
through in twos. The events are in pairs of two to save code
and improve init perf of processing this array, as it will
result in far fewer object allocations and property accesses
if we only use three arrays to process all the categories of
instead of tuples.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; eventTypes.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">var</span> topEvent = eventTypes[i];
      <span class="hljs-keyword">var</span> event = eventTypes[i + <span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> capitalizedEvent = event[<span class="hljs-number">0</span>].<span class="hljs-title function_">toUpperCase</span>() + event.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">var</span> reactName = <span class="hljs-string">&#x27;on&#x27;</span> + capitalizedEvent;
      eventPriorities.<span class="hljs-title function_">set</span>(topEvent, priority);
      topLevelEventsToReactNames.<span class="hljs-title function_">set</span>(topEvent, reactName);
      <span class="hljs-title function_">registerTwoPhaseEvent</span>(reactName, [topEvent]);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setEventPriorities</span>(<span class="hljs-params">eventTypes, priority</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; eventTypes.<span class="hljs-property">length</span>; i++) {
      eventPriorities.<span class="hljs-title function_">set</span>(eventTypes[i], priority);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEventPriorityForPluginSystem</span>(<span class="hljs-params">domEventName</span>) {
    <span class="hljs-keyword">var</span> priority = eventPriorities.<span class="hljs-title function_">get</span>(domEventName); <span class="hljs-comment">// Default to a ContinuousEvent. Note: we might</span></pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-198">&#x00a7;</a>
              </div>
              <p>want to warn if we can’t detect the priority
for the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">return</span> priority === <span class="hljs-literal">undefined</span> ? <span class="hljs-title class_">ContinuousEvent</span> : priority;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerSimpleEvents</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">registerSimplePluginEventsAndSetTheirPriorities</span>(discreteEventPairsForSimpleEventPlugin, <span class="hljs-title class_">DiscreteEvent</span>);
    <span class="hljs-title function_">registerSimplePluginEventsAndSetTheirPriorities</span>(userBlockingPairsForSimpleEventPlugin, <span class="hljs-title class_">UserBlockingEvent</span>);
    <span class="hljs-title function_">registerSimplePluginEventsAndSetTheirPriorities</span>(continuousPairsForSimpleEventPlugin, <span class="hljs-title class_">ContinuousEvent</span>);
    <span class="hljs-title function_">setEventPriorities</span>(otherDiscreteEvents, <span class="hljs-title class_">DiscreteEvent</span>);
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactInternals</span>$<span class="hljs-number">2</span> = <span class="hljs-title class_">React</span>.<span class="hljs-property">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span>;
  <span class="hljs-keyword">var</span> _ReactInternals$Sched$1 = <span class="hljs-title class_">ReactInternals</span>$<span class="hljs-number">2.</span><span class="hljs-title class_">SchedulerTracing</span>,
    __interactionsRef = _ReactInternals$Sched$1.<span class="hljs-property">__interactionsRef</span>,
    __subscriberRef = _ReactInternals$Sched$1.<span class="hljs-property">__subscriberRef</span>,
    unstable_clear = _ReactInternals$Sched$1.<span class="hljs-property">unstable_clear</span>,
    unstable_getCurrent = _ReactInternals$Sched$1.<span class="hljs-property">unstable_getCurrent</span>,
    unstable_getThreadID = _ReactInternals$Sched$1.<span class="hljs-property">unstable_getThreadID</span>,
    unstable_subscribe = _ReactInternals$Sched$1.<span class="hljs-property">unstable_subscribe</span>,
    unstable_trace = _ReactInternals$Sched$1.<span class="hljs-property">unstable_trace</span>,
    unstable_unsubscribe = _ReactInternals$Sched$1.<span class="hljs-property">unstable_unsubscribe</span>,
    unstable_wrap = _ReactInternals$Sched$1.<span class="hljs-property">unstable_wrap</span>;

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Scheduler</span>_now = unstable_now;

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-199">&#x00a7;</a>
              </div>
              <p>Provide explicit error message when production+profiling bundle of e.g.
react-dom is used with production (non-profiling) bundle of
scheduler/tracing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!(__interactionsRef != <span class="hljs-literal">null</span> &amp;&amp; __interactionsRef.<span class="hljs-property">current</span> != <span class="hljs-literal">null</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling&quot;</span>);
      }
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-200">&#x00a7;</a>
              </div>
              <p>ascending numbers so we can compare them like numbers. They start at 90 to
avoid clashing with Scheduler’s priorities.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ImmediatePriority</span> = <span class="hljs-number">99</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">UserBlockingPriority</span> = <span class="hljs-number">98</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NormalPriority</span> = <span class="hljs-number">97</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LowPriority</span> = <span class="hljs-number">96</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IdlePriority</span> = <span class="hljs-number">95</span>; <span class="hljs-comment">// NoPriority is the absence of priority. Also React-only.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoPriority</span> = <span class="hljs-number">90</span>;
  <span class="hljs-keyword">var</span> initialTimeMs = <span class="hljs-title class_">Scheduler</span>_now(); <span class="hljs-comment">// If the initial timestamp is reasonably small, use Scheduler&#x27;s `now` directly.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyncLanePriority</span> = <span class="hljs-number">15</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyncBatchedLanePriority</span> = <span class="hljs-number">14</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputDiscreteHydrationLanePriority</span> = <span class="hljs-number">13</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputDiscreteLanePriority</span> = <span class="hljs-number">12</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputContinuousHydrationLanePriority</span> = <span class="hljs-number">11</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputContinuousLanePriority</span> = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DefaultHydrationLanePriority</span> = <span class="hljs-number">9</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DefaultLanePriority</span> = <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">TransitionHydrationPriority</span> = <span class="hljs-number">7</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">TransitionPriority</span> = <span class="hljs-number">6</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RetryLanePriority</span> = <span class="hljs-number">5</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SelectiveHydrationLanePriority</span> = <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IdleHydrationLanePriority</span> = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IdleLanePriority</span> = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">OffscreenLanePriority</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoLanePriority</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">TotalLanes</span> = <span class="hljs-number">31</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoLanes</span> =
    <span class="hljs-comment">/*                        */</span>
    <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoLane</span> =
    <span class="hljs-comment">/*                          */</span>
    <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyncLane</span> =
    <span class="hljs-comment">/*                        */</span>
    <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyncBatchedLane</span> =
    <span class="hljs-comment">/*                 */</span>
    <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputDiscreteHydrationLane</span> =
    <span class="hljs-comment">/*      */</span>
    <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputDiscreteLanes</span> =
    <span class="hljs-comment">/*                    */</span>
    <span class="hljs-number">24</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputContinuousHydrationLane</span> =
    <span class="hljs-comment">/*           */</span>
    <span class="hljs-number">32</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InputContinuousLanes</span> =
    <span class="hljs-comment">/*                  */</span>
    <span class="hljs-number">192</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DefaultHydrationLane</span> =
    <span class="hljs-comment">/*            */</span>
    <span class="hljs-number">256</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DefaultLanes</span> =
    <span class="hljs-comment">/*                   */</span>
    <span class="hljs-number">3584</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">TransitionHydrationLane</span> =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">4096</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">TransitionLanes</span> =
    <span class="hljs-comment">/*                       */</span>
    <span class="hljs-number">4186112</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RetryLanes</span> =
    <span class="hljs-comment">/*                            */</span>
    <span class="hljs-number">62914560</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SomeRetryLane</span> =
    <span class="hljs-comment">/*                  */</span>
    <span class="hljs-number">33554432</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SelectiveHydrationLane</span> =
    <span class="hljs-comment">/*          */</span>
    <span class="hljs-number">67108864</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NonIdleLanes</span> =
    <span class="hljs-comment">/*                                 */</span>
    <span class="hljs-number">134217727</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IdleHydrationLane</span> =
    <span class="hljs-comment">/*               */</span>
    <span class="hljs-number">134217728</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IdleLanes</span> =
    <span class="hljs-comment">/*                             */</span>
    <span class="hljs-number">805306368</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">OffscreenLane</span> =
    <span class="hljs-comment">/*                   */</span>
    <span class="hljs-number">1073741824</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoTimestamp</span> = -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> currentUpdateLanePriority = <span class="hljs-title class_">NoLanePriority</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentUpdateLanePriority</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> currentUpdateLanePriority;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setCurrentUpdateLanePriority</span>(<span class="hljs-params">newLanePriority</span>) {
    currentUpdateLanePriority = newLanePriority;
  } <span class="hljs-comment">// &quot;Registers&quot; used to &quot;return&quot; multiple values</span></pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-201">&#x00a7;</a>
              </div>
              <p>Used by getHighestPriorityLanes and getNextLanes:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> return_highestLanePriority = <span class="hljs-title class_">DefaultLanePriority</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHighestPriorityLanes</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">if</span> ((<span class="hljs-title class_">SyncLane</span> &amp; lanes) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">SyncLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLane</span>;
    }

    <span class="hljs-keyword">if</span> ((<span class="hljs-title class_">SyncBatchedLane</span> &amp; lanes) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">SyncBatchedLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncBatchedLane</span>;
    }

    <span class="hljs-keyword">if</span> ((<span class="hljs-title class_">InputDiscreteHydrationLane</span> &amp; lanes) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">InputDiscreteHydrationLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">InputDiscreteHydrationLane</span>;
    }

    <span class="hljs-keyword">var</span> inputDiscreteLanes = <span class="hljs-title class_">InputDiscreteLanes</span> &amp; lanes;

    <span class="hljs-keyword">if</span> (inputDiscreteLanes !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">InputDiscreteLanePriority</span>;
      <span class="hljs-keyword">return</span> inputDiscreteLanes;
    }

    <span class="hljs-keyword">if</span> ((lanes &amp; <span class="hljs-title class_">InputContinuousHydrationLane</span>) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">InputContinuousHydrationLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">InputContinuousHydrationLane</span>;
    }

    <span class="hljs-keyword">var</span> inputContinuousLanes = <span class="hljs-title class_">InputContinuousLanes</span> &amp; lanes;

    <span class="hljs-keyword">if</span> (inputContinuousLanes !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">InputContinuousLanePriority</span>;
      <span class="hljs-keyword">return</span> inputContinuousLanes;
    }

    <span class="hljs-keyword">if</span> ((lanes &amp; <span class="hljs-title class_">DefaultHydrationLane</span>) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">DefaultHydrationLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">DefaultHydrationLane</span>;
    }

    <span class="hljs-keyword">var</span> defaultLanes = <span class="hljs-title class_">DefaultLanes</span> &amp; lanes;

    <span class="hljs-keyword">if</span> (defaultLanes !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">DefaultLanePriority</span>;
      <span class="hljs-keyword">return</span> defaultLanes;
    }

    <span class="hljs-keyword">if</span> ((lanes &amp; <span class="hljs-title class_">TransitionHydrationLane</span>) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">TransitionHydrationPriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">TransitionHydrationLane</span>;
    }

    <span class="hljs-keyword">var</span> transitionLanes = <span class="hljs-title class_">TransitionLanes</span> &amp; lanes;

    <span class="hljs-keyword">if</span> (transitionLanes !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">TransitionPriority</span>;
      <span class="hljs-keyword">return</span> transitionLanes;
    }

    <span class="hljs-keyword">var</span> retryLanes = <span class="hljs-title class_">RetryLanes</span> &amp; lanes;

    <span class="hljs-keyword">if</span> (retryLanes !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">RetryLanePriority</span>;
      <span class="hljs-keyword">return</span> retryLanes;
    }

    <span class="hljs-keyword">if</span> (lanes &amp; <span class="hljs-title class_">SelectiveHydrationLane</span>) {
      return_highestLanePriority = <span class="hljs-title class_">SelectiveHydrationLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">SelectiveHydrationLane</span>;
    }

    <span class="hljs-keyword">if</span> ((lanes &amp; <span class="hljs-title class_">IdleHydrationLane</span>) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">IdleHydrationLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdleHydrationLane</span>;
    }

    <span class="hljs-keyword">var</span> idleLanes = <span class="hljs-title class_">IdleLanes</span> &amp; lanes;

    <span class="hljs-keyword">if</span> (idleLanes !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">IdleLanePriority</span>;
      <span class="hljs-keyword">return</span> idleLanes;
    }

    <span class="hljs-keyword">if</span> ((<span class="hljs-title class_">OffscreenLane</span> &amp; lanes) !== <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">OffscreenLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">OffscreenLane</span>;
    }

    {
      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Should have found matching lanes. This is a bug in React.&#x27;</span>);
    } <span class="hljs-comment">// This shouldn&#x27;t be reachable, but as a fallback, return the entire bitmask.</span>


    return_highestLanePriority = <span class="hljs-title class_">DefaultLanePriority</span>;
    <span class="hljs-keyword">return</span> lanes;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">schedulerPriorityToLanePriority</span>(<span class="hljs-params">schedulerPriorityLevel</span>) {
    <span class="hljs-keyword">switch</span> (schedulerPriorityLevel) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLanePriority</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">InputContinuousLanePriority</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-202">&#x00a7;</a>
              </div>
              <p>TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">DefaultLanePriority</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdleLanePriority</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoLanePriority</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">lanePriorityToSchedulerPriority</span>(<span class="hljs-params">lanePriority</span>) {
    <span class="hljs-keyword">switch</span> (lanePriority) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SyncLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SyncBatchedLanePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ImmediatePriority</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputDiscreteHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputDiscreteLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputContinuousHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputContinuousLanePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserBlockingPriority</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DefaultHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DefaultLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TransitionHydrationPriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TransitionPriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SelectiveHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RetryLanePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NormalPriority</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdleHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdleLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenLanePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdlePriority</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">NoLanePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoPriority</span>;

      <span class="hljs-attr">default</span>:
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid update priority: &quot;</span> + lanePriority + <span class="hljs-string">&quot;. This is a bug in React.&quot;</span>);
          }
        }

    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNextLanes</span>(<span class="hljs-params">root, wipLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-203">&#x00a7;</a>
              </div>
              <p>Early bailout if there’s no pending work left.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> pendingLanes = root.<span class="hljs-property">pendingLanes</span>;

    <span class="hljs-keyword">if</span> (pendingLanes === <span class="hljs-title class_">NoLanes</span>) {
      return_highestLanePriority = <span class="hljs-title class_">NoLanePriority</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoLanes</span>;
    }

    <span class="hljs-keyword">var</span> nextLanes = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-keyword">var</span> nextLanePriority = <span class="hljs-title class_">NoLanePriority</span>;
    <span class="hljs-keyword">var</span> expiredLanes = root.<span class="hljs-property">expiredLanes</span>;
    <span class="hljs-keyword">var</span> suspendedLanes = root.<span class="hljs-property">suspendedLanes</span>;
    <span class="hljs-keyword">var</span> pingedLanes = root.<span class="hljs-property">pingedLanes</span>; <span class="hljs-comment">// Check if any work has expired.</span>

    <span class="hljs-keyword">if</span> (expiredLanes !== <span class="hljs-title class_">NoLanes</span>) {
      nextLanes = expiredLanes;
      nextLanePriority = return_highestLanePriority = <span class="hljs-title class_">SyncLanePriority</span>;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-204">&#x00a7;</a>
              </div>
              <p>Do not work on any idle work until all the non-idle work has finished,
even if the work is suspended.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> nonIdlePendingLanes = pendingLanes &amp; <span class="hljs-title class_">NonIdleLanes</span>;

      <span class="hljs-keyword">if</span> (nonIdlePendingLanes !== <span class="hljs-title class_">NoLanes</span>) {
        <span class="hljs-keyword">var</span> nonIdleUnblockedLanes = nonIdlePendingLanes &amp; ~suspendedLanes;

        <span class="hljs-keyword">if</span> (nonIdleUnblockedLanes !== <span class="hljs-title class_">NoLanes</span>) {
          nextLanes = <span class="hljs-title function_">getHighestPriorityLanes</span>(nonIdleUnblockedLanes);
          nextLanePriority = return_highestLanePriority;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> nonIdlePingedLanes = nonIdlePendingLanes &amp; pingedLanes;

          <span class="hljs-keyword">if</span> (nonIdlePingedLanes !== <span class="hljs-title class_">NoLanes</span>) {
            nextLanes = <span class="hljs-title function_">getHighestPriorityLanes</span>(nonIdlePingedLanes);
            nextLanePriority = return_highestLanePriority;
          }
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-205">&#x00a7;</a>
              </div>
              <p>The only remaining work is Idle.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> unblockedLanes = pendingLanes &amp; ~suspendedLanes;

        <span class="hljs-keyword">if</span> (unblockedLanes !== <span class="hljs-title class_">NoLanes</span>) {
          nextLanes = <span class="hljs-title function_">getHighestPriorityLanes</span>(unblockedLanes);
          nextLanePriority = return_highestLanePriority;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (pingedLanes !== <span class="hljs-title class_">NoLanes</span>) {
            nextLanes = <span class="hljs-title function_">getHighestPriorityLanes</span>(pingedLanes);
            nextLanePriority = return_highestLanePriority;
          }
        }
      }
    }

    <span class="hljs-keyword">if</span> (nextLanes === <span class="hljs-title class_">NoLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-206">&#x00a7;</a>
              </div>
              <p>This should only be reachable if we’re suspended
TODO: Consider warning in this path if a fallback timer is not scheduled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoLanes</span>;
    } <span class="hljs-comment">// If there are higher priority lanes, we&#x27;ll include them even if they</span></pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-207">&#x00a7;</a>
              </div>
              <p>are suspended.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    nextLanes = pendingLanes &amp; <span class="hljs-title function_">getEqualOrHigherPriorityLanes</span>(nextLanes); <span class="hljs-comment">// If we&#x27;re already in the middle of a render, switching lanes will interrupt</span></pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-208">&#x00a7;</a>
              </div>
              <p>it and we’ll lose our progress. We should only do this if the new lanes are
higher priority.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (wipLanes !== <span class="hljs-title class_">NoLanes</span> &amp;&amp; wipLanes !== nextLanes &amp;&amp; <span class="hljs-comment">// If we already suspended with a delay, then interrupting is fine. Don&#x27;t</span></pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-209">&#x00a7;</a>
              </div>
              <p>bother waiting until the root is complete.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (wipLanes &amp; suspendedLanes) === <span class="hljs-title class_">NoLanes</span>) {
      <span class="hljs-title function_">getHighestPriorityLanes</span>(wipLanes);
      <span class="hljs-keyword">var</span> wipLanePriority = return_highestLanePriority;

      <span class="hljs-keyword">if</span> (nextLanePriority &lt;= wipLanePriority) {
        <span class="hljs-keyword">return</span> wipLanes;
      } <span class="hljs-keyword">else</span> {
        return_highestLanePriority = nextLanePriority;
      }
    } <span class="hljs-comment">// Check for entangled lanes and add them to the batch.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-210">&#x00a7;</a>
              </div>
              <p>A lane is said to be entangled with another when it’s not allowed to render
in a batch that does not also include the other lane. Typically we do this
when multiple updates have the same source, and we only want to respond to
the most recent event from that source.</p>
<p>Note that we apply entanglements <em>after</em> checking for partial work above.
This means that if a lane is entangled during an interleaved event while
it’s already rendering, we won’t interrupt it. This is intentional, since
entanglement is usually “best effort”: we’ll try our best to render the
lanes in the same batch, but it’s not worth throwing out partially
completed work in order to do it.</p>
<p>For those exceptions where entanglement is semantically important, like
useMutableSource, we should ensure that there is no partial work at the
time we apply the entanglement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> entangledLanes = root.<span class="hljs-property">entangledLanes</span>;

    <span class="hljs-keyword">if</span> (entangledLanes !== <span class="hljs-title class_">NoLanes</span>) {
      <span class="hljs-keyword">var</span> entanglements = root.<span class="hljs-property">entanglements</span>;
      <span class="hljs-keyword">var</span> lanes = nextLanes &amp; entangledLanes;

      <span class="hljs-keyword">while</span> (lanes &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> index = <span class="hljs-title function_">pickArbitraryLaneIndex</span>(lanes);
        <span class="hljs-keyword">var</span> lane = <span class="hljs-number">1</span> &lt;&lt; index;
        nextLanes |= entanglements[index];
        lanes &amp;= ~lane;
      }
    }

    <span class="hljs-keyword">return</span> nextLanes;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMostRecentEventTime</span>(<span class="hljs-params">root, lanes</span>) {
    <span class="hljs-keyword">var</span> eventTimes = root.<span class="hljs-property">eventTimes</span>;
    <span class="hljs-keyword">var</span> mostRecentEventTime = <span class="hljs-title class_">NoTimestamp</span>;

    <span class="hljs-keyword">while</span> (lanes &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> index = <span class="hljs-title function_">pickArbitraryLaneIndex</span>(lanes);
      <span class="hljs-keyword">var</span> lane = <span class="hljs-number">1</span> &lt;&lt; index;
      <span class="hljs-keyword">var</span> eventTime = eventTimes[index];

      <span class="hljs-keyword">if</span> (eventTime &gt; mostRecentEventTime) {
        mostRecentEventTime = eventTime;
      }

      lanes &amp;= ~lane;
    }

    <span class="hljs-keyword">return</span> mostRecentEventTime;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">computeExpirationTime</span>(<span class="hljs-params">lane, currentTime</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-211">&#x00a7;</a>
              </div>
              <p>TODO: Expiration heuristic is constant per lane, so could use a map.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">getHighestPriorityLanes</span>(lane);
    <span class="hljs-keyword">var</span> priority = return_highestLanePriority;

    <span class="hljs-keyword">if</span> (priority &gt;= <span class="hljs-title class_">InputContinuousLanePriority</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-212">&#x00a7;</a>
              </div>
              <p>User interactions should expire slightly more quickly.</p>
<p>NOTE: This is set to the corresponding constant as in Scheduler.js. When
we made it larger, a product metric in www regressed, suggesting there’s
a user interaction that’s being starved by a series of synchronous
updates. If that theory is correct, the proper solution is to fix the
starvation. However, this scenario supports the idea that expiration
times are an important safeguard when starvation does happen.</p>
<p>Also note that, in the case of user input specifically, this will soon no
longer be an issue because we plan to make user input synchronous by
default (until you enter <code>startTransition</code>, of course.)</p>
<p>If weren’t planning to make these updates synchronous soon anyway, I
would probably make this number a configurable parameter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> currentTime + <span class="hljs-number">250</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (priority &gt;= <span class="hljs-title class_">TransitionPriority</span>) {
      <span class="hljs-keyword">return</span> currentTime + <span class="hljs-number">5000</span>;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-213">&#x00a7;</a>
              </div>
              <p>Anything idle priority or lower should never expire.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoTimestamp</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markStarvedLanesAsExpired</span>(<span class="hljs-params">root, currentTime</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-214">&#x00a7;</a>
              </div>
              <p>TODO: This gets called every time we yield. We can optimize by storing
the earliest expiration time on the root. Then use that to quickly bail out
of this function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> pendingLanes = root.<span class="hljs-property">pendingLanes</span>;
    <span class="hljs-keyword">var</span> suspendedLanes = root.<span class="hljs-property">suspendedLanes</span>;
    <span class="hljs-keyword">var</span> pingedLanes = root.<span class="hljs-property">pingedLanes</span>;
    <span class="hljs-keyword">var</span> expirationTimes = root.<span class="hljs-property">expirationTimes</span>; <span class="hljs-comment">// Iterate through the pending lanes and check if we&#x27;ve reached their</span></pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-215">&#x00a7;</a>
              </div>
              <p>expiration time. If so, we’ll assume the update is being starved and mark
it as expired to force it to finish.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> lanes = pendingLanes;

    <span class="hljs-keyword">while</span> (lanes &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> index = <span class="hljs-title function_">pickArbitraryLaneIndex</span>(lanes);
      <span class="hljs-keyword">var</span> lane = <span class="hljs-number">1</span> &lt;&lt; index;
      <span class="hljs-keyword">var</span> expirationTime = expirationTimes[index];

      <span class="hljs-keyword">if</span> (expirationTime === <span class="hljs-title class_">NoTimestamp</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-216">&#x00a7;</a>
              </div>
              <p>Found a pending lane with no expiration time. If it’s not suspended, or
if it’s pinged, assume it’s CPU-bound. Compute a new expiration time
using the current time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((lane &amp; suspendedLanes) === <span class="hljs-title class_">NoLanes</span> || (lane &amp; pingedLanes) !== <span class="hljs-title class_">NoLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-217">&#x00a7;</a>
              </div>
              <p>Assumes timestamps are monotonically increasing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          expirationTimes[index] = <span class="hljs-title function_">computeExpirationTime</span>(lane, currentTime);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expirationTime &lt;= currentTime) {</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-218">&#x00a7;</a>
              </div>
              <p>This lane expired</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        root.<span class="hljs-property">expiredLanes</span> |= lane;
      }

      lanes &amp;= ~lane;
    }
  } <span class="hljs-comment">// This returns the highest priority pending lanes regardless of whether they</span></pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-219">&#x00a7;</a>
              </div>
              <p>are suspended.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHighestPriorityPendingLanes</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getHighestPriorityLanes</span>(root.<span class="hljs-property">pendingLanes</span>);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLanesToRetrySynchronouslyOnError</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">var</span> everythingButOffscreen = root.<span class="hljs-property">pendingLanes</span> &amp; ~<span class="hljs-title class_">OffscreenLane</span>;

    <span class="hljs-keyword">if</span> (everythingButOffscreen !== <span class="hljs-title class_">NoLanes</span>) {
      <span class="hljs-keyword">return</span> everythingButOffscreen;
    }

    <span class="hljs-keyword">if</span> (everythingButOffscreen &amp; <span class="hljs-title class_">OffscreenLane</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">OffscreenLane</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoLanes</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">returnNextLanesPriority</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> return_highestLanePriority;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">includesNonIdleWork</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">return</span> (lanes &amp; <span class="hljs-title class_">NonIdleLanes</span>) !== <span class="hljs-title class_">NoLanes</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">includesOnlyRetries</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">return</span> (lanes &amp; <span class="hljs-title class_">RetryLanes</span>) === lanes;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">includesOnlyTransitions</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">return</span> (lanes &amp; <span class="hljs-title class_">TransitionLanes</span>) === lanes;
  } <span class="hljs-comment">// To ensure consistency across multiple updates in the same event, this should</span></pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-220">&#x00a7;</a>
              </div>
              <p>be a pure function, so that it always returns the same lane for given inputs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findUpdateLane</span>(<span class="hljs-params">lanePriority, wipLanes</span>) {
    <span class="hljs-keyword">switch</span> (lanePriority) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">NoLanePriority</span>:
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SyncLanePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLane</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SyncBatchedLanePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncBatchedLane</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputDiscreteLanePriority</span>:
        {
          <span class="hljs-keyword">var</span> _lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">InputDiscreteLanes</span> &amp; ~wipLanes);

          <span class="hljs-keyword">if</span> (_lane === <span class="hljs-title class_">NoLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-221">&#x00a7;</a>
              </div>
              <p>Shift to the next priority level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">findUpdateLane</span>(<span class="hljs-title class_">InputContinuousLanePriority</span>, wipLanes);
          }

          <span class="hljs-keyword">return</span> _lane;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputContinuousLanePriority</span>:
        {
          <span class="hljs-keyword">var</span> _lane2 = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">InputContinuousLanes</span> &amp; ~wipLanes);

          <span class="hljs-keyword">if</span> (_lane2 === <span class="hljs-title class_">NoLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-222">&#x00a7;</a>
              </div>
              <p>Shift to the next priority level</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">findUpdateLane</span>(<span class="hljs-title class_">DefaultLanePriority</span>, wipLanes);
          }

          <span class="hljs-keyword">return</span> _lane2;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DefaultLanePriority</span>:
        {
          <span class="hljs-keyword">var</span> _lane3 = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">DefaultLanes</span> &amp; ~wipLanes);

          <span class="hljs-keyword">if</span> (_lane3 === <span class="hljs-title class_">NoLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-223">&#x00a7;</a>
              </div>
              <p>If all the default lanes are already being worked on, look for a
lane in the transition range.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            _lane3 = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">TransitionLanes</span> &amp; ~wipLanes);

            <span class="hljs-keyword">if</span> (_lane3 === <span class="hljs-title class_">NoLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-224">&#x00a7;</a>
              </div>
              <p>All the transition lanes are taken, too. This should be very
rare, but as a last resort, pick a default lane. This will have
the effect of interrupting the current work-in-progress render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              _lane3 = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">DefaultLanes</span>);
            }
          }

          <span class="hljs-keyword">return</span> _lane3;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TransitionPriority</span>: <span class="hljs-comment">// Should be handled by findTransitionLane instead</span>

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RetryLanePriority</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-225">&#x00a7;</a>
              </div>
              <p>Should be handled by findRetryLane instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdleLanePriority</span>:
        <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">IdleLanes</span> &amp; ~wipLanes);

        <span class="hljs-keyword">if</span> (lane === <span class="hljs-title class_">NoLane</span>) {
          lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">IdleLanes</span>);
        }

        <span class="hljs-keyword">return</span> lane;
    }

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid update priority: &quot;</span> + lanePriority + <span class="hljs-string">&quot;. This is a bug in React.&quot;</span>);
      }
    }
  } <span class="hljs-comment">// To ensure consistency across multiple updates in the same event, this should</span></pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-226">&#x00a7;</a>
              </div>
              <p>be pure function, so that it always returns the same lane for given inputs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findTransitionLane</span>(<span class="hljs-params">wipLanes, pendingLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-227">&#x00a7;</a>
              </div>
              <p>First look for lanes that are completely unclaimed, i.e. have no
pending work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">TransitionLanes</span> &amp; ~pendingLanes);

    <span class="hljs-keyword">if</span> (lane === <span class="hljs-title class_">NoLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-228">&#x00a7;</a>
              </div>
              <p>If all lanes have pending work, look for a lane that isn’t currently
being worked on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">TransitionLanes</span> &amp; ~wipLanes);

      <span class="hljs-keyword">if</span> (lane === <span class="hljs-title class_">NoLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-229">&#x00a7;</a>
              </div>
              <p>If everything is being worked on, pick any lane. This has the
effect of interrupting the current work-in-progress.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">TransitionLanes</span>);
      }
    }

    <span class="hljs-keyword">return</span> lane;
  } <span class="hljs-comment">// To ensure consistency across multiple updates in the same event, this should</span></pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-230">&#x00a7;</a>
              </div>
              <p>be pure function, so that it always returns the same lane for given inputs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findRetryLane</span>(<span class="hljs-params">wipLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-231">&#x00a7;</a>
              </div>
              <p>This is a fork of <code>findUpdateLane</code> designed specifically for Suspense
“retries” — a special update that attempts to flip a Suspense boundary
from its placeholder state to its primary/resolved state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">RetryLanes</span> &amp; ~wipLanes);

    <span class="hljs-keyword">if</span> (lane === <span class="hljs-title class_">NoLane</span>) {
      lane = <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-title class_">RetryLanes</span>);
    }

    <span class="hljs-keyword">return</span> lane;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHighestPriorityLane</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">return</span> lanes &amp; -lanes;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLowestPriorityLane</span>(<span class="hljs-params">lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-232">&#x00a7;</a>
              </div>
              <p>This finds the most significant non-zero bit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> index = <span class="hljs-number">31</span> - <span class="hljs-title function_">clz32</span>(lanes);
    <span class="hljs-keyword">return</span> index &lt; <span class="hljs-number">0</span> ? <span class="hljs-title class_">NoLanes</span> : <span class="hljs-number">1</span> &lt;&lt; index;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEqualOrHigherPriorityLanes</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">return</span> (<span class="hljs-title function_">getLowestPriorityLane</span>(lanes) &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pickArbitraryLane</span>(<span class="hljs-params">lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-233">&#x00a7;</a>
              </div>
              <p>This wrapper function gets inlined. Only exists so to communicate that it
doesn’t matter which bit is selected; you can pick any bit without
affecting the algorithms where its used. Here I’m using
getHighestPriorityLane because it requires the fewest operations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getHighestPriorityLane</span>(lanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pickArbitraryLaneIndex</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">31</span> - <span class="hljs-title function_">clz32</span>(lanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">laneToIndex</span>(<span class="hljs-params">lane</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">pickArbitraryLaneIndex</span>(lane);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">includesSomeLane</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">return</span> (a &amp; b) !== <span class="hljs-title class_">NoLanes</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isSubsetOfLanes</span>(<span class="hljs-params">set, subset</span>) {
    <span class="hljs-keyword">return</span> (set &amp; subset) === subset;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeLanes</span>(<span class="hljs-params">a, b</span>) {
    <span class="hljs-keyword">return</span> a | b;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">removeLanes</span>(<span class="hljs-params">set, subset</span>) {
    <span class="hljs-keyword">return</span> set &amp; ~subset;
  } <span class="hljs-comment">// Seems redundant, but it changes the type from a single lane (used for</span></pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-234">&#x00a7;</a>
              </div>
              <p>updates) to a group of lanes (used for flushing work).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">laneToLanes</span>(<span class="hljs-params">lane</span>) {
    <span class="hljs-keyword">return</span> lane;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">higherPriorityLane</span>(<span class="hljs-params">a, b</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-235">&#x00a7;</a>
              </div>
              <p>This works because the bit ranges decrease in priority as you go left.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> a !== <span class="hljs-title class_">NoLane</span> &amp;&amp; a &lt; b ? a : b;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createLaneMap</span>(<span class="hljs-params">initial</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-236">&#x00a7;</a>
              </div>
              <p>Intentionally pushing one by one.
<a href="https://v8.dev/blog/elements-kinds#avoid-creating-holes">https://v8.dev/blog/elements-kinds#avoid-creating-holes</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> laneMap = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-title class_">TotalLanes</span>; i++) {
      laneMap.<span class="hljs-title function_">push</span>(initial);
    }

    <span class="hljs-keyword">return</span> laneMap;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootUpdated</span>(<span class="hljs-params">root, updateLane, eventTime</span>) {
    root.<span class="hljs-property">pendingLanes</span> |= updateLane; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Theoretically, any update to any lane can unblock any other lane. But</span></pre></div></div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-237">&#x00a7;</a>
              </div>
              <p>it’s not practical to try every single possible combination. We need a
heuristic to decide which lanes to attempt to render, and in which batches.
For now, we use the same heuristic as in the old ExpirationTimes model:
retry any lane at equal or lower priority, but don’t try updates at higher
priority without also including the lower priority updates. This works well
when considering updates across different priority levels, but isn’t
sufficient for updates within the same priority, since we want to treat
those updates as parallel.
Unsuspend any update at equal or lower priority.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> higherPriorityLanes = updateLane - <span class="hljs-number">1</span>; <span class="hljs-comment">// Turns 0b1000 into 0b0111</span>

    root.<span class="hljs-property">suspendedLanes</span> &amp;= higherPriorityLanes;
    root.<span class="hljs-property">pingedLanes</span> &amp;= higherPriorityLanes;
    <span class="hljs-keyword">var</span> eventTimes = root.<span class="hljs-property">eventTimes</span>;
    <span class="hljs-keyword">var</span> index = <span class="hljs-title function_">laneToIndex</span>(updateLane); <span class="hljs-comment">// We can always overwrite an existing timestamp because we prefer the most</span></pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-238">&#x00a7;</a>
              </div>
              <p>recent event, and we assume time is monotonically increasing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    eventTimes[index] = eventTime;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootSuspended</span>(<span class="hljs-params">root, suspendedLanes</span>) {
    root.<span class="hljs-property">suspendedLanes</span> |= suspendedLanes;
    root.<span class="hljs-property">pingedLanes</span> &amp;= ~suspendedLanes; <span class="hljs-comment">// The suspended lanes are no longer CPU-bound. Clear their expiration times.</span>

    <span class="hljs-keyword">var</span> expirationTimes = root.<span class="hljs-property">expirationTimes</span>;
    <span class="hljs-keyword">var</span> lanes = suspendedLanes;

    <span class="hljs-keyword">while</span> (lanes &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> index = <span class="hljs-title function_">pickArbitraryLaneIndex</span>(lanes);
      <span class="hljs-keyword">var</span> lane = <span class="hljs-number">1</span> &lt;&lt; index;
      expirationTimes[index] = <span class="hljs-title class_">NoTimestamp</span>;
      lanes &amp;= ~lane;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootPinged</span>(<span class="hljs-params">root, pingedLanes, eventTime</span>) {
    root.<span class="hljs-property">pingedLanes</span> |= root.<span class="hljs-property">suspendedLanes</span> &amp; pingedLanes;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootExpired</span>(<span class="hljs-params">root, expiredLanes</span>) {
    root.<span class="hljs-property">expiredLanes</span> |= expiredLanes &amp; root.<span class="hljs-property">pendingLanes</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markDiscreteUpdatesExpired</span>(<span class="hljs-params">root</span>) {
    root.<span class="hljs-property">expiredLanes</span> |= <span class="hljs-title class_">InputDiscreteLanes</span> &amp; root.<span class="hljs-property">pendingLanes</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasDiscreteLanes</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">return</span> (lanes &amp; <span class="hljs-title class_">InputDiscreteLanes</span>) !== <span class="hljs-title class_">NoLanes</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootMutableRead</span>(<span class="hljs-params">root, updateLane</span>) {
    root.<span class="hljs-property">mutableReadLanes</span> |= updateLane &amp; root.<span class="hljs-property">pendingLanes</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootFinished</span>(<span class="hljs-params">root, remainingLanes</span>) {
    <span class="hljs-keyword">var</span> noLongerPendingLanes = root.<span class="hljs-property">pendingLanes</span> &amp; ~remainingLanes;
    root.<span class="hljs-property">pendingLanes</span> = remainingLanes; <span class="hljs-comment">// Let&#x27;s try everything again</span>

    root.<span class="hljs-property">suspendedLanes</span> = <span class="hljs-number">0</span>;
    root.<span class="hljs-property">pingedLanes</span> = <span class="hljs-number">0</span>;
    root.<span class="hljs-property">expiredLanes</span> &amp;= remainingLanes;
    root.<span class="hljs-property">mutableReadLanes</span> &amp;= remainingLanes;
    root.<span class="hljs-property">entangledLanes</span> &amp;= remainingLanes;
    <span class="hljs-keyword">var</span> entanglements = root.<span class="hljs-property">entanglements</span>;
    <span class="hljs-keyword">var</span> eventTimes = root.<span class="hljs-property">eventTimes</span>;
    <span class="hljs-keyword">var</span> expirationTimes = root.<span class="hljs-property">expirationTimes</span>; <span class="hljs-comment">// Clear the lanes that no longer have pending work</span>

    <span class="hljs-keyword">var</span> lanes = noLongerPendingLanes;

    <span class="hljs-keyword">while</span> (lanes &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> index = <span class="hljs-title function_">pickArbitraryLaneIndex</span>(lanes);
      <span class="hljs-keyword">var</span> lane = <span class="hljs-number">1</span> &lt;&lt; index;
      entanglements[index] = <span class="hljs-title class_">NoLanes</span>;
      eventTimes[index] = <span class="hljs-title class_">NoTimestamp</span>;
      expirationTimes[index] = <span class="hljs-title class_">NoTimestamp</span>;
      lanes &amp;= ~lane;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootEntangled</span>(<span class="hljs-params">root, entangledLanes</span>) {
    root.<span class="hljs-property">entangledLanes</span> |= entangledLanes;
    <span class="hljs-keyword">var</span> entanglements = root.<span class="hljs-property">entanglements</span>;
    <span class="hljs-keyword">var</span> lanes = entangledLanes;

    <span class="hljs-keyword">while</span> (lanes &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> index = <span class="hljs-title function_">pickArbitraryLaneIndex</span>(lanes);
      <span class="hljs-keyword">var</span> lane = <span class="hljs-number">1</span> &lt;&lt; index;
      entanglements[index] |= entangledLanes;
      lanes &amp;= ~lane;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getBumpedLaneForHydration</span>(<span class="hljs-params">root, renderLanes</span>) {
    <span class="hljs-title function_">getHighestPriorityLanes</span>(renderLanes);
    <span class="hljs-keyword">var</span> highestLanePriority = return_highestLanePriority;
    <span class="hljs-keyword">var</span> lane;

    <span class="hljs-keyword">switch</span> (highestLanePriority) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SyncLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SyncBatchedLanePriority</span>:
        lane = <span class="hljs-title class_">NoLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputDiscreteHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputDiscreteLanePriority</span>:
        lane = <span class="hljs-title class_">InputDiscreteHydrationLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputContinuousHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">InputContinuousLanePriority</span>:
        lane = <span class="hljs-title class_">InputContinuousHydrationLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DefaultHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DefaultLanePriority</span>:
        lane = <span class="hljs-title class_">DefaultHydrationLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TransitionHydrationPriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">TransitionPriority</span>:
        lane = <span class="hljs-title class_">TransitionHydrationLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RetryLanePriority</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-239">&#x00a7;</a>
              </div>
              <p>Shouldn’t be reachable under normal circumstances, so there’s no
dedicated lane for retry priority. Use the one for long transitions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        lane = <span class="hljs-title class_">TransitionHydrationLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SelectiveHydrationLanePriority</span>:
        lane = <span class="hljs-title class_">SelectiveHydrationLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdleHydrationLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdleLanePriority</span>:
        lane = <span class="hljs-title class_">IdleHydrationLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenLanePriority</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">NoLanePriority</span>:
        lane = <span class="hljs-title class_">NoLane</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-attr">default</span>:
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid lane: &quot;</span> + lane + <span class="hljs-string">&quot;. This is a bug in React.&quot;</span>);
          }
        }

    } <span class="hljs-comment">// Check if the lane we chose is suspended. If so, that indicates that we</span></pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-240">&#x00a7;</a>
              </div>
              <p>already attempted and failed to hydrate at that level. Also check if we’re
already rendering that lane, which is rare but could happen.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> ((lane &amp; (root.<span class="hljs-property">suspendedLanes</span> | renderLanes)) !== <span class="hljs-title class_">NoLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-241">&#x00a7;</a>
              </div>
              <p>Give up trying to hydrate and fall back to client render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">NoLane</span>;
    }

    <span class="hljs-keyword">return</span> lane;
  }
  <span class="hljs-keyword">var</span> clz32 = <span class="hljs-title class_">Math</span>.<span class="hljs-property">clz32</span> ? <span class="hljs-title class_">Math</span>.<span class="hljs-property">clz32</span> : clz32Fallback; <span class="hljs-comment">// Count leading zeros. Only used on lanes, so assume input is an integer.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-242">&#x00a7;</a>
              </div>
              <p>Based on:
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> log = <span class="hljs-title class_">Math</span>.<span class="hljs-property">log</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LN2</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-property">LN2</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clz32Fallback</span>(<span class="hljs-params">lanes</span>) {
    <span class="hljs-keyword">if</span> (lanes === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">32</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">31</span> - (<span class="hljs-title function_">log</span>(lanes) / <span class="hljs-title class_">LN2</span> | <span class="hljs-number">0</span>) | <span class="hljs-number">0</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-243">&#x00a7;</a>
              </div>
              <p>Intentionally not named imports because Rollup would use dynamic dispatch for</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> <span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">1</span> = unstable_UserBlockingPriority,
    runWithPriority = unstable_runWithPriority; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> can we stop exporting these?</span>

  <span class="hljs-keyword">var</span> _enabled = <span class="hljs-literal">true</span>; <span class="hljs-comment">// This is exported in FB builds for use by legacy FB layer infra.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-244">&#x00a7;</a>
              </div>
              <p>We’d like to remove this but it’s not clear if this is safe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setEnabled</span>(<span class="hljs-params">enabled</span>) {
    _enabled = !!enabled;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isEnabled</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> _enabled;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createEventListenerWrapperWithPriority</span>(<span class="hljs-params">targetContainer, domEventName, eventSystemFlags</span>) {
    <span class="hljs-keyword">var</span> eventPriority = <span class="hljs-title function_">getEventPriorityForPluginSystem</span>(domEventName);
    <span class="hljs-keyword">var</span> listenerWrapper;

    <span class="hljs-keyword">switch</span> (eventPriority) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DiscreteEvent</span>:
        listenerWrapper = dispatchDiscreteEvent;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingEvent</span>:
        listenerWrapper = dispatchUserBlockingUpdate;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContinuousEvent</span>:
      <span class="hljs-attr">default</span>:
        listenerWrapper = dispatchEvent;
        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">return</span> listenerWrapper.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, domEventName, eventSystemFlags, targetContainer);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchDiscreteEvent</span>(<span class="hljs-params">domEventName, eventSystemFlags, container, nativeEvent</span>) {
    {
      <span class="hljs-title function_">flushDiscreteUpdatesIfNeeded</span>(nativeEvent.<span class="hljs-property">timeStamp</span>);
    }

    <span class="hljs-title function_">discreteUpdates</span>(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchUserBlockingUpdate</span>(<span class="hljs-params">domEventName, eventSystemFlags, container, nativeEvent</span>) {
    {
      <span class="hljs-title function_">runWithPriority</span>(<span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">1</span>, dispatchEvent.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, domEventName, eventSystemFlags, container, nativeEvent));
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-params">domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) {
    <span class="hljs-keyword">if</span> (!_enabled) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> allowReplay = <span class="hljs-literal">true</span>;

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-245">&#x00a7;</a>
              </div>
              <p>TODO: replaying capture phase events is currently broken
because we used to do it during top-level native bubble handlers
but now we use different bubble and capture handlers.
In eager mode, we attach capture listeners early, so we need
to filter them out until we fix the logic to handle them correctly.
This could’ve been outside the flag but I put it inside to reduce risk.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      allowReplay = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) === <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">if</span> (allowReplay &amp;&amp; <span class="hljs-title function_">hasQueuedDiscreteEvents</span>() &amp;&amp; <span class="hljs-title function_">isReplayableDiscreteEvent</span>(domEventName)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-246">&#x00a7;</a>
              </div>
              <p>If we already have a queue of discrete events, and this is another discrete
event, then we can’t dispatch it regardless of its target, since they
need to dispatch in order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">queueDiscreteEvent</span>(<span class="hljs-literal">null</span>, <span class="hljs-comment">// Flags that we&#x27;re not actually blocked on anything as far as we know.</span>
        domEventName, eventSystemFlags, targetContainer, nativeEvent);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> blockedOn = <span class="hljs-title function_">attemptToDispatchEvent</span>(domEventName, eventSystemFlags, targetContainer, nativeEvent);

    <span class="hljs-keyword">if</span> (blockedOn === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-247">&#x00a7;</a>
              </div>
              <p>We successfully dispatched this event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (allowReplay) {
        <span class="hljs-title function_">clearIfContinuousEvent</span>(domEventName, nativeEvent);
      }

      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (allowReplay) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isReplayableDiscreteEvent</span>(domEventName)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-248">&#x00a7;</a>
              </div>
              <p>This this to be replayed later once the target is available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">queueDiscreteEvent</span>(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">queueIfContinuousEvent</span>(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// We need to clear only if we didn&#x27;t queue because</span></pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-249">&#x00a7;</a>
              </div>
              <p>queueing is accummulative.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-title function_">clearIfContinuousEvent</span>(domEventName, nativeEvent);
    } <span class="hljs-comment">// This is not replayable so we&#x27;ll invoke it but without a target,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-250">&#x00a7;</a>
              </div>
              <p>in case the event system needs to trace it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-title function_">dispatchEventForPluginEventSystem</span>(domEventName, eventSystemFlags, nativeEvent, <span class="hljs-literal">null</span>, targetContainer);
  } <span class="hljs-comment">// Attempt dispatching an event. Returns a SuspenseInstance or Container if it&#x27;s blocked.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptToDispatchEvent</span>(<span class="hljs-params">domEventName, eventSystemFlags, targetContainer, nativeEvent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-251">&#x00a7;</a>
              </div>
              <p>TODO: Warn if _enabled is false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);
    <span class="hljs-keyword">var</span> targetInst = <span class="hljs-title function_">getClosestInstanceFromNode</span>(nativeEventTarget);

    <span class="hljs-keyword">if</span> (targetInst !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> nearestMounted = <span class="hljs-title function_">getNearestMountedFiber</span>(targetInst);

      <span class="hljs-keyword">if</span> (nearestMounted === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-252">&#x00a7;</a>
              </div>
              <p>This tree has been unmounted already. Dispatch without a target.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        targetInst = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> tag = nearestMounted.<span class="hljs-property">tag</span>;

        <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">SuspenseComponent</span>) {
          <span class="hljs-keyword">var</span> instance = <span class="hljs-title function_">getSuspenseInstanceFromFiber</span>(nearestMounted);

          <span class="hljs-keyword">if</span> (instance !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-253">&#x00a7;</a>
              </div>
              <p>Queue the event to be replayed later. Abort dispatching since we
don’t want this event dispatched twice through the event system.
TODO: If this is the first discrete event in the queue. Schedule an increased
priority for this boundary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> instance;
          } <span class="hljs-comment">// This shouldn&#x27;t happen, something went wrong but to avoid blocking</span></pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-254">&#x00a7;</a>
              </div>
              <p>the whole system, dispatch the event without a target.
TODO: Warn.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          targetInst = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostRoot</span>) {
          <span class="hljs-keyword">var</span> root = nearestMounted.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (root.<span class="hljs-property">hydrate</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-255">&#x00a7;</a>
              </div>
              <p>If this happens during a replay something went wrong and it might block
the whole system.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">getContainerFromFiber</span>(nearestMounted);
          }

          targetInst = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nearestMounted !== targetInst) {</pre></div></div>
            
        </li>
        
        
        <li id="section-256">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-256">&#x00a7;</a>
              </div>
              <p>If we get an event (ex: img onload) before committing that
component’s mount, ignore it for now (that is, treat it as if it was an
event on a non-React tree). We might also consider queueing events and
dispatching them after the mount.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          targetInst = <span class="hljs-literal">null</span>;
        }
      }
    }

    <span class="hljs-title function_">dispatchEventForPluginEventSystem</span>(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); <span class="hljs-comment">// We&#x27;re not blocked on anything.</span>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventBubbleListener</span>(<span class="hljs-params">target, eventType, listener</span>) {
    target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, <span class="hljs-literal">false</span>);
    <span class="hljs-keyword">return</span> listener;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventCaptureListener</span>(<span class="hljs-params">target, eventType, listener</span>) {
    target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">return</span> listener;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventCaptureListenerWithPassiveFlag</span>(<span class="hljs-params">target, eventType, listener, passive</span>) {
    target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, {
      <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">passive</span>: passive
    });
    <span class="hljs-keyword">return</span> listener;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addEventBubbleListenerWithPassiveFlag</span>(<span class="hljs-params">target, eventType, listener, passive</span>) {
    target.<span class="hljs-title function_">addEventListener</span>(eventType, listener, {
      <span class="hljs-attr">passive</span>: passive
    });
    <span class="hljs-keyword">return</span> listener;
  }

  <span class="hljs-comment">/**
   * These variables store information about text content of a target node,
   * allowing comparison of content before and after a given event.
   *
   * Identify the node where selection currently begins, then observe
   * both its text content and its current position in the DOM. Since the
   * browser may natively replace the target node during composition, we can
   * use its position to find its replacement.
   *
   *
   */</span>
  <span class="hljs-keyword">var</span> root = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> startText = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> fallbackText = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">initialize</span>(<span class="hljs-params">nativeEventTarget</span>) {
    root = nativeEventTarget;
    startText = <span class="hljs-title function_">getText</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params"></span>) {
    root = <span class="hljs-literal">null</span>;
    startText = <span class="hljs-literal">null</span>;
    fallbackText = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getData</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (fallbackText) {
      <span class="hljs-keyword">return</span> fallbackText;
    }

    <span class="hljs-keyword">var</span> start;
    <span class="hljs-keyword">var</span> startValue = startText;
    <span class="hljs-keyword">var</span> startLength = startValue.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">var</span> end;
    <span class="hljs-keyword">var</span> endValue = <span class="hljs-title function_">getText</span>();
    <span class="hljs-keyword">var</span> endLength = endValue.<span class="hljs-property">length</span>;

    <span class="hljs-keyword">for</span> (start = <span class="hljs-number">0</span>; start &lt; startLength; start++) {
      <span class="hljs-keyword">if</span> (startValue[start] !== endValue[start]) {
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">var</span> minEnd = startLength - start;

    <span class="hljs-keyword">for</span> (end = <span class="hljs-number">1</span>; end &lt;= minEnd; end++) {
      <span class="hljs-keyword">if</span> (startValue[startLength - end] !== endValue[endLength - end]) {
        <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">var</span> sliceTail = end &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> - end : <span class="hljs-literal">undefined</span>;
    fallbackText = endValue.<span class="hljs-title function_">slice</span>(start, sliceTail);
    <span class="hljs-keyword">return</span> fallbackText;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getText</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;value&#x27;</span> <span class="hljs-keyword">in</span> root) {
      <span class="hljs-keyword">return</span> root.<span class="hljs-property">value</span>;
    }

    <span class="hljs-keyword">return</span> root.<span class="hljs-property">textContent</span>;
  }

  <span class="hljs-comment">/**
   * `charCode` represents the actual &quot;character code&quot; and is safe to use with
   * `String.fromCharCode`. As such, only keys that correspond to printable
   * characters produce a valid `charCode`, the only exception to this is Enter.
   * The Tab-key is considered non-printable and does not have a `charCode`,
   * presumably because it does not produce a tab-character in browsers.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} nativeEvent Native browser event.
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">number</span>} Normalized `charCode` property.
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEventCharCode</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">var</span> charCode;
    <span class="hljs-keyword">var</span> keyCode = nativeEvent.<span class="hljs-property">keyCode</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;charCode&#x27;</span> <span class="hljs-keyword">in</span> nativeEvent) {
      charCode = nativeEvent.<span class="hljs-property">charCode</span>; <span class="hljs-comment">// FF does not set `charCode` for the Enter-key, check against `keyCode`.</span>

      <span class="hljs-keyword">if</span> (charCode === <span class="hljs-number">0</span> &amp;&amp; keyCode === <span class="hljs-number">13</span>) {
        charCode = <span class="hljs-number">13</span>;
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-257">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-257">&#x00a7;</a>
              </div>
              <p>IE8 does not implement <code>charCode</code>, but <code>keyCode</code> has the correct value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      charCode = keyCode;
    } <span class="hljs-comment">// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)</span></pre></div></div>
            
        </li>
        
        
        <li id="section-258">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-258">&#x00a7;</a>
              </div>
              <p>report Enter as charCode 10 when ctrl is pressed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (charCode === <span class="hljs-number">10</span>) {
      charCode = <span class="hljs-number">13</span>;
    } <span class="hljs-comment">// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-259">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-259">&#x00a7;</a>
              </div>
              <p>Must not discard the (non-)printable Enter-key.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (charCode &gt;= <span class="hljs-number">32</span> || charCode === <span class="hljs-number">13</span>) {
      <span class="hljs-keyword">return</span> charCode;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">functionThatReturnsTrue</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">functionThatReturnsFalse</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  } <span class="hljs-comment">// This is intentionally a factory so that we have different returned constructors.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-260">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-260">&#x00a7;</a>
              </div>
              <p>If we had a single constructor, it would be megamorphic and engines would deopt.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-params">Interface</span>) {
    <span class="hljs-comment">/**
     * Synthetic events are dispatched by event plugins, typically in response to a
     * top-level event delegation handler.
     *
     * These systems should generally use pooling to reduce the frequency of garbage
     * collection. The system should check `isPersistent` to determine whether the
     * event should be released into the pool after being dispatched. Users that
     * need a persisted event should invoke `persist`.
     *
     * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
     * normalizing browser quirks. Subclasses do not necessarily have to implement a
     * DOM interface; custom application-specific events can also subclass this.
     */</span>
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">SyntheticBaseEvent</span>(<span class="hljs-params">reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_reactName</span> = reactName;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_targetInst</span> = targetInst;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = reactEventType;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeEvent</span> = nativeEvent;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">target</span> = nativeEventTarget;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentTarget</span> = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _propName <span class="hljs-keyword">in</span> <span class="hljs-title class_">Interface</span>) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Interface</span>.<span class="hljs-title function_">hasOwnProperty</span>(_propName)) {
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">var</span> normalize = <span class="hljs-title class_">Interface</span>[_propName];

        <span class="hljs-keyword">if</span> (normalize) {
          <span class="hljs-variable language_">this</span>[_propName] = <span class="hljs-title function_">normalize</span>(nativeEvent);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-variable language_">this</span>[_propName] = nativeEvent[_propName];
        }
      }

      <span class="hljs-keyword">var</span> defaultPrevented = nativeEvent.<span class="hljs-property">defaultPrevented</span> != <span class="hljs-literal">null</span> ? nativeEvent.<span class="hljs-property">defaultPrevented</span> : nativeEvent.<span class="hljs-property">returnValue</span> === <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (defaultPrevented) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDefaultPrevented</span> = functionThatReturnsTrue;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDefaultPrevented</span> = functionThatReturnsFalse;
      }

      <span class="hljs-variable language_">this</span>.<span class="hljs-property">isPropagationStopped</span> = functionThatReturnsFalse;
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;
    }

    <span class="hljs-title function_">_assign</span>(<span class="hljs-title class_">SyntheticBaseEvent</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, {
      <span class="hljs-attr">preventDefault</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">defaultPrevented</span> = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">var</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeEvent</span>;

        <span class="hljs-keyword">if</span> (!event) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">preventDefault</span>) {
          event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// $FlowFixMe - flow is not aware of `unknown` in IE</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">returnValue</span> !== <span class="hljs-string">&#x27;unknown&#x27;</span>) {
          event.<span class="hljs-property">returnValue</span> = <span class="hljs-literal">false</span>;
        }

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isDefaultPrevented</span> = functionThatReturnsTrue;
      },
      <span class="hljs-attr">stopPropagation</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> event = <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeEvent</span>;

        <span class="hljs-keyword">if</span> (!event) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (event.<span class="hljs-property">stopPropagation</span>) {
          event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// $FlowFixMe - flow is not aware of `unknown` in IE</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.<span class="hljs-property">cancelBubble</span> !== <span class="hljs-string">&#x27;unknown&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-261">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-261">&#x00a7;</a>
              </div>
              <p>The ChangeEventPlugin registers a “propertychange” event for
IE. This event does not support bubbling or cancelling, and
any references to cancelBubble throw “Member not found”.  A
typeof check of “unknown” circumvents this issue (and is also
IE specific).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          event.<span class="hljs-property">cancelBubble</span> = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-variable language_">this</span>.<span class="hljs-property">isPropagationStopped</span> = functionThatReturnsTrue;
      },

      <span class="hljs-comment">/**
       * We release all dispatched `SyntheticEvent`s after each event loop, adding
       * them back into the pool. This allows a way to hold onto a reference that
       * won&#x27;t be added back into the pool.
       */</span>
      <span class="hljs-attr">persist</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<span class="hljs-comment">// Modern event system doesn&#x27;t use pooling.</span>
      },

      <span class="hljs-comment">/**
       * Checks if this event should be released back into the pool.
       *
       * <span class="hljs-doctag">@return</span> {<span class="hljs-type">boolean</span>} True if this should not be released, false otherwise.
       */</span>
      <span class="hljs-attr">isPersistent</span>: functionThatReturnsTrue
    });

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyntheticBaseEvent</span>;
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">Event</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/
   */</span>


  <span class="hljs-keyword">var</span> <span class="hljs-title class_">EventInterface</span> = {
    <span class="hljs-attr">eventPhase</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">bubbles</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">cancelable</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">timeStamp</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">return</span> event.<span class="hljs-property">timeStamp</span> || <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();
    },
    <span class="hljs-attr">defaultPrevented</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">isTrusted</span>: <span class="hljs-number">0</span>
  };
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">EventInterface</span>);

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">UIEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">EventInterface</span>, {
    <span class="hljs-attr">view</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">detail</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Synthetic</span>UIEvent = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">UIEventInterface</span>);
  <span class="hljs-keyword">var</span> lastMovementX;
  <span class="hljs-keyword">var</span> lastMovementY;
  <span class="hljs-keyword">var</span> lastMouseEvent;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateMouseMovementPolyfillState</span>(<span class="hljs-params">event</span>) {
    <span class="hljs-keyword">if</span> (event !== lastMouseEvent) {
      <span class="hljs-keyword">if</span> (lastMouseEvent &amp;&amp; event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;mousemove&#x27;</span>) {
        lastMovementX = event.<span class="hljs-property">screenX</span> - lastMouseEvent.<span class="hljs-property">screenX</span>;
        lastMovementY = event.<span class="hljs-property">screenY</span> - lastMouseEvent.<span class="hljs-property">screenY</span>;
      } <span class="hljs-keyword">else</span> {
        lastMovementX = <span class="hljs-number">0</span>;
        lastMovementY = <span class="hljs-number">0</span>;
      }

      lastMouseEvent = event;
    }
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">MouseEvent</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/
   */</span>


  <span class="hljs-keyword">var</span> <span class="hljs-title class_">MouseEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">UIEventInterface</span>, {
    <span class="hljs-attr">screenX</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">screenY</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">clientX</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">clientY</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">pageX</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">pageY</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">ctrlKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">shiftKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">altKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">metaKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">getModifierState</span>: getEventModifierState,
    <span class="hljs-attr">button</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">buttons</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">relatedTarget</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">relatedTarget</span> === <span class="hljs-literal">undefined</span>) <span class="hljs-keyword">return</span> event.<span class="hljs-property">fromElement</span> === event.<span class="hljs-property">srcElement</span> ? event.<span class="hljs-property">toElement</span> : event.<span class="hljs-property">fromElement</span>;
      <span class="hljs-keyword">return</span> event.<span class="hljs-property">relatedTarget</span>;
    },
    <span class="hljs-attr">movementX</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;movementX&#x27;</span> <span class="hljs-keyword">in</span> event) {
        <span class="hljs-keyword">return</span> event.<span class="hljs-property">movementX</span>;
      }

      <span class="hljs-title function_">updateMouseMovementPolyfillState</span>(event);
      <span class="hljs-keyword">return</span> lastMovementX;
    },
    <span class="hljs-attr">movementY</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;movementY&#x27;</span> <span class="hljs-keyword">in</span> event) {
        <span class="hljs-keyword">return</span> event.<span class="hljs-property">movementY</span>;
      } <span class="hljs-comment">// Don&#x27;t need to call updateMouseMovementPolyfillState() here</span></pre></div></div>
            
        </li>
        
        
        <li id="section-262">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-262">&#x00a7;</a>
              </div>
              <p>because it’s guaranteed to have already run when movementX
was copied.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">return</span> lastMovementY;
    }
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticMouseEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">MouseEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">DragEvent</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DragEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">MouseEventInterface</span>, {
    <span class="hljs-attr">dataTransfer</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticDragEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">DragEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">FocusEvent</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">FocusEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">UIEventInterface</span>, {
    <span class="hljs-attr">relatedTarget</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticFocusEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">FocusEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">Event</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
   * <span class="hljs-doctag">@see</span> https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">AnimationEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">EventInterface</span>, {
    <span class="hljs-attr">animationName</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">elapsedTime</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">pseudoElement</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticAnimationEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">AnimationEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">Event</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/clipboard-apis/
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ClipboardEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">EventInterface</span>, {
    <span class="hljs-attr">clipboardData</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;clipboardData&#x27;</span> <span class="hljs-keyword">in</span> event ? event.<span class="hljs-property">clipboardData</span> : <span class="hljs-variable language_">window</span>.<span class="hljs-property">clipboardData</span>;
    }
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticClipboardEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">ClipboardEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">Event</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">CompositionEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">EventInterface</span>, {
    <span class="hljs-attr">data</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticCompositionEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">CompositionEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">Event</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
   *      /#events-inputevents
   */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-263">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-263">&#x00a7;</a>
              </div>
              <p>Happens to share the same list for now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticInputEvent</span> = <span class="hljs-title class_">SyntheticCompositionEvent</span>;
  <span class="hljs-comment">/**
   * Normalization of deprecated HTML5 `key` values
   * <span class="hljs-doctag">@see</span> https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */</span>

  <span class="hljs-keyword">var</span> normalizeKey = {
    <span class="hljs-title class_">Esc</span>: <span class="hljs-string">&#x27;Escape&#x27;</span>,
    <span class="hljs-title class_">Spacebar</span>: <span class="hljs-string">&#x27; &#x27;</span>,
    <span class="hljs-title class_">Left</span>: <span class="hljs-string">&#x27;ArrowLeft&#x27;</span>,
    <span class="hljs-title class_">Up</span>: <span class="hljs-string">&#x27;ArrowUp&#x27;</span>,
    <span class="hljs-title class_">Right</span>: <span class="hljs-string">&#x27;ArrowRight&#x27;</span>,
    <span class="hljs-title class_">Down</span>: <span class="hljs-string">&#x27;ArrowDown&#x27;</span>,
    <span class="hljs-title class_">Del</span>: <span class="hljs-string">&#x27;Delete&#x27;</span>,
    <span class="hljs-title class_">Win</span>: <span class="hljs-string">&#x27;OS&#x27;</span>,
    <span class="hljs-title class_">Menu</span>: <span class="hljs-string">&#x27;ContextMenu&#x27;</span>,
    <span class="hljs-title class_">Apps</span>: <span class="hljs-string">&#x27;ContextMenu&#x27;</span>,
    <span class="hljs-title class_">Scroll</span>: <span class="hljs-string">&#x27;ScrollLock&#x27;</span>,
    <span class="hljs-title class_">MozPrintableKey</span>: <span class="hljs-string">&#x27;Unidentified&#x27;</span>
  };
  <span class="hljs-comment">/**
   * Translation from legacy `keyCode` to HTML5 `key`
   * Only special keys supported, all others depend on keyboard layout or browser
   * <span class="hljs-doctag">@see</span> https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
   */</span>

  <span class="hljs-keyword">var</span> translateToKey = {
    <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-string">&#x27;Backspace&#x27;</span>,
    <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-string">&#x27;Tab&#x27;</span>,
    <span class="hljs-string">&#x27;12&#x27;</span>: <span class="hljs-string">&#x27;Clear&#x27;</span>,
    <span class="hljs-string">&#x27;13&#x27;</span>: <span class="hljs-string">&#x27;Enter&#x27;</span>,
    <span class="hljs-string">&#x27;16&#x27;</span>: <span class="hljs-string">&#x27;Shift&#x27;</span>,
    <span class="hljs-string">&#x27;17&#x27;</span>: <span class="hljs-string">&#x27;Control&#x27;</span>,
    <span class="hljs-string">&#x27;18&#x27;</span>: <span class="hljs-string">&#x27;Alt&#x27;</span>,
    <span class="hljs-string">&#x27;19&#x27;</span>: <span class="hljs-string">&#x27;Pause&#x27;</span>,
    <span class="hljs-string">&#x27;20&#x27;</span>: <span class="hljs-string">&#x27;CapsLock&#x27;</span>,
    <span class="hljs-string">&#x27;27&#x27;</span>: <span class="hljs-string">&#x27;Escape&#x27;</span>,
    <span class="hljs-string">&#x27;32&#x27;</span>: <span class="hljs-string">&#x27; &#x27;</span>,
    <span class="hljs-string">&#x27;33&#x27;</span>: <span class="hljs-string">&#x27;PageUp&#x27;</span>,
    <span class="hljs-string">&#x27;34&#x27;</span>: <span class="hljs-string">&#x27;PageDown&#x27;</span>,
    <span class="hljs-string">&#x27;35&#x27;</span>: <span class="hljs-string">&#x27;End&#x27;</span>,
    <span class="hljs-string">&#x27;36&#x27;</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,
    <span class="hljs-string">&#x27;37&#x27;</span>: <span class="hljs-string">&#x27;ArrowLeft&#x27;</span>,
    <span class="hljs-string">&#x27;38&#x27;</span>: <span class="hljs-string">&#x27;ArrowUp&#x27;</span>,
    <span class="hljs-string">&#x27;39&#x27;</span>: <span class="hljs-string">&#x27;ArrowRight&#x27;</span>,
    <span class="hljs-string">&#x27;40&#x27;</span>: <span class="hljs-string">&#x27;ArrowDown&#x27;</span>,
    <span class="hljs-string">&#x27;45&#x27;</span>: <span class="hljs-string">&#x27;Insert&#x27;</span>,
    <span class="hljs-string">&#x27;46&#x27;</span>: <span class="hljs-string">&#x27;Delete&#x27;</span>,
    <span class="hljs-string">&#x27;112&#x27;</span>: <span class="hljs-string">&#x27;F1&#x27;</span>,
    <span class="hljs-string">&#x27;113&#x27;</span>: <span class="hljs-string">&#x27;F2&#x27;</span>,
    <span class="hljs-string">&#x27;114&#x27;</span>: <span class="hljs-string">&#x27;F3&#x27;</span>,
    <span class="hljs-string">&#x27;115&#x27;</span>: <span class="hljs-string">&#x27;F4&#x27;</span>,
    <span class="hljs-string">&#x27;116&#x27;</span>: <span class="hljs-string">&#x27;F5&#x27;</span>,
    <span class="hljs-string">&#x27;117&#x27;</span>: <span class="hljs-string">&#x27;F6&#x27;</span>,
    <span class="hljs-string">&#x27;118&#x27;</span>: <span class="hljs-string">&#x27;F7&#x27;</span>,
    <span class="hljs-string">&#x27;119&#x27;</span>: <span class="hljs-string">&#x27;F8&#x27;</span>,
    <span class="hljs-string">&#x27;120&#x27;</span>: <span class="hljs-string">&#x27;F9&#x27;</span>,
    <span class="hljs-string">&#x27;121&#x27;</span>: <span class="hljs-string">&#x27;F10&#x27;</span>,
    <span class="hljs-string">&#x27;122&#x27;</span>: <span class="hljs-string">&#x27;F11&#x27;</span>,
    <span class="hljs-string">&#x27;123&#x27;</span>: <span class="hljs-string">&#x27;F12&#x27;</span>,
    <span class="hljs-string">&#x27;144&#x27;</span>: <span class="hljs-string">&#x27;NumLock&#x27;</span>,
    <span class="hljs-string">&#x27;145&#x27;</span>: <span class="hljs-string">&#x27;ScrollLock&#x27;</span>,
    <span class="hljs-string">&#x27;224&#x27;</span>: <span class="hljs-string">&#x27;Meta&#x27;</span>
  };
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} nativeEvent Native browser event.
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">string</span>} Normalized `key` property.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEventKey</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">key</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-264">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-264">&#x00a7;</a>
              </div>
              <p>Normalize inconsistent values reported by browsers due to
implementations of a working draft specification.
FireFox implements <code>key</code> but returns <code>MozPrintableKey</code> for all
printable characters (normalized to <code>Unidentified</code>), ignore it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> key = normalizeKey[nativeEvent.<span class="hljs-property">key</span>] || nativeEvent.<span class="hljs-property">key</span>;

      <span class="hljs-keyword">if</span> (key !== <span class="hljs-string">&#x27;Unidentified&#x27;</span>) {
        <span class="hljs-keyword">return</span> key;
      }
    } <span class="hljs-comment">// Browser does not implement `key`, polyfill as much of it as we can.</span>


    <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keypress&#x27;</span>) {
      <span class="hljs-keyword">var</span> charCode = <span class="hljs-title function_">getEventCharCode</span>(nativeEvent); <span class="hljs-comment">// The enter-key is technically both printable and non-printable and can</span></pre></div></div>
            
        </li>
        
        
        <li id="section-265">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-265">&#x00a7;</a>
              </div>
              <p>thus be captured by <code>keypress</code>, no other non-printable key should.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">return</span> charCode === <span class="hljs-number">13</span> ? <span class="hljs-string">&#x27;Enter&#x27;</span> : <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(charCode);
    }

    <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keydown&#x27;</span> || nativeEvent.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keyup&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-266">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-266">&#x00a7;</a>
              </div>
              <p>While user keyboard layout determines the actual meaning of each
<code>keyCode</code> value, almost all function keys have a universal value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> translateToKey[nativeEvent.<span class="hljs-property">keyCode</span>] || <span class="hljs-string">&#x27;Unidentified&#x27;</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
  }
  <span class="hljs-comment">/**
   * Translation from modifier key to the associated property in the event.
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
   */</span>


  <span class="hljs-keyword">var</span> modifierKeyToProp = {
    <span class="hljs-title class_">Alt</span>: <span class="hljs-string">&#x27;altKey&#x27;</span>,
    <span class="hljs-title class_">Control</span>: <span class="hljs-string">&#x27;ctrlKey&#x27;</span>,
    <span class="hljs-title class_">Meta</span>: <span class="hljs-string">&#x27;metaKey&#x27;</span>,
    <span class="hljs-title class_">Shift</span>: <span class="hljs-string">&#x27;shiftKey&#x27;</span>
  }; <span class="hljs-comment">// Older browsers (Safari &lt;= 10, iOS Safari &lt;= 10.2) do not support</span></pre></div></div>
            
        </li>
        
        
        <li id="section-267">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-267">&#x00a7;</a>
              </div>
              <p>getModifierState. If getModifierState is not supported, we map it to a set of
modifier keys exposed by the event. In this case, Lock-keys are not supported.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">modifierStateGetter</span>(<span class="hljs-params">keyArg</span>) {
    <span class="hljs-keyword">var</span> syntheticEvent = <span class="hljs-variable language_">this</span>;
    <span class="hljs-keyword">var</span> nativeEvent = syntheticEvent.<span class="hljs-property">nativeEvent</span>;

    <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">getModifierState</span>) {
      <span class="hljs-keyword">return</span> nativeEvent.<span class="hljs-title function_">getModifierState</span>(keyArg);
    }

    <span class="hljs-keyword">var</span> keyProp = modifierKeyToProp[keyArg];
    <span class="hljs-keyword">return</span> keyProp ? !!nativeEvent[keyProp] : <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEventModifierState</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">return</span> modifierStateGetter;
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">KeyboardEvent</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/
   */</span>


  <span class="hljs-keyword">var</span> <span class="hljs-title class_">KeyboardEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">UIEventInterface</span>, {
    <span class="hljs-attr">key</span>: getEventKey,
    <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">location</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">ctrlKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">shiftKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">altKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">metaKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">repeat</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">locale</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">getModifierState</span>: getEventModifierState,</pre></div></div>
            
        </li>
        
        
        <li id="section-268">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-268">&#x00a7;</a>
              </div>
              <p>Legacy Interface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-attr">charCode</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-269">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-269">&#x00a7;</a>
              </div>
              <p><code>charCode</code> is the result of a KeyPress event and represents the value of
the actual printable character.
KeyPress is deprecated, but its replacement is not yet final and not
implemented in any major browser. Only KeyPress has charCode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keypress&#x27;</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getEventCharCode</span>(event);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    },
    <span class="hljs-attr">keyCode</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-270">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-270">&#x00a7;</a>
              </div>
              <p><code>keyCode</code> is the result of a KeyDown/Up event and represents the value of
physical keyboard key.
The actual meaning of the value depends on the users’ keyboard layout
which cannot be detected. Assuming that it is a US keyboard layout
provides a surprisingly accurate mapping for US and European users.
Due to this, it is left to the user to implement at this time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keydown&#x27;</span> || event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keyup&#x27;</span>) {
        <span class="hljs-keyword">return</span> event.<span class="hljs-property">keyCode</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    },
    <span class="hljs-attr">which</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-271">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-271">&#x00a7;</a>
              </div>
              <p><code>which</code> is an alias for either <code>keyCode</code> or <code>charCode</code> depending on the
type of the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keypress&#x27;</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getEventCharCode</span>(event);
      }

      <span class="hljs-keyword">if</span> (event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keydown&#x27;</span> || event.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;keyup&#x27;</span>) {
        <span class="hljs-keyword">return</span> event.<span class="hljs-property">keyCode</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticKeyboardEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">KeyboardEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">PointerEvent</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/pointerevents/
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">PointerEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">MouseEventInterface</span>, {
    <span class="hljs-attr">pointerId</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">pressure</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">tangentialPressure</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">tiltX</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">tiltY</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">twist</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">pointerType</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">isPrimary</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticPointerEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">PointerEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">TouchEvent</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/touch-events/
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">TouchEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">UIEventInterface</span>, {
    <span class="hljs-attr">touches</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">targetTouches</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">changedTouches</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">altKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">metaKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">ctrlKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">shiftKey</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">getModifierState</span>: getEventModifierState
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticTouchEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">TouchEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">Event</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
   * <span class="hljs-doctag">@see</span> https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">TransitionEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">EventInterface</span>, {
    <span class="hljs-attr">propertyName</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">elapsedTime</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">pseudoElement</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticTransitionEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">TransitionEventInterface</span>);
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@interface</span> <span class="hljs-variable">WheelEvent</span>
   * <span class="hljs-doctag">@see</span> http://www.w3.org/TR/DOM-Level-3-Events/
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">WheelEventInterface</span> = <span class="hljs-title function_">_assign</span>({}, <span class="hljs-title class_">MouseEventInterface</span>, {
    <span class="hljs-attr">deltaX</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;deltaX&#x27;</span> <span class="hljs-keyword">in</span> event ? event.<span class="hljs-property">deltaX</span> : <span class="hljs-comment">// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).</span>
        <span class="hljs-string">&#x27;wheelDeltaX&#x27;</span> <span class="hljs-keyword">in</span> event ? -event.<span class="hljs-property">wheelDeltaX</span> : <span class="hljs-number">0</span>;
    },
    <span class="hljs-attr">deltaY</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;deltaY&#x27;</span> <span class="hljs-keyword">in</span> event ? event.<span class="hljs-property">deltaY</span> : <span class="hljs-comment">// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).</span>
        <span class="hljs-string">&#x27;wheelDeltaY&#x27;</span> <span class="hljs-keyword">in</span> event ? -event.<span class="hljs-property">wheelDeltaY</span> : <span class="hljs-comment">// Fallback to `wheelDelta` for IE&lt;9 and normalize (down is positive).</span>
          <span class="hljs-string">&#x27;wheelDelta&#x27;</span> <span class="hljs-keyword">in</span> event ? -event.<span class="hljs-property">wheelDelta</span> : <span class="hljs-number">0</span>;
    },
    <span class="hljs-attr">deltaZ</span>: <span class="hljs-number">0</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-272">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-272">&#x00a7;</a>
              </div>
              <p>Browsers without “deltaMode” is reporting in raw wheel delta where one
notch on the scroll is always +/- 120, roughly equivalent to pixels.
A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-attr">deltaMode</span>: <span class="hljs-number">0</span>
  });

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticWheelEvent</span> = <span class="hljs-title function_">createSyntheticEvent</span>(<span class="hljs-title class_">WheelEventInterface</span>);

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">END_KEYCODES</span> = [<span class="hljs-number">9</span>, <span class="hljs-number">13</span>, <span class="hljs-number">27</span>, <span class="hljs-number">32</span>]; <span class="hljs-comment">// Tab, Return, Esc, Space</span>

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">START_KEYCODE</span> = <span class="hljs-number">229</span>;
  <span class="hljs-keyword">var</span> canUseCompositionEvent = canUseDOM &amp;&amp; <span class="hljs-string">&#x27;CompositionEvent&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span>;
  <span class="hljs-keyword">var</span> documentMode = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">if</span> (canUseDOM &amp;&amp; <span class="hljs-string">&#x27;documentMode&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">document</span>) {
    documentMode = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentMode</span>;
  } <span class="hljs-comment">// Webkit offers a very useful `textInput` event that can be used to</span></pre></div></div>
            
        </li>
        
        
        <li id="section-273">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-273">&#x00a7;</a>
              </div>
              <p>directly represent <code>beforeInput</code>. The IE <code>textinput</code> event is not as
useful, so we don’t use it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">var</span> canUseTextInputEvent = canUseDOM &amp;&amp; <span class="hljs-string">&#x27;TextEvent&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">window</span> &amp;&amp; !documentMode; <span class="hljs-comment">// In IE9+, we have access to composition events, but the data supplied</span></pre></div></div>
            
        </li>
        
        
        <li id="section-274">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-274">&#x00a7;</a>
              </div>
              <p>by the native compositionend event may be incorrect. Japanese ideographic
spaces, for instance (\u3000) are not recorded correctly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> useFallbackCompositionData = canUseDOM &amp;&amp; (!canUseCompositionEvent || documentMode &amp;&amp; documentMode &gt; <span class="hljs-number">8</span> &amp;&amp; documentMode &lt;= <span class="hljs-number">11</span>);
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SPACEBAR_CODE</span> = <span class="hljs-number">32</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SPACEBAR_CHAR</span> = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(<span class="hljs-variable constant_">SPACEBAR_CODE</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerEvents</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">registerTwoPhaseEvent</span>(<span class="hljs-string">&#x27;onBeforeInput&#x27;</span>, [<span class="hljs-string">&#x27;compositionend&#x27;</span>, <span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-string">&#x27;textInput&#x27;</span>, <span class="hljs-string">&#x27;paste&#x27;</span>]);
    <span class="hljs-title function_">registerTwoPhaseEvent</span>(<span class="hljs-string">&#x27;onCompositionEnd&#x27;</span>, [<span class="hljs-string">&#x27;compositionend&#x27;</span>, <span class="hljs-string">&#x27;focusout&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;mousedown&#x27;</span>]);
    <span class="hljs-title function_">registerTwoPhaseEvent</span>(<span class="hljs-string">&#x27;onCompositionStart&#x27;</span>, [<span class="hljs-string">&#x27;compositionstart&#x27;</span>, <span class="hljs-string">&#x27;focusout&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;mousedown&#x27;</span>]);
    <span class="hljs-title function_">registerTwoPhaseEvent</span>(<span class="hljs-string">&#x27;onCompositionUpdate&#x27;</span>, [<span class="hljs-string">&#x27;compositionupdate&#x27;</span>, <span class="hljs-string">&#x27;focusout&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keypress&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;mousedown&#x27;</span>]);
  } <span class="hljs-comment">// Track whether we&#x27;ve ever handled a keypress on the space key.</span>


  <span class="hljs-keyword">var</span> hasSpaceKeypress = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">/**
   * Return whether a native keypress event is assumed to be a command.
   * This is required because Firefox fires `keypress` events for key commands
   * (cut, copy, select-all, etc.) even though no character is inserted.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isKeypressCommand</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">return</span> (nativeEvent.<span class="hljs-property">ctrlKey</span> || nativeEvent.<span class="hljs-property">altKey</span> || nativeEvent.<span class="hljs-property">metaKey</span>) &amp;&amp; <span class="hljs-comment">// ctrlKey &amp;&amp; altKey is equivalent to AltGr, and is not a command.</span>
      !(nativeEvent.<span class="hljs-property">ctrlKey</span> &amp;&amp; nativeEvent.<span class="hljs-property">altKey</span>);
  }
  <span class="hljs-comment">/**
   * Translate native top level events into event types.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCompositionEventType</span>(<span class="hljs-params">domEventName</span>) {
    <span class="hljs-keyword">switch</span> (domEventName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;compositionstart&#x27;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;onCompositionStart&#x27;</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;compositionend&#x27;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;onCompositionEnd&#x27;</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;compositionupdate&#x27;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;onCompositionUpdate&#x27;</span>;
    }
  }
  <span class="hljs-comment">/**
   * Does our fallback best-guess model think this event signifies that
   * composition has begun?
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isFallbackCompositionStart</span>(<span class="hljs-params">domEventName, nativeEvent</span>) {
    <span class="hljs-keyword">return</span> domEventName === <span class="hljs-string">&#x27;keydown&#x27;</span> &amp;&amp; nativeEvent.<span class="hljs-property">keyCode</span> === <span class="hljs-variable constant_">START_KEYCODE</span>;
  }
  <span class="hljs-comment">/**
   * Does our fallback mode think that this event is the end of composition?
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isFallbackCompositionEnd</span>(<span class="hljs-params">domEventName, nativeEvent</span>) {
    <span class="hljs-keyword">switch</span> (domEventName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keyup&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-275">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-275">&#x00a7;</a>
              </div>
              <p>Command keys insert or clear IME input.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">END_KEYCODES</span>.<span class="hljs-title function_">indexOf</span>(nativeEvent.<span class="hljs-property">keyCode</span>) !== -<span class="hljs-number">1</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keydown&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-276">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-276">&#x00a7;</a>
              </div>
              <p>Expect IME keyCode on each keydown. If we get any other
code we must have exited earlier.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> nativeEvent.<span class="hljs-property">keyCode</span> !== <span class="hljs-variable constant_">START_KEYCODE</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keypress&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mousedown&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusout&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-277">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-277">&#x00a7;</a>
              </div>
              <p>Events are not possible without cancelling IME.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-comment">/**
   * Google Input Tools provides composition data via a CustomEvent,
   * with the `data` property populated in the `detail` object. If this
   * is available on the event object, use it. If not, this is a plain
   * composition event and we have nothing special to extract.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">nativeEvent</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?string</span>}
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getDataFromCustomEvent</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">var</span> detail = nativeEvent.<span class="hljs-property">detail</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> detail === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;data&#x27;</span> <span class="hljs-keyword">in</span> detail) {
      <span class="hljs-keyword">return</span> detail.<span class="hljs-property">data</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">/**
   * Check if a composition event was triggered by Korean IME.
   * Our fallback mode does not work well with IE&#x27;s Korean IME,
   * so just use native composition events when Korean IME is used.
   * Although CompositionEvent.locale property is deprecated,
   * it is available in IE, where our fallback mode is enabled.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">nativeEvent</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">boolean</span>}
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isUsingKoreanIME</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">return</span> nativeEvent.<span class="hljs-property">locale</span> === <span class="hljs-string">&#x27;ko&#x27;</span>;
  } <span class="hljs-comment">// Track the current IME composition status, if any.</span>


  <span class="hljs-keyword">var</span> isComposing = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?object</span>} A SyntheticCompositionEvent.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractCompositionEvent</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget</span>) {
    <span class="hljs-keyword">var</span> eventType;
    <span class="hljs-keyword">var</span> fallbackData;

    <span class="hljs-keyword">if</span> (canUseCompositionEvent) {
      eventType = <span class="hljs-title function_">getCompositionEventType</span>(domEventName);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isComposing) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFallbackCompositionStart</span>(domEventName, nativeEvent)) {
        eventType = <span class="hljs-string">&#x27;onCompositionStart&#x27;</span>;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isFallbackCompositionEnd</span>(domEventName, nativeEvent)) {
      eventType = <span class="hljs-string">&#x27;onCompositionEnd&#x27;</span>;
    }

    <span class="hljs-keyword">if</span> (!eventType) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (useFallbackCompositionData &amp;&amp; !<span class="hljs-title function_">isUsingKoreanIME</span>(nativeEvent)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-278">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-278">&#x00a7;</a>
              </div>
              <p>The current composition is stored statically and must not be
overwritten while composition continues.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!isComposing &amp;&amp; eventType === <span class="hljs-string">&#x27;onCompositionStart&#x27;</span>) {
        isComposing = <span class="hljs-title function_">initialize</span>(nativeEventTarget);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (eventType === <span class="hljs-string">&#x27;onCompositionEnd&#x27;</span>) {
        <span class="hljs-keyword">if</span> (isComposing) {
          fallbackData = <span class="hljs-title function_">getData</span>();
        }
      }
    }

    <span class="hljs-keyword">var</span> listeners = <span class="hljs-title function_">accumulateTwoPhaseListeners</span>(targetInst, eventType);

    <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticCompositionEvent</span>(eventType, domEventName, <span class="hljs-literal">null</span>, nativeEvent, nativeEventTarget);
      dispatchQueue.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">event</span>: event,
        <span class="hljs-attr">listeners</span>: listeners
      });

      <span class="hljs-keyword">if</span> (fallbackData) {</pre></div></div>
            
        </li>
        
        
        <li id="section-279">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-279">&#x00a7;</a>
              </div>
              <p>Inject data generated from fallback path into the synthetic event.
This matches the property of native CompositionEventInterface.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        event.<span class="hljs-property">data</span> = fallbackData;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> customData = <span class="hljs-title function_">getDataFromCustomEvent</span>(nativeEvent);

        <span class="hljs-keyword">if</span> (customData !== <span class="hljs-literal">null</span>) {
          event.<span class="hljs-property">data</span> = customData;
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNativeBeforeInputChars</span>(<span class="hljs-params">domEventName, nativeEvent</span>) {
    <span class="hljs-keyword">switch</span> (domEventName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;compositionend&#x27;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getDataFromCustomEvent</span>(nativeEvent);

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keypress&#x27;</span>:
        <span class="hljs-comment">/**
         * If native `textInput` events are available, our goal is to make
         * use of them. However, there is a special case: the spacebar key.
         * In Webkit, preventing default on a spacebar `textInput` event
         * cancels character insertion, but it *also* causes the browser
         * to fall back to its default spacebar behavior of scrolling the
         * page.
         *
         * Tracking at:
         * https://code.google.com/p/chromium/issues/detail?id=355103
         *
         * To avoid this issue, use the keypress event as if no `textInput`
         * event is available.
         */</span>
        <span class="hljs-keyword">var</span> which = nativeEvent.<span class="hljs-property">which</span>;

        <span class="hljs-keyword">if</span> (which !== <span class="hljs-variable constant_">SPACEBAR_CODE</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        hasSpaceKeypress = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">SPACEBAR_CHAR</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textInput&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-280">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-280">&#x00a7;</a>
              </div>
              <p>Record the characters to be added to the DOM.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> chars = nativeEvent.<span class="hljs-property">data</span>; <span class="hljs-comment">// If it&#x27;s a spacebar character, assume that we have already handled</span></pre></div></div>
            
        </li>
        
        
        <li id="section-281">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-281">&#x00a7;</a>
              </div>
              <p>it at the keypress level and bail immediately. Android Chrome
doesn’t give us keycodes, so we need to ignore it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (chars === <span class="hljs-variable constant_">SPACEBAR_CHAR</span> &amp;&amp; hasSpaceKeypress) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> chars;

      <span class="hljs-attr">default</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-282">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-282">&#x00a7;</a>
              </div>
              <p>For other native event types, do nothing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }
  <span class="hljs-comment">/**
   * For browsers that do not provide the `textInput` event, extract the
   * appropriate string to use for SyntheticInputEvent.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFallbackBeforeInputChars</span>(<span class="hljs-params">domEventName, nativeEvent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-283">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-283">&#x00a7;</a>
              </div>
              <p>If we are currently composing (IME) and using a fallback to do so,
try to extract the composed characters from the fallback object.
If composition event is available, we extract a string only at
compositionevent, otherwise extract it at fallback events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (isComposing) {
      <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;compositionend&#x27;</span> || !canUseCompositionEvent &amp;&amp; <span class="hljs-title function_">isFallbackCompositionEnd</span>(domEventName, nativeEvent)) {
        <span class="hljs-keyword">var</span> chars = <span class="hljs-title function_">getData</span>();
        <span class="hljs-title function_">reset</span>();
        isComposing = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> chars;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">switch</span> (domEventName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;paste&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-284">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-284">&#x00a7;</a>
              </div>
              <p>If a paste event occurs after a keypress, throw out the input
chars. Paste events should not lead to BeforeInput events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keypress&#x27;</span>:
        <span class="hljs-comment">/**
         * As of v27, Firefox may fire keypress events even when no character
         * will be inserted. A few possibilities:
         *
         * - `which` is `0`. Arrow keys, Esc key, etc.
         *
         * - `which` is the pressed key code, but no char is available.
         *   Ex: &#x27;AltGr + d` in Polish. There is no modified character for
         *   this key combination and no character is inserted into the
         *   document, but FF fires the keypress for char code `100` anyway.
         *   No `input` event will occur.
         *
         * - `which` is the pressed key code, but a command combination is
         *   being used. Ex: `Cmd+C`. No character is inserted, and no
         *   `input` event will occur.
         */</span>
        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isKeypressCommand</span>(nativeEvent)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-285">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-285">&#x00a7;</a>
              </div>
              <p>IE fires the <code>keypress</code> event when a user types an emoji via
Touch keyboard of Windows.  In such a case, the <code>char</code> property
holds an emoji character like <code>\uD83D\uDE0A</code>.  Because its length
is 2, the property <code>which</code> does not represent an emoji correctly.
In such a case, we directly return the <code>char</code> property instead of
using <code>which</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">char</span> &amp;&amp; nativeEvent.<span class="hljs-property">char</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> nativeEvent.<span class="hljs-property">char</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">which</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>(nativeEvent.<span class="hljs-property">which</span>);
          }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;compositionend&#x27;</span>:
        <span class="hljs-keyword">return</span> useFallbackCompositionData &amp;&amp; !<span class="hljs-title function_">isUsingKoreanIME</span>(nativeEvent) ? <span class="hljs-literal">null</span> : nativeEvent.<span class="hljs-property">data</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }
  <span class="hljs-comment">/**
   * Extract a SyntheticInputEvent for `beforeInput`, based on either native
   * `textInput` or fallback behavior.
   *
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?object</span>} A SyntheticInputEvent.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractBeforeInputEvent</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget</span>) {
    <span class="hljs-keyword">var</span> chars;

    <span class="hljs-keyword">if</span> (canUseTextInputEvent) {
      chars = <span class="hljs-title function_">getNativeBeforeInputChars</span>(domEventName, nativeEvent);
    } <span class="hljs-keyword">else</span> {
      chars = <span class="hljs-title function_">getFallbackBeforeInputChars</span>(domEventName, nativeEvent);
    } <span class="hljs-comment">// If no characters are being inserted, no BeforeInput event should</span></pre></div></div>
            
        </li>
        
        
        <li id="section-286">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-286">&#x00a7;</a>
              </div>
              <p>be fired.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (!chars) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> listeners = <span class="hljs-title function_">accumulateTwoPhaseListeners</span>(targetInst, <span class="hljs-string">&#x27;onBeforeInput&#x27;</span>);

    <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticInputEvent</span>(<span class="hljs-string">&#x27;onBeforeInput&#x27;</span>, <span class="hljs-string">&#x27;beforeinput&#x27;</span>, <span class="hljs-literal">null</span>, nativeEvent, nativeEventTarget);
      dispatchQueue.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">event</span>: event,
        <span class="hljs-attr">listeners</span>: listeners
      });
      event.<span class="hljs-property">data</span> = chars;
    }
  }
  <span class="hljs-comment">/**
   * Create an `onBeforeInput` event to match
   * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
   *
   * This event plugin is based on the native `textInput` event
   * available in Chrome, Safari, Opera, and IE. This event fires after
   * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
   *
   * `beforeInput` is spec&#x27;d but not implemented in any browsers, and
   * the `input` event does not provide any useful information about what has
   * actually been added, contrary to the spec. Thus, `textInput` is the best
   * available event to identify the characters that have actually been inserted
   * into the target node.
   *
   * This plugin is also responsible for emitting `composition` events, thus
   * allowing us to share composition fallback code for both `beforeInput` and
   * `composition` event types.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer</span>) {
    <span class="hljs-title function_">extractCompositionEvent</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    <span class="hljs-title function_">extractBeforeInputEvent</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@see</span> http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
   */</span>
  <span class="hljs-keyword">var</span> supportedInputTypes = {
    <span class="hljs-attr">color</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">date</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">datetime</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">&#x27;datetime-local&#x27;</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">email</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">month</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">number</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">range</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">search</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">tel</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">text</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">time</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">url</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">week</span>: <span class="hljs-literal">true</span>
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isTextInputElement</span>(<span class="hljs-params">elem</span>) {
    <span class="hljs-keyword">var</span> nodeName = elem &amp;&amp; elem.<span class="hljs-property">nodeName</span> &amp;&amp; elem.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>();

    <span class="hljs-keyword">if</span> (nodeName === <span class="hljs-string">&#x27;input&#x27;</span>) {
      <span class="hljs-keyword">return</span> !!supportedInputTypes[elem.<span class="hljs-property">type</span>];
    }

    <span class="hljs-keyword">if</span> (nodeName === <span class="hljs-string">&#x27;textarea&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-comment">/**
   * Checks if an event is supported in the current execution environment.
   *
   * <span class="hljs-doctag">NOTE:</span> This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">string</span>} eventNameSuffix Event name, e.g. &quot;click&quot;.
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">boolean</span>} True if the event is supported.
   * <span class="hljs-doctag">@internal</span>
   * <span class="hljs-doctag">@license</span> Modernizr 3.0.0pre (Custom Build) | MIT
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isEventSupported</span>(<span class="hljs-params">eventNameSuffix</span>) {
    <span class="hljs-keyword">if</span> (!canUseDOM) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> eventName = <span class="hljs-string">&#x27;on&#x27;</span> + eventNameSuffix;
    <span class="hljs-keyword">var</span> isSupported = (eventName <span class="hljs-keyword">in</span> <span class="hljs-variable language_">document</span>);

    <span class="hljs-keyword">if</span> (!isSupported) {
      <span class="hljs-keyword">var</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
      element.<span class="hljs-title function_">setAttribute</span>(eventName, <span class="hljs-string">&#x27;return;&#x27;</span>);
      isSupported = <span class="hljs-keyword">typeof</span> element[eventName] === <span class="hljs-string">&#x27;function&#x27;</span>;
    }

    <span class="hljs-keyword">return</span> isSupported;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerEvents$1</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">registerTwoPhaseEvent</span>(<span class="hljs-string">&#x27;onChange&#x27;</span>, [<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;focusin&#x27;</span>, <span class="hljs-string">&#x27;focusout&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;selectionchange&#x27;</span>]);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createAndAccumulateChangeEvent</span>(<span class="hljs-params">dispatchQueue, inst, nativeEvent, target</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-287">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-287">&#x00a7;</a>
              </div>
              <p>Flag this event loop as needing state restore.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">enqueueStateRestore</span>(target);
    <span class="hljs-keyword">var</span> listeners = <span class="hljs-title function_">accumulateTwoPhaseListeners</span>(inst, <span class="hljs-string">&#x27;onChange&#x27;</span>);

    <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEvent</span>(<span class="hljs-string">&#x27;onChange&#x27;</span>, <span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-literal">null</span>, nativeEvent, target);
      dispatchQueue.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">event</span>: event,
        <span class="hljs-attr">listeners</span>: listeners
      });
    }
  }
  <span class="hljs-comment">/**
   * For IE shims
   */</span>


  <span class="hljs-keyword">var</span> activeElement = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> activeElementInst = <span class="hljs-literal">null</span>;
  <span class="hljs-comment">/**
   * SECTION: handle `change` event
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldUseChangeEvent</span>(<span class="hljs-params">elem</span>) {
    <span class="hljs-keyword">var</span> nodeName = elem.<span class="hljs-property">nodeName</span> &amp;&amp; elem.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>();
    <span class="hljs-keyword">return</span> nodeName === <span class="hljs-string">&#x27;select&#x27;</span> || nodeName === <span class="hljs-string">&#x27;input&#x27;</span> &amp;&amp; elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;file&#x27;</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">manualDispatchChangeEvent</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">var</span> dispatchQueue = [];
    <span class="hljs-title function_">createAndAccumulateChangeEvent</span>(dispatchQueue, activeElementInst, nativeEvent, <span class="hljs-title function_">getEventTarget</span>(nativeEvent)); <span class="hljs-comment">// If change and propertychange bubbled, we&#x27;d just bind to it like all the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-288">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-288">&#x00a7;</a>
              </div>
              <p>other events and have it go through ReactBrowserEventEmitter. Since it
doesn’t, we manually listen for the events and so we have to enqueue and
process the abstract event manually.</p>
<p>Batching is necessary here in order to ensure that all event handlers run
before the next rerender (including event handlers attached to ancestor
elements instead of directly on the input). Without this, controlled
components don’t work properly in conjunction with event bubbling because
the component is rerendered and the value reverted before all the event
handlers can run. See <a href="https://github.com/facebook/react/issues/708">https://github.com/facebook/react/issues/708</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title function_">batchedUpdates</span>(runEventInBatch, dispatchQueue);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">runEventInBatch</span>(<span class="hljs-params">dispatchQueue</span>) {
    <span class="hljs-title function_">processDispatchQueue</span>(dispatchQueue, <span class="hljs-number">0</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInstIfValueChanged</span>(<span class="hljs-params">targetInst</span>) {
    <span class="hljs-keyword">var</span> targetNode = <span class="hljs-title function_">getNodeFromInstance</span>(targetInst);

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">updateValueIfChanged</span>(targetNode)) {
      <span class="hljs-keyword">return</span> targetInst;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTargetInstForChangeEvent</span>(<span class="hljs-params">domEventName, targetInst</span>) {
    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;change&#x27;</span>) {
      <span class="hljs-keyword">return</span> targetInst;
    }
  }
  <span class="hljs-comment">/**
   * SECTION: handle `input` event
   */</span>


  <span class="hljs-keyword">var</span> isInputEventSupported = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">if</span> (canUseDOM) {</pre></div></div>
            
        </li>
        
        
        <li id="section-289">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-289">&#x00a7;</a>
              </div>
              <p>IE9 claims to support the input event but fails to trigger it when
deleting text, so we ignore its input events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isInputEventSupported = <span class="hljs-title function_">isEventSupported</span>(<span class="hljs-string">&#x27;input&#x27;</span>) &amp;&amp; (!<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentMode</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentMode</span> &gt; <span class="hljs-number">9</span>);
  }
  <span class="hljs-comment">/**
   * (For IE &lt;=9) Starts tracking propertychange events on the passed-in element
   * and override the value property so that we can distinguish user events from
   * value changes in JS.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">startWatchingForValueChange</span>(<span class="hljs-params">target, targetInst</span>) {
    activeElement = target;
    activeElementInst = targetInst;
    activeElement.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;onpropertychange&#x27;</span>, handlePropertyChange);
  }
  <span class="hljs-comment">/**
   * (For IE &lt;=9) Removes the event listeners from the currently-tracked element,
   * if any exists.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopWatchingForValueChange</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!activeElement) {
      <span class="hljs-keyword">return</span>;
    }

    activeElement.<span class="hljs-title function_">detachEvent</span>(<span class="hljs-string">&#x27;onpropertychange&#x27;</span>, handlePropertyChange);
    activeElement = <span class="hljs-literal">null</span>;
    activeElementInst = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">/**
   * (For IE &lt;=9) Handles a propertychange event, sending a `change` event if
   * the value of the active element has changed.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handlePropertyChange</span>(<span class="hljs-params">nativeEvent</span>) {
    <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">propertyName</span> !== <span class="hljs-string">&#x27;value&#x27;</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getInstIfValueChanged</span>(activeElementInst)) {
      <span class="hljs-title function_">manualDispatchChangeEvent</span>(nativeEvent);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleEventsForInputEventPolyfill</span>(<span class="hljs-params">domEventName, target, targetInst</span>) {
    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;focusin&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-290">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-290">&#x00a7;</a>
              </div>
              <p>In IE9, propertychange fires for most input events but is buggy and
doesn’t fire when text is deleted, but conveniently, selectionchange
appears to fire in all of the remaining cases so we catch those and
forward the event if the value has changed
In either case, we don’t want to call the event handler if the value
is changed from JS so we redefine a setter for <code>.value</code> that updates
our activeElementValue variable, allowing us to ignore those changes</p>
<p>stopWatching() should be a noop here but we call it just in case we
missed a blur event somehow.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">stopWatchingForValueChange</span>();
      <span class="hljs-title function_">startWatchingForValueChange</span>(target, targetInst);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;focusout&#x27;</span>) {
      <span class="hljs-title function_">stopWatchingForValueChange</span>();
    }
  } <span class="hljs-comment">// For IE8 and IE9.</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTargetInstForInputEventPolyfill</span>(<span class="hljs-params">domEventName, targetInst</span>) {
    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;selectionchange&#x27;</span> || domEventName === <span class="hljs-string">&#x27;keyup&#x27;</span> || domEventName === <span class="hljs-string">&#x27;keydown&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-291">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-291">&#x00a7;</a>
              </div>
              <p>On the selectionchange event, the target is just document which isn’t
helpful for us so just check activeElement instead.</p>
<p>99% of the time, keydown and keyup aren’t necessary. IE8 fails to fire
propertychange on the first input event after setting <code>value</code> from a
script and fires only keydown, keypress, keyup. Catching keyup usually
gets it and catching keydown lets us fire an event for the first
keystroke if user does a key repeat (it’ll be a little delayed: right
before the second keystroke). Other input methods (e.g., paste) seem to
fire selectionchange normally.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getInstIfValueChanged</span>(activeElementInst);
    }
  }
  <span class="hljs-comment">/**
   * SECTION: handle `click` event
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldUseClickEvent</span>(<span class="hljs-params">elem</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-292">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-292">&#x00a7;</a>
              </div>
              <p>Use the <code>click</code> event to detect changes to checkbox and radio inputs.
This approach works across all browsers, whereas <code>change</code> does not fire
until <code>blur</code> in IE8.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> nodeName = elem.<span class="hljs-property">nodeName</span>;
    <span class="hljs-keyword">return</span> nodeName &amp;&amp; nodeName.<span class="hljs-title function_">toLowerCase</span>() === <span class="hljs-string">&#x27;input&#x27;</span> &amp;&amp; (elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;checkbox&#x27;</span> || elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;radio&#x27;</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTargetInstForClickEvent</span>(<span class="hljs-params">domEventName, targetInst</span>) {
    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;click&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getInstIfValueChanged</span>(targetInst);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getTargetInstForInputOrChangeEvent</span>(<span class="hljs-params">domEventName, targetInst</span>) {
    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;input&#x27;</span> || domEventName === <span class="hljs-string">&#x27;change&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getInstIfValueChanged</span>(targetInst);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleControlledInputBlur</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">var</span> state = node.<span class="hljs-property">_wrapperState</span>;

    <span class="hljs-keyword">if</span> (!state || !state.<span class="hljs-property">controlled</span> || node.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;number&#x27;</span>) {
      <span class="hljs-keyword">return</span>;
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-293">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-293">&#x00a7;</a>
              </div>
              <p>If controlled, assign the value attribute to the current value on blur</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">setDefaultValue</span>(node, <span class="hljs-string">&#x27;number&#x27;</span>, node.<span class="hljs-property">value</span>);
    }
  }
  <span class="hljs-comment">/**
   * This plugin creates an `onChange` event that normalizes change events
   * across form elements. This event fires at a time when it&#x27;s possible to
   * change the element&#x27;s value without seeing a flicker.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - select
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents$1</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer</span>) {
    <span class="hljs-keyword">var</span> targetNode = targetInst ? <span class="hljs-title function_">getNodeFromInstance</span>(targetInst) : <span class="hljs-variable language_">window</span>;
    <span class="hljs-keyword">var</span> getTargetInstFunc, handleEventFunc;

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldUseChangeEvent</span>(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTextInputElement</span>(targetNode)) {
      <span class="hljs-keyword">if</span> (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } <span class="hljs-keyword">else</span> {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldUseClickEvent</span>(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    <span class="hljs-keyword">if</span> (getTargetInstFunc) {
      <span class="hljs-keyword">var</span> inst = <span class="hljs-title function_">getTargetInstFunc</span>(domEventName, targetInst);

      <span class="hljs-keyword">if</span> (inst) {
        <span class="hljs-title function_">createAndAccumulateChangeEvent</span>(dispatchQueue, inst, nativeEvent, nativeEventTarget);
        <span class="hljs-keyword">return</span>;
      }
    }

    <span class="hljs-keyword">if</span> (handleEventFunc) {
      <span class="hljs-title function_">handleEventFunc</span>(domEventName, targetNode, targetInst);
    } <span class="hljs-comment">// When blurring, set the value attribute for number inputs</span>


    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;focusout&#x27;</span>) {
      <span class="hljs-title function_">handleControlledInputBlur</span>(targetNode);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerEvents$2</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">registerDirectEvent</span>(<span class="hljs-string">&#x27;onMouseEnter&#x27;</span>, [<span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-string">&#x27;mouseover&#x27;</span>]);
    <span class="hljs-title function_">registerDirectEvent</span>(<span class="hljs-string">&#x27;onMouseLeave&#x27;</span>, [<span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-string">&#x27;mouseover&#x27;</span>]);
    <span class="hljs-title function_">registerDirectEvent</span>(<span class="hljs-string">&#x27;onPointerEnter&#x27;</span>, [<span class="hljs-string">&#x27;pointerout&#x27;</span>, <span class="hljs-string">&#x27;pointerover&#x27;</span>]);
    <span class="hljs-title function_">registerDirectEvent</span>(<span class="hljs-string">&#x27;onPointerLeave&#x27;</span>, [<span class="hljs-string">&#x27;pointerout&#x27;</span>, <span class="hljs-string">&#x27;pointerover&#x27;</span>]);
  }
  <span class="hljs-comment">/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents$2</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer</span>) {
    <span class="hljs-keyword">var</span> isOverEvent = domEventName === <span class="hljs-string">&#x27;mouseover&#x27;</span> || domEventName === <span class="hljs-string">&#x27;pointerover&#x27;</span>;
    <span class="hljs-keyword">var</span> isOutEvent = domEventName === <span class="hljs-string">&#x27;mouseout&#x27;</span> || domEventName === <span class="hljs-string">&#x27;pointerout&#x27;</span>;

    <span class="hljs-keyword">if</span> (isOverEvent &amp;&amp; (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_REPLAYED</span>) === <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-294">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-294">&#x00a7;</a>
              </div>
              <p>If this is an over event with a target, we might have already dispatched
the event in the out event of the other target. If this is replayed,
then it’s because we couldn’t dispatch against this target previously
so we have to do it now instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> related = nativeEvent.<span class="hljs-property">relatedTarget</span> || nativeEvent.<span class="hljs-property">fromElement</span>;

      <span class="hljs-keyword">if</span> (related) {</pre></div></div>
            
        </li>
        
        
        <li id="section-295">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-295">&#x00a7;</a>
              </div>
              <p>If the related node is managed by React, we can assume that we have
already dispatched the corresponding events during its mouseout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getClosestInstanceFromNode</span>(related) || <span class="hljs-title function_">isContainerMarkedAsRoot</span>(related)) {
          <span class="hljs-keyword">return</span>;
        }
      }
    }

    <span class="hljs-keyword">if</span> (!isOutEvent &amp;&amp; !isOverEvent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-296">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-296">&#x00a7;</a>
              </div>
              <p>Must not be a mouse or pointer in or out - ignoring.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> win; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> why is this nullable in the types but we read from it?</span>

    <span class="hljs-keyword">if</span> (nativeEventTarget.<span class="hljs-property">window</span> === nativeEventTarget) {</pre></div></div>
            
        </li>
        
        
        <li id="section-297">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-297">&#x00a7;</a>
              </div>
              <p><code>nativeEventTarget</code> is probably a window object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      win = nativeEventTarget;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-298">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-298">&#x00a7;</a>
              </div>
              <p>TODO: Figure out why <code>ownerDocument</code> is sometimes undefined in IE8.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> doc = nativeEventTarget.<span class="hljs-property">ownerDocument</span>;

      <span class="hljs-keyword">if</span> (doc) {
        win = doc.<span class="hljs-property">defaultView</span> || doc.<span class="hljs-property">parentWindow</span>;
      } <span class="hljs-keyword">else</span> {
        win = <span class="hljs-variable language_">window</span>;
      }
    }

    <span class="hljs-keyword">var</span> <span class="hljs-keyword">from</span>;
    <span class="hljs-keyword">var</span> to;

    <span class="hljs-keyword">if</span> (isOutEvent) {
      <span class="hljs-keyword">var</span> _related = nativeEvent.<span class="hljs-property">relatedTarget</span> || nativeEvent.<span class="hljs-property">toElement</span>;

      <span class="hljs-keyword">from</span> = targetInst;
      to = _related ? <span class="hljs-title function_">getClosestInstanceFromNode</span>(_related) : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (to !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> nearestMounted = <span class="hljs-title function_">getNearestMountedFiber</span>(to);

        <span class="hljs-keyword">if</span> (to !== nearestMounted || to.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostComponent</span> &amp;&amp; to.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostText</span>) {
          to = <span class="hljs-literal">null</span>;
        }
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-299">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-299">&#x00a7;</a>
              </div>
              <p>Moving to a node from outside the window.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">from</span> = <span class="hljs-literal">null</span>;
      to = targetInst;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> === to) {</pre></div></div>
            
        </li>
        
        
        <li id="section-300">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-300">&#x00a7;</a>
              </div>
              <p>Nothing pertains to our managed components.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticMouseEvent</span>;
    <span class="hljs-keyword">var</span> leaveEventType = <span class="hljs-string">&#x27;onMouseLeave&#x27;</span>;
    <span class="hljs-keyword">var</span> enterEventType = <span class="hljs-string">&#x27;onMouseEnter&#x27;</span>;
    <span class="hljs-keyword">var</span> eventTypePrefix = <span class="hljs-string">&#x27;mouse&#x27;</span>;

    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;pointerout&#x27;</span> || domEventName === <span class="hljs-string">&#x27;pointerover&#x27;</span>) {
      <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticPointerEvent</span>;
      leaveEventType = <span class="hljs-string">&#x27;onPointerLeave&#x27;</span>;
      enterEventType = <span class="hljs-string">&#x27;onPointerEnter&#x27;</span>;
      eventTypePrefix = <span class="hljs-string">&#x27;pointer&#x27;</span>;
    }

    <span class="hljs-keyword">var</span> fromNode = <span class="hljs-keyword">from</span> == <span class="hljs-literal">null</span> ? win : <span class="hljs-title function_">getNodeFromInstance</span>(<span class="hljs-keyword">from</span>);
    <span class="hljs-keyword">var</span> toNode = to == <span class="hljs-literal">null</span> ? win : <span class="hljs-title function_">getNodeFromInstance</span>(to);
    <span class="hljs-keyword">var</span> leave = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEventCtor</span>(leaveEventType, eventTypePrefix + <span class="hljs-string">&#x27;leave&#x27;</span>, <span class="hljs-keyword">from</span>, nativeEvent, nativeEventTarget);
    leave.<span class="hljs-property">target</span> = fromNode;
    leave.<span class="hljs-property">relatedTarget</span> = toNode;
    <span class="hljs-keyword">var</span> enter = <span class="hljs-literal">null</span>; <span class="hljs-comment">// We should only process this nativeEvent if we are processing</span></pre></div></div>
            
        </li>
        
        
        <li id="section-301">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-301">&#x00a7;</a>
              </div>
              <p>the first ancestor. Next time, we will ignore the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> nativeTargetInst = <span class="hljs-title function_">getClosestInstanceFromNode</span>(nativeEventTarget);

    <span class="hljs-keyword">if</span> (nativeTargetInst === targetInst) {
      <span class="hljs-keyword">var</span> enterEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEventCtor</span>(enterEventType, eventTypePrefix + <span class="hljs-string">&#x27;enter&#x27;</span>, to, nativeEvent, nativeEventTarget);
      enterEvent.<span class="hljs-property">target</span> = toNode;
      enterEvent.<span class="hljs-property">relatedTarget</span> = fromNode;
      enter = enterEvent;
    }

    <span class="hljs-title function_">accumulateEnterLeaveTwoPhaseListeners</span>(dispatchQueue, leave, enter, <span class="hljs-keyword">from</span>, to);
  }

  <span class="hljs-comment">/**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">is</span>(<span class="hljs-params">x, y</span>) {
    <span class="hljs-keyword">return</span> x === y &amp;&amp; (x !== <span class="hljs-number">0</span> || <span class="hljs-number">1</span> / x === <span class="hljs-number">1</span> / y) || x !== x &amp;&amp; y !== y <span class="hljs-comment">// eslint-disable-line no-self-compare</span>
      ;
  }

  <span class="hljs-keyword">var</span> objectIs = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title class_">Object</span>.<span class="hljs-property">is</span> : is;

  <span class="hljs-keyword">var</span> hasOwnProperty$<span class="hljs-number">2</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>;
  <span class="hljs-comment">/**
   * Performs equality by iterating through keys on an object and returning false
   * when any key has values which are not strictly equal between the arguments.
   * Returns true when the values of all keys are strictly equal.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowEqual</span>(<span class="hljs-params">objA, objB</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">objectIs</span>(objA, objB)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> objA !== <span class="hljs-string">&#x27;object&#x27;</span> || objA === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> objB !== <span class="hljs-string">&#x27;object&#x27;</span> || objB === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> keysA = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(objA);
    <span class="hljs-keyword">var</span> keysB = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(objB);

    <span class="hljs-keyword">if</span> (keysA.<span class="hljs-property">length</span> !== keysB.<span class="hljs-property">length</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// Test for A&#x27;s keys different from B.</span>


    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keysA.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (!hasOwnProperty$<span class="hljs-number">2.</span><span class="hljs-title function_">call</span>(objB, keysA[i]) || !<span class="hljs-title function_">objectIs</span>(objA[keysA[i]], objB[keysA[i]])) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-comment">/**
   * Given any node return the first leaf node without children.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement|DOMTextNode</span>} <span class="hljs-variable">node</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">DOMElement|DOMTextNode</span>}
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLeafNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">while</span> (node &amp;&amp; node.<span class="hljs-property">firstChild</span>) {
      node = node.<span class="hljs-property">firstChild</span>;
    }

    <span class="hljs-keyword">return</span> node;
  }
  <span class="hljs-comment">/**
   * Get the next sibling within a container. This will walk up the
   * DOM if a node&#x27;s siblings have been exhausted.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement|DOMTextNode</span>} <span class="hljs-variable">node</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?DOMElement|DOMTextNode</span>}
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSiblingNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">while</span> (node) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nextSibling</span>) {
        <span class="hljs-keyword">return</span> node.<span class="hljs-property">nextSibling</span>;
      }

      node = node.<span class="hljs-property">parentNode</span>;
    }
  }
  <span class="hljs-comment">/**
   * Get object describing the nodes which contain characters at offset.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement|DOMTextNode</span>} <span class="hljs-variable">root</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">number</span>} <span class="hljs-variable">offset</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?object</span>}
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNodeForCharacterOffset</span>(<span class="hljs-params">root, offset</span>) {
    <span class="hljs-keyword">var</span> node = <span class="hljs-title function_">getLeafNode</span>(root);
    <span class="hljs-keyword">var</span> nodeStart = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> nodeEnd = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (node) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span>) {
        nodeEnd = nodeStart + node.<span class="hljs-property">textContent</span>.<span class="hljs-property">length</span>;

        <span class="hljs-keyword">if</span> (nodeStart &lt;= offset &amp;&amp; nodeEnd &gt;= offset) {
          <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">node</span>: node,
            <span class="hljs-attr">offset</span>: offset - nodeStart
          };
        }

        nodeStart = nodeEnd;
      }

      node = <span class="hljs-title function_">getLeafNode</span>(<span class="hljs-title function_">getSiblingNode</span>(node));
    }
  }

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement</span>} <span class="hljs-variable">outerNode</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?object</span>}
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getOffsets</span>(<span class="hljs-params">outerNode</span>) {
    <span class="hljs-keyword">var</span> ownerDocument = outerNode.<span class="hljs-property">ownerDocument</span>;
    <span class="hljs-keyword">var</span> win = ownerDocument &amp;&amp; ownerDocument.<span class="hljs-property">defaultView</span> || <span class="hljs-variable language_">window</span>;
    <span class="hljs-keyword">var</span> selection = win.<span class="hljs-property">getSelection</span> &amp;&amp; win.<span class="hljs-title function_">getSelection</span>();

    <span class="hljs-keyword">if</span> (!selection || selection.<span class="hljs-property">rangeCount</span> === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> anchorNode = selection.<span class="hljs-property">anchorNode</span>,
      anchorOffset = selection.<span class="hljs-property">anchorOffset</span>,
      focusNode = selection.<span class="hljs-property">focusNode</span>,
      focusOffset = selection.<span class="hljs-property">focusOffset</span>; <span class="hljs-comment">// In Firefox, anchorNode and focusNode can be &quot;anonymous divs&quot;, e.g. the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-302">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-302">&#x00a7;</a>
              </div>
              <p>up/down buttons on an <input type="number">. Anonymous divs do not seem to
expose properties, triggering a “Permission denied error” if any of its
properties are accessed. The only seemingly possible way to avoid erroring
is to access a property that typically works for non-anonymous divs and
catch any error that may otherwise arise. See
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=208427">https://bugzilla.mozilla.org/show_bug.cgi?id=208427</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">/* eslint-disable no-unused-expressions */</span>
      anchorNode.<span class="hljs-property">nodeType</span>;
      focusNode.<span class="hljs-property">nodeType</span>;
      <span class="hljs-comment">/* eslint-enable no-unused-expressions */</span>
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getModernOffsetsFromPoints</span>(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
  }
  <span class="hljs-comment">/**
   * Returns {start, end} where `start` is the character/codepoint index of
   * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
   * `end` is the index of (focusNode, focusOffset).
   *
   * Returns null if you pass in garbage input but we should probably just crash.
   *
   * Exported only for testing.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getModernOffsetsFromPoints</span>(<span class="hljs-params">outerNode, anchorNode, anchorOffset, focusNode, focusOffset</span>) {
    <span class="hljs-keyword">var</span> length = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> start = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> end = -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> indexWithinAnchor = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> indexWithinFocus = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> node = outerNode;
    <span class="hljs-keyword">var</span> parentNode = <span class="hljs-literal">null</span>;

    <span class="hljs-attr">outer</span>: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">var</span> next = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (node === anchorNode &amp;&amp; (anchorOffset === <span class="hljs-number">0</span> || node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span>)) {
          start = length + anchorOffset;
        }

        <span class="hljs-keyword">if</span> (node === focusNode &amp;&amp; (focusOffset === <span class="hljs-number">0</span> || node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span>)) {
          end = length + focusOffset;
        }

        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span>) {
          length += node.<span class="hljs-property">nodeValue</span>.<span class="hljs-property">length</span>;
        }

        <span class="hljs-keyword">if</span> ((next = node.<span class="hljs-property">firstChild</span>) === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">break</span>;
        } <span class="hljs-comment">// Moving from `node` to its first child `next`.</span>


        parentNode = node;
        node = next;
      }

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (node === outerNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-303">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-303">&#x00a7;</a>
              </div>
              <p>If <code>outerNode</code> has children, this is always the second time visiting
it. If it has no children, this is still the first loop, and the only
valid selection is anchorNode and focusNode both equal to this node
and both offsets 0, in which case we will have handled above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">break</span> outer;
        }

        <span class="hljs-keyword">if</span> (parentNode === anchorNode &amp;&amp; ++indexWithinAnchor === anchorOffset) {
          start = length;
        }

        <span class="hljs-keyword">if</span> (parentNode === focusNode &amp;&amp; ++indexWithinFocus === focusOffset) {
          end = length;
        }

        <span class="hljs-keyword">if</span> ((next = node.<span class="hljs-property">nextSibling</span>) !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">break</span>;
        }

        node = parentNode;
        parentNode = node.<span class="hljs-property">parentNode</span>;
      } <span class="hljs-comment">// Moving from `node` to its next sibling `next`.</span>


      node = next;
    }

    <span class="hljs-keyword">if</span> (start === -<span class="hljs-number">1</span> || end === -<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-304">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-304">&#x00a7;</a>
              </div>
              <p>This should never happen. (Would happen if the anchor/focus nodes aren’t
actually inside the passed-in node.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">start</span>: start,
      <span class="hljs-attr">end</span>: end
    };
  }
  <span class="hljs-comment">/**
   * In modern non-IE browsers, we can support both forward and backward
   * selections.
   *
   * Note: IE10+ supports the Selection object, but it does not support
   * the `extend` method, which means that even in modern IE, it&#x27;s not possible
   * to programmatically create a backward selection. Thus, for all IE
   * versions, we use the old IE API to create our selections.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">DOMElement|DOMTextNode</span>} <span class="hljs-variable">node</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">offsets</span>
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setOffsets</span>(<span class="hljs-params">node, offsets</span>) {
    <span class="hljs-keyword">var</span> doc = node.<span class="hljs-property">ownerDocument</span> || <span class="hljs-variable language_">document</span>;
    <span class="hljs-keyword">var</span> win = doc &amp;&amp; doc.<span class="hljs-property">defaultView</span> || <span class="hljs-variable language_">window</span>; <span class="hljs-comment">// Edge fails with &quot;Object expected&quot; in some scenarios.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-305">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-305">&#x00a7;</a>
              </div>
              <p>(For instance: TinyMCE editor used in a list component that supports pasting to add more,
fails when pasting 100+ items)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!win.<span class="hljs-property">getSelection</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> selection = win.<span class="hljs-title function_">getSelection</span>();
    <span class="hljs-keyword">var</span> length = node.<span class="hljs-property">textContent</span>.<span class="hljs-property">length</span>;
    <span class="hljs-keyword">var</span> start = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(offsets.<span class="hljs-property">start</span>, length);
    <span class="hljs-keyword">var</span> end = offsets.<span class="hljs-property">end</span> === <span class="hljs-literal">undefined</span> ? start : <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(offsets.<span class="hljs-property">end</span>, length); <span class="hljs-comment">// IE 11 uses modern selection, but doesn&#x27;t support the extend method.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-306">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-306">&#x00a7;</a>
              </div>
              <p>Flip backward selections, so we can set with a single range.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!selection.<span class="hljs-property">extend</span> &amp;&amp; start &gt; end) {
      <span class="hljs-keyword">var</span> temp = end;
      end = start;
      start = temp;
    }

    <span class="hljs-keyword">var</span> startMarker = <span class="hljs-title function_">getNodeForCharacterOffset</span>(node, start);
    <span class="hljs-keyword">var</span> endMarker = <span class="hljs-title function_">getNodeForCharacterOffset</span>(node, end);

    <span class="hljs-keyword">if</span> (startMarker &amp;&amp; endMarker) {
      <span class="hljs-keyword">if</span> (selection.<span class="hljs-property">rangeCount</span> === <span class="hljs-number">1</span> &amp;&amp; selection.<span class="hljs-property">anchorNode</span> === startMarker.<span class="hljs-property">node</span> &amp;&amp; selection.<span class="hljs-property">anchorOffset</span> === startMarker.<span class="hljs-property">offset</span> &amp;&amp; selection.<span class="hljs-property">focusNode</span> === endMarker.<span class="hljs-property">node</span> &amp;&amp; selection.<span class="hljs-property">focusOffset</span> === endMarker.<span class="hljs-property">offset</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> range = doc.<span class="hljs-title function_">createRange</span>();
      range.<span class="hljs-title function_">setStart</span>(startMarker.<span class="hljs-property">node</span>, startMarker.<span class="hljs-property">offset</span>);
      selection.<span class="hljs-title function_">removeAllRanges</span>();

      <span class="hljs-keyword">if</span> (start &gt; end) {
        selection.<span class="hljs-title function_">addRange</span>(range);
        selection.<span class="hljs-title function_">extend</span>(endMarker.<span class="hljs-property">node</span>, endMarker.<span class="hljs-property">offset</span>);
      } <span class="hljs-keyword">else</span> {
        range.<span class="hljs-title function_">setEnd</span>(endMarker.<span class="hljs-property">node</span>, endMarker.<span class="hljs-property">offset</span>);
        selection.<span class="hljs-title function_">addRange</span>(range);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isTextNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> node &amp;&amp; node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">TEXT_NODE</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">containsNode</span>(<span class="hljs-params">outerNode, innerNode</span>) {
    <span class="hljs-keyword">if</span> (!outerNode || !innerNode) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (outerNode === innerNode) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTextNode</span>(outerNode)) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTextNode</span>(innerNode)) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">containsNode</span>(outerNode, innerNode.<span class="hljs-property">parentNode</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;contains&#x27;</span> <span class="hljs-keyword">in</span> outerNode) {
      <span class="hljs-keyword">return</span> outerNode.<span class="hljs-title function_">contains</span>(innerNode);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (outerNode.<span class="hljs-property">compareDocumentPosition</span>) {
      <span class="hljs-keyword">return</span> !!(outerNode.<span class="hljs-title function_">compareDocumentPosition</span>(innerNode) &amp; <span class="hljs-number">16</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isInDocument</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> node &amp;&amp; node.<span class="hljs-property">ownerDocument</span> &amp;&amp; <span class="hljs-title function_">containsNode</span>(node.<span class="hljs-property">ownerDocument</span>.<span class="hljs-property">documentElement</span>, node);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isSameOriginFrame</span>(<span class="hljs-params">iframe</span>) {
    <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-307">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-307">&#x00a7;</a>
              </div>
              <p>Accessing the contentDocument of a HTMLIframeElement can cause the browser
to throw, e.g. if it has a cross-origin src attribute.
Safari will show an error in the console when the access results in “Blocked a frame with origin”. e.g:
iframe.contentDocument.defaultView;
A safety way is to access one of the cross origin properties: Window or Location
Which might result in “SecurityError” DOM Exception and it is compatible to Safari.
<a href="https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl">https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> === <span class="hljs-string">&#x27;string&#x27;</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getActiveElementDeep</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> win = <span class="hljs-variable language_">window</span>;
    <span class="hljs-keyword">var</span> element = <span class="hljs-title function_">getActiveElement</span>();

    <span class="hljs-keyword">while</span> (element <span class="hljs-keyword">instanceof</span> win.<span class="hljs-property">HTMLIFrameElement</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSameOriginFrame</span>(element)) {
        win = element.<span class="hljs-property">contentWindow</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> element;
      }

      element = <span class="hljs-title function_">getActiveElement</span>(win.<span class="hljs-property">document</span>);
    }

    <span class="hljs-keyword">return</span> element;
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@ReactInputSelection</span>: React input selection module. Based on Selection.js,
   * but modified to be suitable for react and has a couple of bug fixes (doesn&#x27;t
   * assume buttons have range selections allowed).
   * Input selection module for React.
   */</span>

  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@hasSelectionCapabilities</span>: we get the element types that support selection
   * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
   * and `selectionEnd` rows.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasSelectionCapabilities</span>(<span class="hljs-params">elem</span>) {
    <span class="hljs-keyword">var</span> nodeName = elem &amp;&amp; elem.<span class="hljs-property">nodeName</span> &amp;&amp; elem.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>();
    <span class="hljs-keyword">return</span> nodeName &amp;&amp; (nodeName === <span class="hljs-string">&#x27;input&#x27;</span> &amp;&amp; (elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;text&#x27;</span> || elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;search&#x27;</span> || elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;tel&#x27;</span> || elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;url&#x27;</span> || elem.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;password&#x27;</span>) || nodeName === <span class="hljs-string">&#x27;textarea&#x27;</span> || elem.<span class="hljs-property">contentEditable</span> === <span class="hljs-string">&#x27;true&#x27;</span>);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelectionInformation</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> focusedElem = <span class="hljs-title function_">getActiveElementDeep</span>();
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">focusedElem</span>: focusedElem,
      <span class="hljs-attr">selectionRange</span>: <span class="hljs-title function_">hasSelectionCapabilities</span>(focusedElem) ? <span class="hljs-title function_">getSelection</span>(focusedElem) : <span class="hljs-literal">null</span>
    };
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@restoreSelection</span>: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreSelection</span>(<span class="hljs-params">priorSelectionInformation</span>) {
    <span class="hljs-keyword">var</span> curFocusedElem = <span class="hljs-title function_">getActiveElementDeep</span>();
    <span class="hljs-keyword">var</span> priorFocusedElem = priorSelectionInformation.<span class="hljs-property">focusedElem</span>;
    <span class="hljs-keyword">var</span> priorSelectionRange = priorSelectionInformation.<span class="hljs-property">selectionRange</span>;

    <span class="hljs-keyword">if</span> (curFocusedElem !== priorFocusedElem &amp;&amp; <span class="hljs-title function_">isInDocument</span>(priorFocusedElem)) {
      <span class="hljs-keyword">if</span> (priorSelectionRange !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">hasSelectionCapabilities</span>(priorFocusedElem)) {
        <span class="hljs-title function_">setSelection</span>(priorFocusedElem, priorSelectionRange);
      } <span class="hljs-comment">// Focusing a node can change the scroll position, which is undesirable</span>


      <span class="hljs-keyword">var</span> ancestors = [];
      <span class="hljs-keyword">var</span> ancestor = priorFocusedElem;

      <span class="hljs-keyword">while</span> (ancestor = ancestor.<span class="hljs-property">parentNode</span>) {
        <span class="hljs-keyword">if</span> (ancestor.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span>) {
          ancestors.<span class="hljs-title function_">push</span>({
            <span class="hljs-attr">element</span>: ancestor,
            <span class="hljs-attr">left</span>: ancestor.<span class="hljs-property">scrollLeft</span>,
            <span class="hljs-attr">top</span>: ancestor.<span class="hljs-property">scrollTop</span>
          });
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> priorFocusedElem.<span class="hljs-property">focus</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        priorFocusedElem.<span class="hljs-title function_">focus</span>();
      }

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ancestors.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">var</span> info = ancestors[i];
        info.<span class="hljs-property">element</span>.<span class="hljs-property">scrollLeft</span> = info.<span class="hljs-property">left</span>;
        info.<span class="hljs-property">element</span>.<span class="hljs-property">scrollTop</span> = info.<span class="hljs-property">top</span>;
      }
    }
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@getSelection</span>: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -<span class="hljs-doctag">@input</span>: Look up selection bounds of this input
   * -<span class="hljs-doctag">@return</span> {<span class="hljs-type">start: selectionStart, end: selectionEnd</span>}
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelection</span>(<span class="hljs-params">input</span>) {
    <span class="hljs-keyword">var</span> selection;

    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;selectionStart&#x27;</span> <span class="hljs-keyword">in</span> input) {</pre></div></div>
            
        </li>
        
        
        <li id="section-308">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-308">&#x00a7;</a>
              </div>
              <p>Modern browser with input or textarea.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      selection = {
        <span class="hljs-attr">start</span>: input.<span class="hljs-property">selectionStart</span>,
        <span class="hljs-attr">end</span>: input.<span class="hljs-property">selectionEnd</span>
      };
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-309">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-309">&#x00a7;</a>
              </div>
              <p>Content editable or old IE textarea.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      selection = <span class="hljs-title function_">getOffsets</span>(input);
    }

    <span class="hljs-keyword">return</span> selection || {
      <span class="hljs-attr">start</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">end</span>: <span class="hljs-number">0</span>
    };
  }
  <span class="hljs-comment">/**
   * <span class="hljs-doctag">@setSelection</span>: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -<span class="hljs-doctag">@input</span>     Set selection bounds of this input or textarea
   * -<span class="hljs-doctag">@offsets</span>   Object of same form that is returned from get*
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setSelection</span>(<span class="hljs-params">input, offsets</span>) {
    <span class="hljs-keyword">var</span> start = offsets.<span class="hljs-property">start</span>;
    <span class="hljs-keyword">var</span> end = offsets.<span class="hljs-property">end</span>;

    <span class="hljs-keyword">if</span> (end === <span class="hljs-literal">undefined</span>) {
      end = start;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;selectionStart&#x27;</span> <span class="hljs-keyword">in</span> input) {
      input.<span class="hljs-property">selectionStart</span> = start;
      input.<span class="hljs-property">selectionEnd</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(end, input.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">setOffsets</span>(input, offsets);
    }
  }

  <span class="hljs-keyword">var</span> skipSelectionChangeEvent = canUseDOM &amp;&amp; <span class="hljs-string">&#x27;documentMode&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-variable language_">document</span> &amp;&amp; <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentMode</span> &lt;= <span class="hljs-number">11</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerEvents$3</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">registerTwoPhaseEvent</span>(<span class="hljs-string">&#x27;onSelect&#x27;</span>, [<span class="hljs-string">&#x27;focusout&#x27;</span>, <span class="hljs-string">&#x27;contextmenu&#x27;</span>, <span class="hljs-string">&#x27;dragend&#x27;</span>, <span class="hljs-string">&#x27;focusin&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;mousedown&#x27;</span>, <span class="hljs-string">&#x27;mouseup&#x27;</span>, <span class="hljs-string">&#x27;selectionchange&#x27;</span>]);
  }

  <span class="hljs-keyword">var</span> activeElement$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> activeElementInst$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> lastSelection = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> mouseDown = <span class="hljs-literal">false</span>;
  <span class="hljs-comment">/**
   * Get an object which is a unique representation of the current selection.
   *
   * The return value will not be consistent across nodes or browsers, but
   * two identical selections on the same node will return identical objects.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getSelection$1</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;selectionStart&#x27;</span> <span class="hljs-keyword">in</span> node &amp;&amp; <span class="hljs-title function_">hasSelectionCapabilities</span>(node)) {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">start</span>: node.<span class="hljs-property">selectionStart</span>,
        <span class="hljs-attr">end</span>: node.<span class="hljs-property">selectionEnd</span>
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> win = node.<span class="hljs-property">ownerDocument</span> &amp;&amp; node.<span class="hljs-property">ownerDocument</span>.<span class="hljs-property">defaultView</span> || <span class="hljs-variable language_">window</span>;
      <span class="hljs-keyword">var</span> selection = win.<span class="hljs-title function_">getSelection</span>();
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">anchorNode</span>: selection.<span class="hljs-property">anchorNode</span>,
        <span class="hljs-attr">anchorOffset</span>: selection.<span class="hljs-property">anchorOffset</span>,
        <span class="hljs-attr">focusNode</span>: selection.<span class="hljs-property">focusNode</span>,
        <span class="hljs-attr">focusOffset</span>: selection.<span class="hljs-property">focusOffset</span>
      };
    }
  }
  <span class="hljs-comment">/**
   * Get document associated with the event target.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEventTargetDocument</span>(<span class="hljs-params">eventTarget</span>) {
    <span class="hljs-keyword">return</span> eventTarget.<span class="hljs-property">window</span> === eventTarget ? eventTarget.<span class="hljs-property">document</span> : eventTarget.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_NODE</span> ? eventTarget : eventTarget.<span class="hljs-property">ownerDocument</span>;
  }
  <span class="hljs-comment">/**
   * Poll selection to see whether it&#x27;s changed.
   *
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">nativeEvent</span>
   * <span class="hljs-doctag">@param</span> {<span class="hljs-type">object</span>} <span class="hljs-variable">nativeEventTarget</span>
   * <span class="hljs-doctag">@return</span> {<span class="hljs-type">?SyntheticEvent</span>}
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">constructSelectEvent</span>(<span class="hljs-params">dispatchQueue, nativeEvent, nativeEventTarget</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-310">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-310">&#x00a7;</a>
              </div>
              <p>Ensure we have the right element, and that the user is not dragging a
selection (this matches native <code>select</code> event behavior). In HTML5, select
fires only on input and textarea thus if there’s no focused element we
won’t dispatch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> doc = <span class="hljs-title function_">getEventTargetDocument</span>(nativeEventTarget);

    <span class="hljs-keyword">if</span> (mouseDown || activeElement$<span class="hljs-number">1</span> == <span class="hljs-literal">null</span> || activeElement$<span class="hljs-number">1</span> !== <span class="hljs-title function_">getActiveElement</span>(doc)) {
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// Only fire when selection has actually changed.</span>


    <span class="hljs-keyword">var</span> currentSelection = <span class="hljs-title function_">getSelection$1</span>(activeElement$<span class="hljs-number">1</span>);

    <span class="hljs-keyword">if</span> (!lastSelection || !<span class="hljs-title function_">shallowEqual</span>(lastSelection, currentSelection)) {
      lastSelection = currentSelection;
      <span class="hljs-keyword">var</span> listeners = <span class="hljs-title function_">accumulateTwoPhaseListeners</span>(activeElementInst$<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;onSelect&#x27;</span>);

      <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEvent</span>(<span class="hljs-string">&#x27;onSelect&#x27;</span>, <span class="hljs-string">&#x27;select&#x27;</span>, <span class="hljs-literal">null</span>, nativeEvent, nativeEventTarget);
        dispatchQueue.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">event</span>: event,
          <span class="hljs-attr">listeners</span>: listeners
        });
        event.<span class="hljs-property">target</span> = activeElement$<span class="hljs-number">1</span>;
      }
    }
  }
  <span class="hljs-comment">/**
   * This plugin creates an `onSelect` event that normalizes select events
   * across form elements.
   *
   * Supported elements are:
   * - input (see `isTextInputElement`)
   * - textarea
   * - contentEditable
   *
   * This differs from native browser implementations in the following ways:
   * - Fires on contentEditable fields as well as inputs.
   * - Fires for collapsed selection.
   * - Fires after user input.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents$3</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer</span>) {

    <span class="hljs-keyword">var</span> targetNode = targetInst ? <span class="hljs-title function_">getNodeFromInstance</span>(targetInst) : <span class="hljs-variable language_">window</span>;

    <span class="hljs-keyword">switch</span> (domEventName) {</pre></div></div>
            
        </li>
        
        
        <li id="section-311">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-311">&#x00a7;</a>
              </div>
              <p>Track the input node that has focus.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusin&#x27;</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isTextInputElement</span>(targetNode) || targetNode.<span class="hljs-property">contentEditable</span> === <span class="hljs-string">&#x27;true&#x27;</span>) {
          activeElement$<span class="hljs-number">1</span> = targetNode;
          activeElementInst$<span class="hljs-number">1</span> = targetInst;
          lastSelection = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusout&#x27;</span>:
        activeElement$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
        activeElementInst$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
        lastSelection = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-312">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-312">&#x00a7;</a>
              </div>
              <p>Don’t fire the event while the user is dragging. This matches the
semantics of the native select event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mousedown&#x27;</span>:
        mouseDown = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;contextmenu&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseup&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragend&#x27;</span>:
        mouseDown = <span class="hljs-literal">false</span>;
        <span class="hljs-title function_">constructSelectEvent</span>(dispatchQueue, nativeEvent, nativeEventTarget);
        <span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-313">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-313">&#x00a7;</a>
              </div>
              <p>Chrome and IE fire non-standard event when selection is changed (and
sometimes when it hasn’t). IE’s event fires out of order with respect
to key and input events on deletion, so we discard it.</p>
<p>Firefox doesn’t support selectionchange, so check selection status
after each key entry. The selection changes after keydown and before
keyup, but we check on keydown as well in the case of holding down a
key, when multiple keydown events are fired but only one keyup is.
This is also our approach for IE handling, for the reason above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;selectionchange&#x27;</span>:
        <span class="hljs-keyword">if</span> (skipSelectionChangeEvent) {
          <span class="hljs-keyword">break</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-314">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-314">&#x00a7;</a>
              </div>
              <p>falls through</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keydown&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keyup&#x27;</span>:
        <span class="hljs-title function_">constructSelectEvent</span>(dispatchQueue, nativeEvent, nativeEventTarget);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents$4</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer</span>) {
    <span class="hljs-keyword">var</span> reactName = topLevelEventsToReactNames.<span class="hljs-title function_">get</span>(domEventName);

    <span class="hljs-keyword">if</span> (reactName === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticEvent</span>;
    <span class="hljs-keyword">var</span> reactEventType = domEventName;

    <span class="hljs-keyword">switch</span> (domEventName) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keypress&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-315">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-315">&#x00a7;</a>
              </div>
              <p>Firefox creates a keypress event for function keys too. This removes
the unwanted keypress events. Enter is however both printable and
non-printable. One would expect Tab to be as well (but it isn’t).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getEventCharCode</span>(nativeEvent) === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-comment">/* falls through */</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keydown&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;keyup&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticKeyboardEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusin&#x27;</span>:
        reactEventType = <span class="hljs-string">&#x27;focus&#x27;</span>;
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticFocusEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;focusout&#x27;</span>:
        reactEventType = <span class="hljs-string">&#x27;blur&#x27;</span>;
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticFocusEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;beforeblur&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;afterblur&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticFocusEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;click&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-316">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-316">&#x00a7;</a>
              </div>
              <p>Firefox creates a click event on right mouse clicks. This removes the
unwanted click events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (nativeEvent.<span class="hljs-property">button</span> === <span class="hljs-number">2</span>) {
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-comment">/* falls through */</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;auxclick&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dblclick&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mousedown&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mousemove&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseup&#x27;</span>: <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Disabled elements should not respond to mouse events</span>

      <span class="hljs-comment">/* falls through */</span>

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseout&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;mouseover&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;contextmenu&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticMouseEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;drag&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragend&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragenter&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragexit&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragleave&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragover&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dragstart&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;drop&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticDragEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;touchcancel&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;touchend&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;touchmove&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;touchstart&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticTouchEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-attr">ANIMATION_END</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-attr">ANIMATION_ITERATION</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-attr">ANIMATION_START</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticAnimationEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-attr">TRANSITION_END</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticTransitionEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;scroll&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">Synthetic</span>UIEvent;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;wheel&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticWheelEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;copy&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;cut&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;paste&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticClipboardEvent</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;gotpointercapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;lostpointercapture&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointercancel&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointerdown&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointermove&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointerout&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointerover&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pointerup&#x27;</span>:
        <span class="hljs-title class_">SyntheticEventCtor</span> = <span class="hljs-title class_">SyntheticPointerEvent</span>;
        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">var</span> inCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>;

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-317">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-317">&#x00a7;</a>
              </div>
              <p>Some events don’t bubble in the browser.
In the past, React has always bubbled them, but this can be surprising.
We’re going to try aligning closer to the browser behavior by not bubbling
them in React either. We’ll start by not bubbling onScroll, and then expand.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> accumulateTargetOnly = !inCapturePhase &amp;&amp; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> ideally, we&#x27;d eventually add all events from</span></pre></div></div>
            
        </li>
        
        
        <li id="section-318">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-318">&#x00a7;</a>
              </div>
              <p>nonDelegatedEvents list in DOMPluginEventSystem.
Then we can remove this special list.
This is a breaking change that can wait until React 18.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        domEventName === <span class="hljs-string">&#x27;scroll&#x27;</span>;

      <span class="hljs-keyword">var</span> _listeners = <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(targetInst, reactName, nativeEvent.<span class="hljs-property">type</span>, inCapturePhase, accumulateTargetOnly);

      <span class="hljs-keyword">if</span> (_listeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-319">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-319">&#x00a7;</a>
              </div>
              <p>Intentionally create event lazily.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> _event = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyntheticEventCtor</span>(reactName, reactEventType, <span class="hljs-literal">null</span>, nativeEvent, nativeEventTarget);

        dispatchQueue.<span class="hljs-title function_">push</span>({
          <span class="hljs-attr">event</span>: _event,
          <span class="hljs-attr">listeners</span>: _listeners
        });
      }
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-320">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-320">&#x00a7;</a>
              </div>
              <p>TODO: remove top-level side effect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-title function_">registerSimpleEvents</span>();
  <span class="hljs-title function_">registerEvents$2</span>();
  <span class="hljs-title function_">registerEvents$1</span>();
  <span class="hljs-title function_">registerEvents$3</span>();
  <span class="hljs-title function_">registerEvents</span>();

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">extractEvents$5</span>(<span class="hljs-params">dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-321">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-321">&#x00a7;</a>
              </div>
              <p>TODO: we should remove the concept of a “SimpleEventPlugin”.
This is the basic functionality of the event system. All
the other plugins are essentially polyfills. So the plugin
should probably be inlined somewhere and have its logic
be core the to event system. This would potentially allow
us to ship builds of React without the polyfilled plugins below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">extractEvents$4</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
    <span class="hljs-keyword">var</span> shouldProcessPolyfillPlugins = (eventSystemFlags &amp; <span class="hljs-variable constant_">SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS</span>) === <span class="hljs-number">0</span>; <span class="hljs-comment">// We don&#x27;t process these events unless we are in the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-322">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-322">&#x00a7;</a>
              </div>
              <p>event’s native “bubble” phase, which means that we’re
not in the capture phase. That’s because we emulate
the capture phase here still. This is a trade-off,
because in an ideal world we would not emulate and use
the phases properly, like we do with the SimpleEvent
plugin. However, the plugins below either expect
emulation (EnterLeave) or use state localized to that
plugin (BeforeInput, Change, Select). The state in
these modules complicates things, as you’ll essentially
get the case where the capture phase event might change
state, only for the following bubble event to come in
later and not trigger anything as the state now
invalidates the heuristics of the event plugin. We
could alter all these plugins to work in such ways, but
that might cause other unknown side-effects that we
can’t forsee right now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (shouldProcessPolyfillPlugins) {
      <span class="hljs-title function_">extractEvents$2</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
      <span class="hljs-title function_">extractEvents$1</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      <span class="hljs-title function_">extractEvents$3</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      <span class="hljs-title function_">extractEvents</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    }
  } <span class="hljs-comment">// List of events that need to be individually attached to media elements.</span>


  <span class="hljs-keyword">var</span> mediaEventTypes = [<span class="hljs-string">&#x27;abort&#x27;</span>, <span class="hljs-string">&#x27;canplay&#x27;</span>, <span class="hljs-string">&#x27;canplaythrough&#x27;</span>, <span class="hljs-string">&#x27;durationchange&#x27;</span>, <span class="hljs-string">&#x27;emptied&#x27;</span>, <span class="hljs-string">&#x27;encrypted&#x27;</span>, <span class="hljs-string">&#x27;ended&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-string">&#x27;loadeddata&#x27;</span>, <span class="hljs-string">&#x27;loadedmetadata&#x27;</span>, <span class="hljs-string">&#x27;loadstart&#x27;</span>, <span class="hljs-string">&#x27;pause&#x27;</span>, <span class="hljs-string">&#x27;play&#x27;</span>, <span class="hljs-string">&#x27;playing&#x27;</span>, <span class="hljs-string">&#x27;progress&#x27;</span>, <span class="hljs-string">&#x27;ratechange&#x27;</span>, <span class="hljs-string">&#x27;seeked&#x27;</span>, <span class="hljs-string">&#x27;seeking&#x27;</span>, <span class="hljs-string">&#x27;stalled&#x27;</span>, <span class="hljs-string">&#x27;suspend&#x27;</span>, <span class="hljs-string">&#x27;timeupdate&#x27;</span>, <span class="hljs-string">&#x27;volumechange&#x27;</span>, <span class="hljs-string">&#x27;waiting&#x27;</span>]; <span class="hljs-comment">// We should not delegate these events to the container, but rather</span></pre></div></div>
            
        </li>
        
        
        <li id="section-323">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-323">&#x00a7;</a>
              </div>
              <p>set them on the actual target element itself. This is primarily
because these events do not consistently bubble in the DOM.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> nonDelegatedEvents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;cancel&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;invalid&#x27;</span>, <span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-string">&#x27;toggle&#x27;</span>].<span class="hljs-title function_">concat</span>(mediaEventTypes));

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">executeDispatch</span>(<span class="hljs-params">event, listener, currentTarget</span>) {
    <span class="hljs-keyword">var</span> type = event.<span class="hljs-property">type</span> || <span class="hljs-string">&#x27;unknown-event&#x27;</span>;
    event.<span class="hljs-property">currentTarget</span> = currentTarget;
    <span class="hljs-title function_">invokeGuardedCallbackAndCatchFirstError</span>(type, listener, <span class="hljs-literal">undefined</span>, event);
    event.<span class="hljs-property">currentTarget</span> = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(<span class="hljs-params">event, dispatchListeners, inCapturePhase</span>) {
    <span class="hljs-keyword">var</span> previousInstance;

    <span class="hljs-keyword">if</span> (inCapturePhase) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = dispatchListeners.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">var</span> _dispatchListeners$i = dispatchListeners[i],
          instance = _dispatchListeners$i.<span class="hljs-property">instance</span>,
          currentTarget = _dispatchListeners$i.<span class="hljs-property">currentTarget</span>,
          listener = _dispatchListeners$i.<span class="hljs-property">listener</span>;

        <span class="hljs-keyword">if</span> (instance !== previousInstance &amp;&amp; event.<span class="hljs-title function_">isPropagationStopped</span>()) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-title function_">executeDispatch</span>(event, listener, currentTarget);
        previousInstance = instance;
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; dispatchListeners.<span class="hljs-property">length</span>; _i++) {
        <span class="hljs-keyword">var</span> _dispatchListeners$_i = dispatchListeners[_i],
          _instance = _dispatchListeners$_i.<span class="hljs-property">instance</span>,
          _currentTarget = _dispatchListeners$_i.<span class="hljs-property">currentTarget</span>,
          _listener = _dispatchListeners$_i.<span class="hljs-property">listener</span>;

        <span class="hljs-keyword">if</span> (_instance !== previousInstance &amp;&amp; event.<span class="hljs-title function_">isPropagationStopped</span>()) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-title function_">executeDispatch</span>(event, _listener, _currentTarget);
        previousInstance = _instance;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">processDispatchQueue</span>(<span class="hljs-params">dispatchQueue, eventSystemFlags</span>) {
    <span class="hljs-keyword">var</span> inCapturePhase = (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>) !== <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dispatchQueue.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">var</span> _dispatchQueue$i = dispatchQueue[i],
        event = _dispatchQueue$i.<span class="hljs-property">event</span>,
        listeners = _dispatchQueue$i.<span class="hljs-property">listeners</span>;
      <span class="hljs-title function_">processDispatchQueueItemsInOrder</span>(event, listeners, inCapturePhase); <span class="hljs-comment">//  event system doesn&#x27;t use pooling.</span>
    } <span class="hljs-comment">// This would be a good time to rethrow if any of the event handlers threw.</span>


    <span class="hljs-title function_">rethrowCaughtError</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventsForPlugins</span>(<span class="hljs-params">domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer</span>) {
    <span class="hljs-keyword">var</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent);
    <span class="hljs-keyword">var</span> dispatchQueue = [];
    <span class="hljs-title function_">extractEvents$5</span>(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
    <span class="hljs-title function_">processDispatchQueue</span>(dispatchQueue, eventSystemFlags);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-params">domEventName, targetElement</span>) {
    <span class="hljs-keyword">var</span> isCapturePhaseListener = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> listenerSet = <span class="hljs-title function_">getEventListenerSet</span>(targetElement);
    <span class="hljs-keyword">var</span> listenerSetKey = <span class="hljs-title function_">getListenerSetKey</span>(domEventName, isCapturePhaseListener);

    <span class="hljs-keyword">if</span> (!listenerSet.<span class="hljs-title function_">has</span>(listenerSetKey)) {
      <span class="hljs-title function_">addTrappedEventListener</span>(targetElement, domEventName, <span class="hljs-variable constant_">IS_NON_DELEGATED</span>, isCapturePhaseListener);
      listenerSet.<span class="hljs-title function_">add</span>(listenerSetKey);
    }
  }
  <span class="hljs-keyword">var</span> listeningMarker = <span class="hljs-string">&#x27;_reactListening&#x27;</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">listenToAllSupportedEvents</span>(<span class="hljs-params">rootContainerElement</span>) {
    {
      <span class="hljs-keyword">if</span> (rootContainerElement[listeningMarker]) {</pre></div></div>
            
        </li>
        
        
        <li id="section-324">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-324">&#x00a7;</a>
              </div>
              <p>Performance optimization: don’t iterate through events
for the same portal container or root node more than once.
TODO: once we remove the flag, we may be able to also
remove some of the bookkeeping maps used for laziness.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }

      rootContainerElement[listeningMarker] = <span class="hljs-literal">true</span>;
      allNativeEvents.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">domEventName</span>) {
        <span class="hljs-keyword">if</span> (!nonDelegatedEvents.<span class="hljs-title function_">has</span>(domEventName)) {
          <span class="hljs-title function_">listenToNativeEvent</span>(domEventName, <span class="hljs-literal">false</span>, rootContainerElement, <span class="hljs-literal">null</span>);
        }

        <span class="hljs-title function_">listenToNativeEvent</span>(domEventName, <span class="hljs-literal">true</span>, rootContainerElement, <span class="hljs-literal">null</span>);
      });
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">listenToNativeEvent</span>(<span class="hljs-params">domEventName, isCapturePhaseListener, rootContainerElement, targetElement</span>) {
    <span class="hljs-keyword">var</span> eventSystemFlags = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">4</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">4</span>] : <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> target = rootContainerElement; <span class="hljs-comment">// selectionchange needs to be attached to the document</span></pre></div></div>
            
        </li>
        
        
        <li id="section-325">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-325">&#x00a7;</a>
              </div>
              <p>otherwise it won’t capture incoming events that are only
triggered on the document directly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;selectionchange&#x27;</span> &amp;&amp; rootContainerElement.<span class="hljs-property">nodeType</span> !== <span class="hljs-variable constant_">DOCUMENT_NODE</span>) {
      target = rootContainerElement.<span class="hljs-property">ownerDocument</span>;
    } <span class="hljs-comment">// If the event can be delegated (or is capture phase), we can</span></pre></div></div>
            
        </li>
        
        
        <li id="section-326">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-326">&#x00a7;</a>
              </div>
              <p>register it to the root container. Otherwise, we should
register the event to the target element and mark it as
a non-delegated event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (targetElement !== <span class="hljs-literal">null</span> &amp;&amp; !isCapturePhaseListener &amp;&amp; nonDelegatedEvents.<span class="hljs-title function_">has</span>(domEventName)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-327">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-327">&#x00a7;</a>
              </div>
              <p>For all non-delegated events, apart from scroll, we attach
their event listeners to the respective elements that their
events fire on. That means we can skip this step, as event
listener has already been added previously. However, we
special case the scroll event because the reality is that any
element can scroll.
TODO: ideally, we’d eventually apply the same logic to all
events from the nonDelegatedEvents list. Then we can remove
this special case and use the same logic for all events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (domEventName !== <span class="hljs-string">&#x27;scroll&#x27;</span>) {
        <span class="hljs-keyword">return</span>;
      }

      eventSystemFlags |= <span class="hljs-variable constant_">IS_NON_DELEGATED</span>;
      target = targetElement;
    }

    <span class="hljs-keyword">var</span> listenerSet = <span class="hljs-title function_">getEventListenerSet</span>(target);
    <span class="hljs-keyword">var</span> listenerSetKey = <span class="hljs-title function_">getListenerSetKey</span>(domEventName, isCapturePhaseListener); <span class="hljs-comment">// If the listener entry is empty or we should upgrade, then</span></pre></div></div>
            
        </li>
        
        
        <li id="section-328">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-328">&#x00a7;</a>
              </div>
              <p>we need to trap an event listener onto the target.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!listenerSet.<span class="hljs-title function_">has</span>(listenerSetKey)) {
      <span class="hljs-keyword">if</span> (isCapturePhaseListener) {
        eventSystemFlags |= <span class="hljs-variable constant_">IS_CAPTURE_PHASE</span>;
      }

      <span class="hljs-title function_">addTrappedEventListener</span>(target, domEventName, eventSystemFlags, isCapturePhaseListener);
      listenerSet.<span class="hljs-title function_">add</span>(listenerSetKey);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addTrappedEventListener</span>(<span class="hljs-params">targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport</span>) {
    <span class="hljs-keyword">var</span> listener = <span class="hljs-title function_">createEventListenerWrapperWithPriority</span>(targetContainer, domEventName, eventSystemFlags); <span class="hljs-comment">// If passive option is not supported, then the event will be</span></pre></div></div>
            
        </li>
        
        
        <li id="section-329">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-329">&#x00a7;</a>
              </div>
              <p>active and not passive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> isPassiveListener = <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">if</span> (passiveBrowserEventsSupported) {</pre></div></div>
            
        </li>
        
        
        <li id="section-330">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-330">&#x00a7;</a>
              </div>
              <p>Browsers introduced an intervention, making these events
passive by default on document. React doesn’t bind them
to document anymore, but changing this now would undo
the performance wins from the change. So we emulate
the existing behavior manually on the roots now.
<a href="https://github.com/facebook/react/issues/19651">https://github.com/facebook/react/issues/19651</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (domEventName === <span class="hljs-string">&#x27;touchstart&#x27;</span> || domEventName === <span class="hljs-string">&#x27;touchmove&#x27;</span> || domEventName === <span class="hljs-string">&#x27;wheel&#x27;</span>) {
        isPassiveListener = <span class="hljs-literal">true</span>;
      }
    }

    targetContainer = targetContainer;
    <span class="hljs-keyword">var</span> unsubscribeListener; <span class="hljs-comment">// When legacyFBSupport is enabled, it&#x27;s for when we</span>


    <span class="hljs-keyword">if</span> (isCapturePhaseListener) {
      <span class="hljs-keyword">if</span> (isPassiveListener !== <span class="hljs-literal">undefined</span>) {
        unsubscribeListener = <span class="hljs-title function_">addEventCaptureListenerWithPassiveFlag</span>(targetContainer, domEventName, listener, isPassiveListener);
      } <span class="hljs-keyword">else</span> {
        unsubscribeListener = <span class="hljs-title function_">addEventCaptureListener</span>(targetContainer, domEventName, listener);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (isPassiveListener !== <span class="hljs-literal">undefined</span>) {
        unsubscribeListener = <span class="hljs-title function_">addEventBubbleListenerWithPassiveFlag</span>(targetContainer, domEventName, listener, isPassiveListener);
      } <span class="hljs-keyword">else</span> {
        unsubscribeListener = <span class="hljs-title function_">addEventBubbleListener</span>(targetContainer, domEventName, listener);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isMatchingRootContainer</span>(<span class="hljs-params">grandContainer, targetContainer</span>) {
    <span class="hljs-keyword">return</span> grandContainer === targetContainer || grandContainer.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span> &amp;&amp; grandContainer.<span class="hljs-property">parentNode</span> === targetContainer;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventForPluginEventSystem</span>(<span class="hljs-params">domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer</span>) {
    <span class="hljs-keyword">var</span> ancestorInst = targetInst;

    <span class="hljs-keyword">if</span> ((eventSystemFlags &amp; <span class="hljs-variable constant_">IS_EVENT_HANDLE_NON_MANAGED_NODE</span>) === <span class="hljs-number">0</span> &amp;&amp; (eventSystemFlags &amp; <span class="hljs-variable constant_">IS_NON_DELEGATED</span>) === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> targetContainerNode = targetContainer; <span class="hljs-comment">// If we are using the legacy FB support flag, we</span>

      <span class="hljs-keyword">if</span> (targetInst !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-331">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-331">&#x00a7;</a>
              </div>
              <p>The below logic attempts to work out if we need to change
the target fiber to a different ancestor. We had similar logic
in the legacy event system, except the big difference between
systems is that the modern event system now has an event listener
attached to each React Root and React Portal Root. Together,
the DOM nodes representing these roots are the “rootContainer”.
To figure out which ancestor instance we should use, we traverse
up the fiber tree from the target instance and attempt to find
root boundaries that match that of our current “rootContainer”.
If we find that “rootContainer”, we find the parent fiber
sub-tree for that root and make that our ancestor instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> node = targetInst;

        <span class="hljs-attr">mainLoop</span>: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">if</span> (node === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">var</span> nodeTag = node.<span class="hljs-property">tag</span>;

          <span class="hljs-keyword">if</span> (nodeTag === <span class="hljs-title class_">HostRoot</span> || nodeTag === <span class="hljs-title class_">HostPortal</span>) {
            <span class="hljs-keyword">var</span> container = node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>;

            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMatchingRootContainer</span>(container, targetContainerNode)) {
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">if</span> (nodeTag === <span class="hljs-title class_">HostPortal</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-332">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-332">&#x00a7;</a>
              </div>
              <p>The target is a portal, but it’s not the rootContainer we’re looking for.
Normally portals handle their own events all the way down to the root.
So we should be able to stop now. However, we don’t know if this portal
was part of <em>our</em> root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> grandNode = node.<span class="hljs-property">return</span>;

              <span class="hljs-keyword">while</span> (grandNode !== <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">var</span> grandTag = grandNode.<span class="hljs-property">tag</span>;

                <span class="hljs-keyword">if</span> (grandTag === <span class="hljs-title class_">HostRoot</span> || grandTag === <span class="hljs-title class_">HostPortal</span>) {
                  <span class="hljs-keyword">var</span> grandContainer = grandNode.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>;

                  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isMatchingRootContainer</span>(grandContainer, targetContainerNode)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-333">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-333">&#x00a7;</a>
              </div>
              <p>This is the rootContainer we’re looking for and we found it as
a parent of the Portal. That means we can ignore it because the
Portal will bubble through to us.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">return</span>;
                  }
                }

                grandNode = grandNode.<span class="hljs-property">return</span>;
              }
            } <span class="hljs-comment">// Now we need to find it&#x27;s corresponding host fiber in the other</span></pre></div></div>
            
        </li>
        
        
        <li id="section-334">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-334">&#x00a7;</a>
              </div>
              <p>tree. To do this we can use getClosestInstanceFromNode, but we
need to validate that the fiber is a host instance, otherwise
we need to traverse up through the DOM till we find the correct
node that is from the other tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

            <span class="hljs-keyword">while</span> (container !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> parentNode = <span class="hljs-title function_">getClosestInstanceFromNode</span>(container);

              <span class="hljs-keyword">if</span> (parentNode === <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span>;
              }

              <span class="hljs-keyword">var</span> parentTag = parentNode.<span class="hljs-property">tag</span>;

              <span class="hljs-keyword">if</span> (parentTag === <span class="hljs-title class_">HostComponent</span> || parentTag === <span class="hljs-title class_">HostText</span>) {
                node = ancestorInst = parentNode;
                <span class="hljs-keyword">continue</span> mainLoop;
              }

              container = container.<span class="hljs-property">parentNode</span>;
            }
          }

          node = node.<span class="hljs-property">return</span>;
        }
      }
    }

    <span class="hljs-title function_">batchedEventUpdates</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">dispatchEventsForPlugins</span>(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
    });
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createDispatchListener</span>(<span class="hljs-params">instance, listener, currentTarget</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">instance</span>: instance,
      <span class="hljs-attr">listener</span>: listener,
      <span class="hljs-attr">currentTarget</span>: currentTarget
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateSinglePhaseListeners</span>(<span class="hljs-params">targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly</span>) {
    <span class="hljs-keyword">var</span> captureName = reactName !== <span class="hljs-literal">null</span> ? reactName + <span class="hljs-string">&#x27;Capture&#x27;</span> : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> reactEventName = inCapturePhase ? captureName : reactName;
    <span class="hljs-keyword">var</span> listeners = [];
    <span class="hljs-keyword">var</span> instance = targetFiber;
    <span class="hljs-keyword">var</span> lastHostComponent = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Accumulate all instances and listeners via the target -&gt; root path.</span>

    <span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _instance2 = instance,
        stateNode = _instance2.<span class="hljs-property">stateNode</span>,
        tag = _instance2.<span class="hljs-property">tag</span>; <span class="hljs-comment">// Handle listeners that are on HostComponents (i.e. &lt;div&gt;)</span>

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="hljs-literal">null</span>) {
        lastHostComponent = stateNode; <span class="hljs-comment">// createEventHandle listeners</span>


        <span class="hljs-keyword">if</span> (reactEventName !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> listener = <span class="hljs-title function_">getListener</span>(instance, reactEventName);

          <span class="hljs-keyword">if</span> (listener != <span class="hljs-literal">null</span>) {
            listeners.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createDispatchListener</span>(instance, listener, lastHostComponent));
          }
        }
      } <span class="hljs-comment">// If we are only accumulating events for the target, then we don&#x27;t</span></pre></div></div>
            
        </li>
        
        
        <li id="section-335">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-335">&#x00a7;</a>
              </div>
              <p>continue to propagate through the React fiber tree to find other
listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (accumulateTargetOnly) {
        <span class="hljs-keyword">break</span>;
      }

      instance = instance.<span class="hljs-property">return</span>;
    }

    <span class="hljs-keyword">return</span> listeners;
  } <span class="hljs-comment">// We should only use this function for:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-336">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-336">&#x00a7;</a>
              </div>
              <ul>
<li>BeforeInputEventPlugin</li>
<li>ChangeEventPlugin</li>
<li>SelectEventPlugin
This is because we only process these plugins
in the bubble phase, so we need to accumulate two
phase event listeners (via emulation).</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateTwoPhaseListeners</span>(<span class="hljs-params">targetFiber, reactName</span>) {
    <span class="hljs-keyword">var</span> captureName = reactName + <span class="hljs-string">&#x27;Capture&#x27;</span>;
    <span class="hljs-keyword">var</span> listeners = [];
    <span class="hljs-keyword">var</span> instance = targetFiber; <span class="hljs-comment">// Accumulate all instances and listeners via the target -&gt; root path.</span>

    <span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> _instance3 = instance,
        stateNode = _instance3.<span class="hljs-property">stateNode</span>,
        tag = _instance3.<span class="hljs-property">tag</span>; <span class="hljs-comment">// Handle listeners that are on HostComponents (i.e. &lt;div&gt;)</span>

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> currentTarget = stateNode;
        <span class="hljs-keyword">var</span> captureListener = <span class="hljs-title function_">getListener</span>(instance, captureName);

        <span class="hljs-keyword">if</span> (captureListener != <span class="hljs-literal">null</span>) {
          listeners.<span class="hljs-title function_">unshift</span>(<span class="hljs-title function_">createDispatchListener</span>(instance, captureListener, currentTarget));
        }

        <span class="hljs-keyword">var</span> bubbleListener = <span class="hljs-title function_">getListener</span>(instance, reactName);

        <span class="hljs-keyword">if</span> (bubbleListener != <span class="hljs-literal">null</span>) {
          listeners.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createDispatchListener</span>(instance, bubbleListener, currentTarget));
        }
      }

      instance = instance.<span class="hljs-property">return</span>;
    }

    <span class="hljs-keyword">return</span> listeners;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getParent</span>(<span class="hljs-params">inst</span>) {
    <span class="hljs-keyword">if</span> (inst === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">do</span> {
      inst = inst.<span class="hljs-property">return</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If this is a HostRoot we might want to bail out.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-337">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-337">&#x00a7;</a>
              </div>
              <p>That is depending on if we want nested subtrees (layers) to bubble
events to their parent. We could also go through parentNode on the
host node but that wouldn’t work for React Native and doesn’t let us
do the portal feature.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    } <span class="hljs-keyword">while</span> (inst &amp;&amp; inst.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostComponent</span>);

    <span class="hljs-keyword">if</span> (inst) {
      <span class="hljs-keyword">return</span> inst;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">/**
   * Return the lowest common ancestor of A and B, or null if they are in
   * different trees.
   */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getLowestCommonAncestor</span>(<span class="hljs-params">instA, instB</span>) {
    <span class="hljs-keyword">var</span> nodeA = instA;
    <span class="hljs-keyword">var</span> nodeB = instB;
    <span class="hljs-keyword">var</span> depthA = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> tempA = nodeA; tempA; tempA = <span class="hljs-title function_">getParent</span>(tempA)) {
      depthA++;
    }

    <span class="hljs-keyword">var</span> depthB = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> tempB = nodeB; tempB; tempB = <span class="hljs-title function_">getParent</span>(tempB)) {
      depthB++;
    } <span class="hljs-comment">// If A is deeper, crawl up.</span>


    <span class="hljs-keyword">while</span> (depthA - depthB &gt; <span class="hljs-number">0</span>) {
      nodeA = <span class="hljs-title function_">getParent</span>(nodeA);
      depthA--;
    } <span class="hljs-comment">// If B is deeper, crawl up.</span>


    <span class="hljs-keyword">while</span> (depthB - depthA &gt; <span class="hljs-number">0</span>) {
      nodeB = <span class="hljs-title function_">getParent</span>(nodeB);
      depthB--;
    } <span class="hljs-comment">// Walk in lockstep until we find a match.</span>


    <span class="hljs-keyword">var</span> depth = depthA;

    <span class="hljs-keyword">while</span> (depth--) {
      <span class="hljs-keyword">if</span> (nodeA === nodeB || nodeB !== <span class="hljs-literal">null</span> &amp;&amp; nodeA === nodeB.<span class="hljs-property">alternate</span>) {
        <span class="hljs-keyword">return</span> nodeA;
      }

      nodeA = <span class="hljs-title function_">getParent</span>(nodeA);
      nodeB = <span class="hljs-title function_">getParent</span>(nodeB);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateEnterLeaveListenersForEvent</span>(<span class="hljs-params">dispatchQueue, event, target, common, inCapturePhase</span>) {
    <span class="hljs-keyword">var</span> registrationName = event.<span class="hljs-property">_reactName</span>;
    <span class="hljs-keyword">var</span> listeners = [];
    <span class="hljs-keyword">var</span> instance = target;

    <span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (instance === common) {
        <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">var</span> _instance4 = instance,
        alternate = _instance4.<span class="hljs-property">alternate</span>,
        stateNode = _instance4.<span class="hljs-property">stateNode</span>,
        tag = _instance4.<span class="hljs-property">tag</span>;

      <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate === common) {
        <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> currentTarget = stateNode;

        <span class="hljs-keyword">if</span> (inCapturePhase) {
          <span class="hljs-keyword">var</span> captureListener = <span class="hljs-title function_">getListener</span>(instance, registrationName);

          <span class="hljs-keyword">if</span> (captureListener != <span class="hljs-literal">null</span>) {
            listeners.<span class="hljs-title function_">unshift</span>(<span class="hljs-title function_">createDispatchListener</span>(instance, captureListener, currentTarget));
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!inCapturePhase) {
          <span class="hljs-keyword">var</span> bubbleListener = <span class="hljs-title function_">getListener</span>(instance, registrationName);

          <span class="hljs-keyword">if</span> (bubbleListener != <span class="hljs-literal">null</span>) {
            listeners.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">createDispatchListener</span>(instance, bubbleListener, currentTarget));
          }
        }
      }

      instance = instance.<span class="hljs-property">return</span>;
    }

    <span class="hljs-keyword">if</span> (listeners.<span class="hljs-property">length</span> !== <span class="hljs-number">0</span>) {
      dispatchQueue.<span class="hljs-title function_">push</span>({
        <span class="hljs-attr">event</span>: event,
        <span class="hljs-attr">listeners</span>: listeners
      });
    }
  } <span class="hljs-comment">// We should only use this function for:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-338">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-338">&#x00a7;</a>
              </div>
              <ul>
<li>EnterLeaveEventPlugin
This is because we only process this plugin
in the bubble phase, so we need to accumulate two
phase event listeners.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">accumulateEnterLeaveTwoPhaseListeners</span>(<span class="hljs-params">dispatchQueue, leaveEvent, enterEvent, <span class="hljs-keyword">from</span>, to</span>) {
    <span class="hljs-keyword">var</span> common = <span class="hljs-keyword">from</span> &amp;&amp; to ? <span class="hljs-title function_">getLowestCommonAncestor</span>(<span class="hljs-keyword">from</span>, to) : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span> !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">accumulateEnterLeaveListenersForEvent</span>(dispatchQueue, leaveEvent, <span class="hljs-keyword">from</span>, common, <span class="hljs-literal">false</span>);
    }

    <span class="hljs-keyword">if</span> (to !== <span class="hljs-literal">null</span> &amp;&amp; enterEvent !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">accumulateEnterLeaveListenersForEvent</span>(dispatchQueue, enterEvent, to, common, <span class="hljs-literal">true</span>);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getListenerSetKey</span>(<span class="hljs-params">domEventName, capture</span>) {
    <span class="hljs-keyword">return</span> domEventName + <span class="hljs-string">&quot;__&quot;</span> + (capture ? <span class="hljs-string">&#x27;capture&#x27;</span> : <span class="hljs-string">&#x27;bubble&#x27;</span>);
  }

  <span class="hljs-keyword">var</span> didWarnInvalidHydration = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">DANGEROUSLY_SET_INNER_HTML</span> = <span class="hljs-string">&#x27;dangerouslySetInnerHTML&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUPPRESS_CONTENT_EDITABLE_WARNING</span> = <span class="hljs-string">&#x27;suppressContentEditableWarning&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span> = <span class="hljs-string">&#x27;suppressHydrationWarning&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">AUTOFOCUS</span> = <span class="hljs-string">&#x27;autoFocus&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">CHILDREN</span> = <span class="hljs-string">&#x27;children&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">STYLE</span> = <span class="hljs-string">&#x27;style&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">HTML</span>$<span class="hljs-number">1</span> = <span class="hljs-string">&#x27;__html&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">HTML_NAMESPACE</span>$<span class="hljs-number">1</span> = <span class="hljs-title class_">Namespaces</span>.<span class="hljs-property">html</span>;
  <span class="hljs-keyword">var</span> warnedUnknownTags;
  <span class="hljs-keyword">var</span> suppressHydrationWarning;
  <span class="hljs-keyword">var</span> validatePropertiesInDevelopment;
  <span class="hljs-keyword">var</span> warnForTextDifference;
  <span class="hljs-keyword">var</span> warnForPropDifference;
  <span class="hljs-keyword">var</span> warnForExtraAttributes;
  <span class="hljs-keyword">var</span> warnForInvalidEventListener;
  <span class="hljs-keyword">var</span> canDiffStyleForHydrationWarning;
  <span class="hljs-keyword">var</span> normalizeMarkupForTextOrAttribute;
  <span class="hljs-keyword">var</span> normalizeHTML;

  {
    warnedUnknownTags = {</pre></div></div>
            
        </li>
        
        
        <li id="section-339">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-339">&#x00a7;</a>
              </div>
              <p>There are working polyfills for <dialog>. Let people use it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-attr">dialog</span>: <span class="hljs-literal">true</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-340">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-340">&#x00a7;</a>
              </div>
              <p>Electron ships a custom <webview> tag to display external web content in
an isolated frame and process.
This tag is not present in non Electron environments such as JSDom which
is often used for testing purposes.
@see <a href="https://electronjs.org/docs/api/webview-tag">https://electronjs.org/docs/api/webview-tag</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-attr">webview</span>: <span class="hljs-literal">true</span>
    };

    validatePropertiesInDevelopment = <span class="hljs-keyword">function</span> (<span class="hljs-params">type, props</span>) {
      <span class="hljs-title function_">validateProperties</span>(type, props);
      <span class="hljs-title function_">validateProperties$1</span>(type, props);
      <span class="hljs-title function_">validateProperties$2</span>(type, props, {
        <span class="hljs-attr">registrationNameDependencies</span>: registrationNameDependencies,
        <span class="hljs-attr">possibleRegistrationNames</span>: possibleRegistrationNames
      });
    }; <span class="hljs-comment">// IE 11 parses &amp; normalizes the style attribute as opposed to other</span></pre></div></div>
            
        </li>
        
        
        <li id="section-341">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-341">&#x00a7;</a>
              </div>
              <p>browsers. It adds spaces and sorts the properties in some
non-alphabetical order. Handling that would require sorting CSS
properties in the client &amp; server versions or applying
<code>expectedStyle</code> to a temporary DOM node to read its <code>style</code> attribute
normalized. Since it only affects IE, we’re skipping style warnings
in that browser completely in favor of doing all that work.
See <a href="https://github.com/facebook/react/issues/11807">https://github.com/facebook/react/issues/11807</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    canDiffStyleForHydrationWarning = canUseDOM &amp;&amp; !<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentMode</span>; <span class="hljs-comment">// HTML parsing normalizes CR and CRLF to LF.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-342">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-342">&#x00a7;</a>
              </div>
              <p>It also can turn \u0000 into \uFFFD inside attributes.
<a href="https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream">https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream</a>
If we have a mismatch, it might be caused by that.
We will still patch up in this case but not fire the warning.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NORMALIZE_NEWLINES_REGEX</span> = <span class="hljs-regexp">/\r\n?/g</span>;
    <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NORMALIZE_NULL_AND_REPLACEMENT_REGEX</span> = <span class="hljs-regexp">/\u0000|\uFFFD/g</span>;

    normalizeMarkupForTextOrAttribute = <span class="hljs-keyword">function</span> (<span class="hljs-params">markup</span>) {
      <span class="hljs-keyword">var</span> markupString = <span class="hljs-keyword">typeof</span> markup === <span class="hljs-string">&#x27;string&#x27;</span> ? markup : <span class="hljs-string">&#x27;&#x27;</span> + markup;
      <span class="hljs-keyword">return</span> markupString.<span class="hljs-title function_">replace</span>(<span class="hljs-variable constant_">NORMALIZE_NEWLINES_REGEX</span>, <span class="hljs-string">&#x27;\n&#x27;</span>).<span class="hljs-title function_">replace</span>(<span class="hljs-variable constant_">NORMALIZE_NULL_AND_REPLACEMENT_REGEX</span>, <span class="hljs-string">&#x27;&#x27;</span>);
    };

    warnForTextDifference = <span class="hljs-keyword">function</span> (<span class="hljs-params">serverText, clientText</span>) {
      <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> normalizedClientText = <span class="hljs-title function_">normalizeMarkupForTextOrAttribute</span>(clientText);
      <span class="hljs-keyword">var</span> normalizedServerText = <span class="hljs-title function_">normalizeMarkupForTextOrAttribute</span>(serverText);

      <span class="hljs-keyword">if</span> (normalizedServerText === normalizedClientText) {
        <span class="hljs-keyword">return</span>;
      }

      didWarnInvalidHydration = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Text content did not match. Server: &quot;%s&quot; Client: &quot;%s&quot;&#x27;</span>, normalizedServerText, normalizedClientText);
    };

    warnForPropDifference = <span class="hljs-keyword">function</span> (<span class="hljs-params">propName, serverValue, clientValue</span>) {
      <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> normalizedClientValue = <span class="hljs-title function_">normalizeMarkupForTextOrAttribute</span>(clientValue);
      <span class="hljs-keyword">var</span> normalizedServerValue = <span class="hljs-title function_">normalizeMarkupForTextOrAttribute</span>(serverValue);

      <span class="hljs-keyword">if</span> (normalizedServerValue === normalizedClientValue) {
        <span class="hljs-keyword">return</span>;
      }

      didWarnInvalidHydration = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Prop `%s` did not match. Server: %s Client: %s&#x27;</span>, propName, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(normalizedServerValue), <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(normalizedClientValue));
    };

    warnForExtraAttributes = <span class="hljs-keyword">function</span> (<span class="hljs-params">attributeNames</span>) {
      <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
        <span class="hljs-keyword">return</span>;
      }

      didWarnInvalidHydration = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> names = [];
      attributeNames.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">name</span>) {
        names.<span class="hljs-title function_">push</span>(name);
      });

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Extra attributes from the server: %s&#x27;</span>, names);
    };

    warnForInvalidEventListener = <span class="hljs-keyword">function</span> (<span class="hljs-params">registrationName, listener</span>) {
      <span class="hljs-keyword">if</span> (listener === <span class="hljs-literal">false</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected `%s` listener to be a function, instead got `false`.\n\n&#x27;</span> + <span class="hljs-string">&#x27;If you used to conditionally omit it with %s={condition &amp;&amp; value}, &#x27;</span> + <span class="hljs-string">&#x27;pass %s={condition ? value : undefined} instead.&#x27;</span>, registrationName, registrationName, registrationName);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected `%s` listener to be a function, instead got a value of `%s` type.&#x27;</span>, registrationName, <span class="hljs-keyword">typeof</span> listener);
      }
    }; <span class="hljs-comment">// Parse the HTML and read it back to normalize the HTML string so that it</span></pre></div></div>
            
        </li>
        
        
        <li id="section-343">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-343">&#x00a7;</a>
              </div>
              <p>can be used for comparison.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    normalizeHTML = <span class="hljs-keyword">function</span> (<span class="hljs-params">parent, html</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-344">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-344">&#x00a7;</a>
              </div>
              <p>We could have created a separate document here to avoid
re-initializing custom elements if they exist. But this breaks
how <noscript> is being handled. So we use the same document.
See the discussion in <a href="https://github.com/facebook/react/pull/11157">https://github.com/facebook/react/pull/11157</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> testElement = parent.<span class="hljs-property">namespaceURI</span> === <span class="hljs-variable constant_">HTML_NAMESPACE</span>$<span class="hljs-number">1</span> ? parent.<span class="hljs-property">ownerDocument</span>.<span class="hljs-title function_">createElement</span>(parent.<span class="hljs-property">tagName</span>) : parent.<span class="hljs-property">ownerDocument</span>.<span class="hljs-title function_">createElementNS</span>(parent.<span class="hljs-property">namespaceURI</span>, parent.<span class="hljs-property">tagName</span>);
      testElement.<span class="hljs-property">innerHTML</span> = html;
      <span class="hljs-keyword">return</span> testElement.<span class="hljs-property">innerHTML</span>;
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getOwnerDocumentFromRootContainer</span>(<span class="hljs-params">rootContainerElement</span>) {
    <span class="hljs-keyword">return</span> rootContainerElement.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_NODE</span> ? rootContainerElement : rootContainerElement.<span class="hljs-property">ownerDocument</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">noop</span>(<span class="hljs-params"></span>) { }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">trapClickOnNonInteractiveElement</span>(<span class="hljs-params">node</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-345">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-345">&#x00a7;</a>
              </div>
              <p>Mobile Safari does not fire properly bubble click events on
non-interactive elements, which means delegated click listeners do not
fire. The workaround for this bug involves attaching an empty click
listener on the target node.
<a href="https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html">https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html</a>
Just set it using the onclick property so that we don’t have to manage any
bookkeeping for it. Not sure if we need to clear it when the listener is
removed.
TODO: Only do this for the relevant Safaris maybe?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    node.<span class="hljs-property">onclick</span> = noop;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setInitialDOMProperties</span>(<span class="hljs-params">tag, domElement, rootContainerElement, nextProps, isCustomComponentTag</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propKey <span class="hljs-keyword">in</span> nextProps) {
      <span class="hljs-keyword">if</span> (!nextProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey)) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">var</span> nextProp = nextProps[propKey];

      <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">STYLE</span>) {
        {
          <span class="hljs-keyword">if</span> (nextProp) {</pre></div></div>
            
        </li>
        
        
        <li id="section-346">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-346">&#x00a7;</a>
              </div>
              <p>Freeze the next style object so that we can assume it won’t be
mutated. We have already warned for this in the past.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(nextProp);
          }
        } <span class="hljs-comment">// Relies on `updateStylesByID` not mutating `styleUpdates`.</span>


        <span class="hljs-title function_">setValueForStyles</span>(domElement, nextProp);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">DANGEROUSLY_SET_INNER_HTML</span>) {
        <span class="hljs-keyword">var</span> nextHtml = nextProp ? nextProp[<span class="hljs-variable constant_">HTML</span>$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;

        <span class="hljs-keyword">if</span> (nextHtml != <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">setInnerHTML</span>(domElement, nextHtml);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">CHILDREN</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&#x27;string&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-347">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-347">&#x00a7;</a>
              </div>
              <p>Avoid setting initial textContent when the text is empty. In IE11 setting
textContent on a <textarea> will cause the placeholder to not
show within the <textarea> until it has been focused and blurred again.
<a href="https://github.com/facebook/react/issues/6731#issuecomment-254874553">https://github.com/facebook/react/issues/6731#issuecomment-254874553</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> canSetTextContent = tag !== <span class="hljs-string">&#x27;textarea&#x27;</span> || nextProp !== <span class="hljs-string">&#x27;&#x27;</span>;

          <span class="hljs-keyword">if</span> (canSetTextContent) {
            <span class="hljs-title function_">setTextContent</span>(domElement, nextProp);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&#x27;number&#x27;</span>) {
          <span class="hljs-title function_">setTextContent</span>(domElement, <span class="hljs-string">&#x27;&#x27;</span> + nextProp);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">SUPPRESS_CONTENT_EDITABLE_WARNING</span> || propKey === <span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">AUTOFOCUS</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameDependencies.<span class="hljs-title function_">hasOwnProperty</span>(propKey)) {
        <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp !== <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-title function_">warnForInvalidEventListener</span>(propKey, nextProp);
          }

          <span class="hljs-keyword">if</span> (propKey === <span class="hljs-string">&#x27;onScroll&#x27;</span>) {
            <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, domElement);
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">setValueForProperty</span>(domElement, propKey, nextProp, isCustomComponentTag);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDOMProperties</span>(<span class="hljs-params">domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-348">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-348">&#x00a7;</a>
              </div>
              <p>TODO: Handle wasCustomComponentTag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; updatePayload.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">var</span> propKey = updatePayload[i];
      <span class="hljs-keyword">var</span> propValue = updatePayload[i + <span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">STYLE</span>) {
        <span class="hljs-title function_">setValueForStyles</span>(domElement, propValue);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">DANGEROUSLY_SET_INNER_HTML</span>) {
        <span class="hljs-title function_">setInnerHTML</span>(domElement, propValue);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">CHILDREN</span>) {
        <span class="hljs-title function_">setTextContent</span>(domElement, propValue);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">setValueForProperty</span>(domElement, propKey, propValue, isCustomComponentTag);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, props, rootContainerElement, parentNamespace</span>) {
    <span class="hljs-keyword">var</span> isCustomComponentTag; <span class="hljs-comment">// We create tags in the namespace of their parent container, except HTML</span></pre></div></div>
            
        </li>
        
        
        <li id="section-349">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-349">&#x00a7;</a>
              </div>
              <p>tags get no namespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> ownerDocument = <span class="hljs-title function_">getOwnerDocumentFromRootContainer</span>(rootContainerElement);
    <span class="hljs-keyword">var</span> domElement;
    <span class="hljs-keyword">var</span> namespaceURI = parentNamespace;

    <span class="hljs-keyword">if</span> (namespaceURI === <span class="hljs-variable constant_">HTML_NAMESPACE</span>$<span class="hljs-number">1</span>) {
      namespaceURI = <span class="hljs-title function_">getIntrinsicNamespace</span>(type);
    }

    <span class="hljs-keyword">if</span> (namespaceURI === <span class="hljs-variable constant_">HTML_NAMESPACE</span>$<span class="hljs-number">1</span>) {
      {
        isCustomComponentTag = <span class="hljs-title function_">isCustomComponent</span>(type, props); <span class="hljs-comment">// Should this check be gated by parent namespace? Not sure we want to</span></pre></div></div>
            
        </li>
        
        
        <li id="section-350">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-350">&#x00a7;</a>
              </div>
              <p>allow <SVG> or <mATH>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (!isCustomComponentTag &amp;&amp; type !== type.<span class="hljs-title function_">toLowerCase</span>()) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;&lt;%s /&gt; is using incorrect casing. &#x27;</span> + <span class="hljs-string">&#x27;Use PascalCase for React components, &#x27;</span> + <span class="hljs-string">&#x27;or lowercase for HTML elements.&#x27;</span>, type);
        }
      }

      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;script&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-351">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-351">&#x00a7;</a>
              </div>
              <p>Create the script via .innerHTML so its “parser-inserted” flag is
set to true and it does not execute</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> div = ownerDocument.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);

        div.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;script&gt;&lt;&#x27;</span> + <span class="hljs-string">&#x27;/script&gt;&#x27;</span>; <span class="hljs-comment">// eslint-disable-line</span></pre></div></div>
            
        </li>
        
        
        <li id="section-352">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-352">&#x00a7;</a>
              </div>
              <p>This is guaranteed to yield a script element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> firstChild = div.<span class="hljs-property">firstChild</span>;
        domElement = div.<span class="hljs-title function_">removeChild</span>(firstChild);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.<span class="hljs-property">is</span> === <span class="hljs-string">&#x27;string&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-353">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-353">&#x00a7;</a>
              </div>
              <p>$FlowIssue <code>createElement</code> should be updated for Web Components</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        domElement = ownerDocument.<span class="hljs-title function_">createElement</span>(type, {
          <span class="hljs-attr">is</span>: props.<span class="hljs-property">is</span>
        });
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-354">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-354">&#x00a7;</a>
              </div>
              <p>Separate else branch instead of using <code>props.is || undefined</code> above because of a Firefox bug.
See discussion in <a href="https://github.com/facebook/react/pull/6896">https://github.com/facebook/react/pull/6896</a>
and discussion in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1276240">https://bugzilla.mozilla.org/show_bug.cgi?id=1276240</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        domElement = ownerDocument.<span class="hljs-title function_">createElement</span>(type); <span class="hljs-comment">// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`</span></pre></div></div>
            
        </li>
        
        
        <li id="section-355">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-355">&#x00a7;</a>
              </div>
              <p>attributes on <code>select</code>s needs to be added before <code>option</code>s are inserted.
This prevents:</p>
<ul>
<li>a bug where the <code>select</code> does not scroll to the correct option because singular
 <code>select</code> elements automatically pick the first item #13222</li>
<li>a bug where the <code>select</code> set the first item as selected despite the <code>size</code> attribute #14239
See <a href="https://github.com/facebook/react/issues/13222">https://github.com/facebook/react/issues/13222</a>
and <a href="https://github.com/facebook/react/issues/14239">https://github.com/facebook/react/issues/14239</a></li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;select&#x27;</span>) {
          <span class="hljs-keyword">var</span> node = domElement;

          <span class="hljs-keyword">if</span> (props.<span class="hljs-property">multiple</span>) {
            node.<span class="hljs-property">multiple</span> = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (props.<span class="hljs-property">size</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-356">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-356">&#x00a7;</a>
              </div>
              <p>Setting a size greater than 1 causes a select to behave like <code>multiple=true</code>, where
it is possible that no option is selected.</p>
<p>This is only necessary when a select in “single selection mode”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            node.<span class="hljs-property">size</span> = props.<span class="hljs-property">size</span>;
          }
        }
      }
    } <span class="hljs-keyword">else</span> {
      domElement = ownerDocument.<span class="hljs-title function_">createElementNS</span>(namespaceURI, type);
    }

    {
      <span class="hljs-keyword">if</span> (namespaceURI === <span class="hljs-variable constant_">HTML_NAMESPACE</span>$<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (!isCustomComponentTag &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(domElement) === <span class="hljs-string">&#x27;[object HTMLUnknownElement]&#x27;</span> &amp;&amp; !<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(warnedUnknownTags, type)) {
          warnedUnknownTags[type] = <span class="hljs-literal">true</span>;

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The tag &lt;%s&gt; is unrecognized in this browser. &#x27;</span> + <span class="hljs-string">&#x27;If you meant to render a React component, start its name with &#x27;</span> + <span class="hljs-string">&#x27;an uppercase letter.&#x27;</span>, type);
        }
      }
    }

    <span class="hljs-keyword">return</span> domElement;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextNode</span>(<span class="hljs-params">text, rootContainerElement</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getOwnerDocumentFromRootContainer</span>(rootContainerElement).<span class="hljs-title function_">createTextNode</span>(text);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setInitialProperties</span>(<span class="hljs-params">domElement, tag, rawProps, rootContainerElement</span>) {
    <span class="hljs-keyword">var</span> isCustomComponentTag = <span class="hljs-title function_">isCustomComponent</span>(tag, rawProps);

    {
      <span class="hljs-title function_">validatePropertiesInDevelopment</span>(tag, rawProps);
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make sure that we check isMounted before firing any of these events.</span>


    <span class="hljs-keyword">var</span> props;

    <span class="hljs-keyword">switch</span> (tag) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dialog&#x27;</span>:
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;cancel&#x27;</span>, domElement);
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;close&#x27;</span>, domElement);
        props = rawProps;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;iframe&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;object&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;embed&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-357">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-357">&#x00a7;</a>
              </div>
              <p>We listen to this event in case to ensure emulated bubble
listeners still fire for the load event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;load&#x27;</span>, domElement);
        props = rawProps;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;video&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;audio&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-358">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-358">&#x00a7;</a>
              </div>
              <p>We listen to these events in case to ensure emulated bubble
listeners still fire for all the media events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mediaEventTypes.<span class="hljs-property">length</span>; i++) {
          <span class="hljs-title function_">listenToNonDelegatedEvent</span>(mediaEventTypes[i], domElement);
        }

        props = rawProps;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;source&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-359">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-359">&#x00a7;</a>
              </div>
              <p>We listen to this event in case to ensure emulated bubble
listeners still fire for the error event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;error&#x27;</span>, domElement);
        props = rawProps;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;img&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;image&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;link&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-360">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-360">&#x00a7;</a>
              </div>
              <p>We listen to these events in case to ensure emulated bubble
listeners still fire for error and load events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;error&#x27;</span>, domElement);
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;load&#x27;</span>, domElement);
        props = rawProps;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;details&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-361">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-361">&#x00a7;</a>
              </div>
              <p>We listen to this event in case to ensure emulated bubble
listeners still fire for the toggle event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;toggle&#x27;</span>, domElement);
        props = rawProps;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:
        <span class="hljs-title function_">initWrapperState</span>(domElement, rawProps);
        props = <span class="hljs-title function_">getHostProps</span>(domElement, rawProps); <span class="hljs-comment">// We listen to this event in case to ensure emulated bubble</span></pre></div></div>
            
        </li>
        
        
        <li id="section-362">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-362">&#x00a7;</a>
              </div>
              <p>listeners still fire for the invalid event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;invalid&#x27;</span>, domElement);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;option&#x27;</span>:
        <span class="hljs-title function_">validateProps</span>(domElement, rawProps);
        props = <span class="hljs-title function_">getHostProps$1</span>(domElement, rawProps);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
        <span class="hljs-title function_">initWrapperState$1</span>(domElement, rawProps);
        props = <span class="hljs-title function_">getHostProps$2</span>(domElement, rawProps); <span class="hljs-comment">// We listen to this event in case to ensure emulated bubble</span></pre></div></div>
            
        </li>
        
        
        <li id="section-363">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-363">&#x00a7;</a>
              </div>
              <p>listeners still fire for the invalid event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;invalid&#x27;</span>, domElement);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:
        <span class="hljs-title function_">initWrapperState$2</span>(domElement, rawProps);
        props = <span class="hljs-title function_">getHostProps$3</span>(domElement, rawProps); <span class="hljs-comment">// We listen to this event in case to ensure emulated bubble</span></pre></div></div>
            
        </li>
        
        
        <li id="section-364">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-364">&#x00a7;</a>
              </div>
              <p>listeners still fire for the invalid event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;invalid&#x27;</span>, domElement);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-attr">default</span>:
        props = rawProps;
    }

    <span class="hljs-title function_">assertValidProps</span>(tag, props);
    <span class="hljs-title function_">setInitialDOMProperties</span>(tag, domElement, rootContainerElement, props, isCustomComponentTag);

    <span class="hljs-keyword">switch</span> (tag) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-365">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-365">&#x00a7;</a>
              </div>
              <p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">track</span>(domElement);
        <span class="hljs-title function_">postMountWrapper</span>(domElement, rawProps, <span class="hljs-literal">false</span>);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-366">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-366">&#x00a7;</a>
              </div>
              <p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">track</span>(domElement);
        <span class="hljs-title function_">postMountWrapper$3</span>(domElement);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;option&#x27;</span>:
        <span class="hljs-title function_">postMountWrapper$1</span>(domElement, rawProps);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
        <span class="hljs-title function_">postMountWrapper$2</span>(domElement, rawProps);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.<span class="hljs-property">onClick</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-367">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-367">&#x00a7;</a>
              </div>
              <p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">trapClickOnNonInteractiveElement</span>(domElement);
        }

        <span class="hljs-keyword">break</span>;
    }
  } <span class="hljs-comment">// Calculate the diff between the two objects.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">diffProperties</span>(<span class="hljs-params">domElement, tag, lastRawProps, nextRawProps, rootContainerElement</span>) {
    {
      <span class="hljs-title function_">validatePropertiesInDevelopment</span>(tag, nextRawProps);
    }

    <span class="hljs-keyword">var</span> updatePayload = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> lastProps;
    <span class="hljs-keyword">var</span> nextProps;

    <span class="hljs-keyword">switch</span> (tag) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:
        lastProps = <span class="hljs-title function_">getHostProps</span>(domElement, lastRawProps);
        nextProps = <span class="hljs-title function_">getHostProps</span>(domElement, nextRawProps);
        updatePayload = [];
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;option&#x27;</span>:
        lastProps = <span class="hljs-title function_">getHostProps$1</span>(domElement, lastRawProps);
        nextProps = <span class="hljs-title function_">getHostProps$1</span>(domElement, nextRawProps);
        updatePayload = [];
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
        lastProps = <span class="hljs-title function_">getHostProps$2</span>(domElement, lastRawProps);
        nextProps = <span class="hljs-title function_">getHostProps$2</span>(domElement, nextRawProps);
        updatePayload = [];
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:
        lastProps = <span class="hljs-title function_">getHostProps$3</span>(domElement, lastRawProps);
        nextProps = <span class="hljs-title function_">getHostProps$3</span>(domElement, nextRawProps);
        updatePayload = [];
        <span class="hljs-keyword">break</span>;

      <span class="hljs-attr">default</span>:
        lastProps = lastRawProps;
        nextProps = nextRawProps;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> lastProps.<span class="hljs-property">onClick</span> !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> nextProps.<span class="hljs-property">onClick</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-368">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-368">&#x00a7;</a>
              </div>
              <p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">trapClickOnNonInteractiveElement</span>(domElement);
        }

        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-title function_">assertValidProps</span>(tag, nextProps);
    <span class="hljs-keyword">var</span> propKey;
    <span class="hljs-keyword">var</span> styleName;
    <span class="hljs-keyword">var</span> styleUpdates = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">for</span> (propKey <span class="hljs-keyword">in</span> lastProps) {
      <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey) || !lastProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey) || lastProps[propKey] == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">STYLE</span>) {
        <span class="hljs-keyword">var</span> lastStyle = lastProps[propKey];

        <span class="hljs-keyword">for</span> (styleName <span class="hljs-keyword">in</span> lastStyle) {
          <span class="hljs-keyword">if</span> (lastStyle.<span class="hljs-title function_">hasOwnProperty</span>(styleName)) {
            <span class="hljs-keyword">if</span> (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = <span class="hljs-string">&#x27;&#x27;</span>;
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">DANGEROUSLY_SET_INNER_HTML</span> || propKey === <span class="hljs-variable constant_">CHILDREN</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">SUPPRESS_CONTENT_EDITABLE_WARNING</span> || propKey === <span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">AUTOFOCUS</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameDependencies.<span class="hljs-title function_">hasOwnProperty</span>(propKey)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-369">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-369">&#x00a7;</a>
              </div>
              <p>This is a special case. If any listener updates we need to ensure
that the “current” fiber pointer gets updated so we need a commit
to update this element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!updatePayload) {
          updatePayload = [];
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-370">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-370">&#x00a7;</a>
              </div>
              <p>For all other deleted properties we add it to the queue. We use
the allowed property list in the commit phase instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        (updatePayload = updatePayload || []).<span class="hljs-title function_">push</span>(propKey, <span class="hljs-literal">null</span>);
      }
    }

    <span class="hljs-keyword">for</span> (propKey <span class="hljs-keyword">in</span> nextProps) {
      <span class="hljs-keyword">var</span> nextProp = nextProps[propKey];
      <span class="hljs-keyword">var</span> lastProp = lastProps != <span class="hljs-literal">null</span> ? lastProps[propKey] : <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">if</span> (!nextProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey) || nextProp === lastProp || nextProp == <span class="hljs-literal">null</span> &amp;&amp; lastProp == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">STYLE</span>) {
        {
          <span class="hljs-keyword">if</span> (nextProp) {</pre></div></div>
            
        </li>
        
        
        <li id="section-371">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-371">&#x00a7;</a>
              </div>
              <p>Freeze the next style object so that we can assume it won’t be
mutated. We have already warned for this in the past.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(nextProp);
          }
        }

        <span class="hljs-keyword">if</span> (lastProp) {</pre></div></div>
            
        </li>
        
        
        <li id="section-372">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-372">&#x00a7;</a>
              </div>
              <p>Unset styles on <code>lastProp</code> but not on <code>nextProp</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">for</span> (styleName <span class="hljs-keyword">in</span> lastProp) {
            <span class="hljs-keyword">if</span> (lastProp.<span class="hljs-title function_">hasOwnProperty</span>(styleName) &amp;&amp; (!nextProp || !nextProp.<span class="hljs-title function_">hasOwnProperty</span>(styleName))) {
              <span class="hljs-keyword">if</span> (!styleUpdates) {
                styleUpdates = {};
              }

              styleUpdates[styleName] = <span class="hljs-string">&#x27;&#x27;</span>;
            }
          } <span class="hljs-comment">// Update styles that changed since `lastProp`.</span>


          <span class="hljs-keyword">for</span> (styleName <span class="hljs-keyword">in</span> nextProp) {
            <span class="hljs-keyword">if</span> (nextProp.<span class="hljs-title function_">hasOwnProperty</span>(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) {
              <span class="hljs-keyword">if</span> (!styleUpdates) {
                styleUpdates = {};
              }

              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-373">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-373">&#x00a7;</a>
              </div>
              <p>Relies on <code>updateStylesByID</code> not mutating <code>styleUpdates</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!styleUpdates) {
            <span class="hljs-keyword">if</span> (!updatePayload) {
              updatePayload = [];
            }

            updatePayload.<span class="hljs-title function_">push</span>(propKey, styleUpdates);
          }

          styleUpdates = nextProp;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">DANGEROUSLY_SET_INNER_HTML</span>) {
        <span class="hljs-keyword">var</span> nextHtml = nextProp ? nextProp[<span class="hljs-variable constant_">HTML</span>$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;
        <span class="hljs-keyword">var</span> lastHtml = lastProp ? lastProp[<span class="hljs-variable constant_">HTML</span>$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;

        <span class="hljs-keyword">if</span> (nextHtml != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (lastHtml !== nextHtml) {
            (updatePayload = updatePayload || []).<span class="hljs-title function_">push</span>(propKey, nextHtml);
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">CHILDREN</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&#x27;number&#x27;</span>) {
          (updatePayload = updatePayload || []).<span class="hljs-title function_">push</span>(propKey, <span class="hljs-string">&#x27;&#x27;</span> + nextProp);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">SUPPRESS_CONTENT_EDITABLE_WARNING</span> || propKey === <span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameDependencies.<span class="hljs-title function_">hasOwnProperty</span>(propKey)) {
        <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-374">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-374">&#x00a7;</a>
              </div>
              <p>We eagerly listen to this even though we haven’t committed yet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp !== <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-title function_">warnForInvalidEventListener</span>(propKey, nextProp);
          }

          <span class="hljs-keyword">if</span> (propKey === <span class="hljs-string">&#x27;onScroll&#x27;</span>) {
            <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, domElement);
          }
        }

        <span class="hljs-keyword">if</span> (!updatePayload &amp;&amp; lastProp !== nextProp) {</pre></div></div>
            
        </li>
        
        
        <li id="section-375">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-375">&#x00a7;</a>
              </div>
              <p>This is a special case. If any listener updates we need to ensure
that the “current” props pointer gets updated so we need a commit
to update this element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          updatePayload = [];
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; nextProp !== <span class="hljs-literal">null</span> &amp;&amp; nextProp.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_OPAQUE_ID_TYPE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-376">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-376">&#x00a7;</a>
              </div>
              <p>If we encounter useOpaqueReference’s opaque object, this means we are hydrating.
In this case, call the opaque object’s toString function which generates a new client
ID so client and server IDs match and throws to rerender.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        nextProp.<span class="hljs-title function_">toString</span>();
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-377">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-377">&#x00a7;</a>
              </div>
              <p>For any other property we always add it to the queue and then we
filter it out using the allowed property list during the commit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        (updatePayload = updatePayload || []).<span class="hljs-title function_">push</span>(propKey, nextProp);
      }
    }

    <span class="hljs-keyword">if</span> (styleUpdates) {
      {
        <span class="hljs-title function_">validateShorthandPropertyCollisionInDev</span>(styleUpdates, nextProps[<span class="hljs-variable constant_">STYLE</span>]);
      }

      (updatePayload = updatePayload || []).<span class="hljs-title function_">push</span>(<span class="hljs-variable constant_">STYLE</span>, styleUpdates);
    }

    <span class="hljs-keyword">return</span> updatePayload;
  } <span class="hljs-comment">// Apply the diff.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProperties</span>(<span class="hljs-params">domElement, updatePayload, tag, lastRawProps, nextRawProps</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-378">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-378">&#x00a7;</a>
              </div>
              <p>Update checked <em>before</em> name.
In the middle of an update, it is possible to have multiple checked.
When a checked radio tries to change name, browser makes another radio’s checked false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;input&#x27;</span> &amp;&amp; nextRawProps.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;radio&#x27;</span> &amp;&amp; nextRawProps.<span class="hljs-property">name</span> != <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">updateChecked</span>(domElement, nextRawProps);
    }

    <span class="hljs-keyword">var</span> wasCustomComponentTag = <span class="hljs-title function_">isCustomComponent</span>(tag, lastRawProps);
    <span class="hljs-keyword">var</span> isCustomComponentTag = <span class="hljs-title function_">isCustomComponent</span>(tag, nextRawProps); <span class="hljs-comment">// Apply the diff.</span>

    <span class="hljs-title function_">updateDOMProperties</span>(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Ensure that an update gets scheduled if any of the special props</span></pre></div></div>
            
        </li>
        
        
        <li id="section-379">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-379">&#x00a7;</a>
              </div>
              <p>changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">switch</span> (tag) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-380">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-380">&#x00a7;</a>
              </div>
              <p>Update the wrapper around inputs <em>after</em> updating props. This has to
happen after <code>updateDOMProperties</code>. Otherwise HTML5 input validations
raise warnings and prevent the new value from being assigned.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">updateWrapper</span>(domElement, nextRawProps);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:
        <span class="hljs-title function_">updateWrapper$1</span>(domElement, nextRawProps);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-381">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-381">&#x00a7;</a>
              </div>
              <p><select> value update needs to occur after <option> children
reconciliation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">postUpdateWrapper</span>(domElement, nextRawProps);
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPossibleStandardName</span>(<span class="hljs-params">propName</span>) {
    {
      <span class="hljs-keyword">var</span> lowerCasedName = propName.<span class="hljs-title function_">toLowerCase</span>();

      <span class="hljs-keyword">if</span> (!possibleStandardNames.<span class="hljs-title function_">hasOwnProperty</span>(lowerCasedName)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> possibleStandardNames[lowerCasedName] || <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">diffHydratedProperties</span>(<span class="hljs-params">domElement, tag, rawProps, parentNamespace, rootContainerElement</span>) {
    <span class="hljs-keyword">var</span> isCustomComponentTag;
    <span class="hljs-keyword">var</span> extraAttributeNames;

    {
      suppressHydrationWarning = rawProps[<span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>] === <span class="hljs-literal">true</span>;
      isCustomComponentTag = <span class="hljs-title function_">isCustomComponent</span>(tag, rawProps);
      <span class="hljs-title function_">validatePropertiesInDevelopment</span>(tag, rawProps);
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Make sure that we check isMounted before firing any of these events.</span>


    <span class="hljs-keyword">switch</span> (tag) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dialog&#x27;</span>:
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;cancel&#x27;</span>, domElement);
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;close&#x27;</span>, domElement);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;iframe&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;object&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;embed&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-382">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-382">&#x00a7;</a>
              </div>
              <p>We listen to this event in case to ensure emulated bubble
listeners still fire for the load event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;load&#x27;</span>, domElement);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;video&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;audio&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-383">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-383">&#x00a7;</a>
              </div>
              <p>We listen to these events in case to ensure emulated bubble
listeners still fire for all the media events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mediaEventTypes.<span class="hljs-property">length</span>; i++) {
          <span class="hljs-title function_">listenToNonDelegatedEvent</span>(mediaEventTypes[i], domElement);
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;source&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-384">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-384">&#x00a7;</a>
              </div>
              <p>We listen to this event in case to ensure emulated bubble
listeners still fire for the error event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;error&#x27;</span>, domElement);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;img&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;image&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;link&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-385">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-385">&#x00a7;</a>
              </div>
              <p>We listen to these events in case to ensure emulated bubble
listeners still fire for error and load events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;error&#x27;</span>, domElement);
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;load&#x27;</span>, domElement);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;details&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-386">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-386">&#x00a7;</a>
              </div>
              <p>We listen to this event in case to ensure emulated bubble
listeners still fire for the toggle event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;toggle&#x27;</span>, domElement);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:
        <span class="hljs-title function_">initWrapperState</span>(domElement, rawProps); <span class="hljs-comment">// We listen to this event in case to ensure emulated bubble</span></pre></div></div>
            
        </li>
        
        
        <li id="section-387">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-387">&#x00a7;</a>
              </div>
              <p>listeners still fire for the invalid event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;invalid&#x27;</span>, domElement);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;option&#x27;</span>:
        <span class="hljs-title function_">validateProps</span>(domElement, rawProps);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
        <span class="hljs-title function_">initWrapperState$1</span>(domElement, rawProps); <span class="hljs-comment">// We listen to this event in case to ensure emulated bubble</span></pre></div></div>
            
        </li>
        
        
        <li id="section-388">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-388">&#x00a7;</a>
              </div>
              <p>listeners still fire for the invalid event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;invalid&#x27;</span>, domElement);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:
        <span class="hljs-title function_">initWrapperState$2</span>(domElement, rawProps); <span class="hljs-comment">// We listen to this event in case to ensure emulated bubble</span></pre></div></div>
            
        </li>
        
        
        <li id="section-389">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-389">&#x00a7;</a>
              </div>
              <p>listeners still fire for the invalid event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;invalid&#x27;</span>, domElement);

        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-title function_">assertValidProps</span>(tag, rawProps);

    {
      extraAttributeNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
      <span class="hljs-keyword">var</span> attributes = domElement.<span class="hljs-property">attributes</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; attributes.<span class="hljs-property">length</span>; _i++) {
        <span class="hljs-keyword">var</span> name = attributes[_i].<span class="hljs-property">name</span>.<span class="hljs-title function_">toLowerCase</span>();

        <span class="hljs-keyword">switch</span> (name) {</pre></div></div>
            
        </li>
        
        
        <li id="section-390">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-390">&#x00a7;</a>
              </div>
              <p>Built-in SSR attribute is allowed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;data-reactroot&#x27;</span>:
            <span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-391">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-391">&#x00a7;</a>
              </div>
              <p>Controlled attributes are not validated
TODO: Only ignore them on controlled tags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;value&#x27;</span>:
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;checked&#x27;</span>:
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;selected&#x27;</span>:
            <span class="hljs-keyword">break</span>;

          <span class="hljs-attr">default</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-392">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-392">&#x00a7;</a>
              </div>
              <p>Intentionally use the original name.
See discussion in <a href="https://github.com/facebook/react/pull/10676">https://github.com/facebook/react/pull/10676</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            extraAttributeNames.<span class="hljs-title function_">add</span>(attributes[_i].<span class="hljs-property">name</span>);
        }
      }
    }

    <span class="hljs-keyword">var</span> updatePayload = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propKey <span class="hljs-keyword">in</span> rawProps) {
      <span class="hljs-keyword">if</span> (!rawProps.<span class="hljs-title function_">hasOwnProperty</span>(propKey)) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">var</span> nextProp = rawProps[propKey];

      <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">CHILDREN</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-393">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-393">&#x00a7;</a>
              </div>
              <p>For text content children we compare against textContent. This
might match additional HTML that is hidden when we read it using
textContent. E.g. “foo” will match “f<span>oo</span>“ but that still
satisfies our requirement. Our requirement is not to produce perfect
HTML and attributes. Ideally we should preserve structure but it’s
ok not to if the visible content is still enough to indicate what
even listeners these nodes might be wired up to.
TODO: Warn if there is more than a single textNode as a child.
TODO: Should we use domElement.firstChild.nodeValue to compare?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&#x27;string&#x27;</span>) {
          <span class="hljs-keyword">if</span> (domElement.<span class="hljs-property">textContent</span> !== nextProp) {
            <span class="hljs-keyword">if</span> (!suppressHydrationWarning) {
              <span class="hljs-title function_">warnForTextDifference</span>(domElement.<span class="hljs-property">textContent</span>, nextProp);
            }

            updatePayload = [<span class="hljs-variable constant_">CHILDREN</span>, nextProp];
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp === <span class="hljs-string">&#x27;number&#x27;</span>) {
          <span class="hljs-keyword">if</span> (domElement.<span class="hljs-property">textContent</span> !== <span class="hljs-string">&#x27;&#x27;</span> + nextProp) {
            <span class="hljs-keyword">if</span> (!suppressHydrationWarning) {
              <span class="hljs-title function_">warnForTextDifference</span>(domElement.<span class="hljs-property">textContent</span>, nextProp);
            }

            updatePayload = [<span class="hljs-variable constant_">CHILDREN</span>, <span class="hljs-string">&#x27;&#x27;</span> + nextProp];
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (registrationNameDependencies.<span class="hljs-title function_">hasOwnProperty</span>(propKey)) {
        <span class="hljs-keyword">if</span> (nextProp != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProp !== <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-title function_">warnForInvalidEventListener</span>(propKey, nextProp);
          }

          <span class="hljs-keyword">if</span> (propKey === <span class="hljs-string">&#x27;onScroll&#x27;</span>) {
            <span class="hljs-title function_">listenToNonDelegatedEvent</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, domElement);
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Convince Flow we&#x27;ve calculated it (it&#x27;s DEV-only in this method.)</span>
        <span class="hljs-keyword">typeof</span> isCustomComponentTag === <span class="hljs-string">&#x27;boolean&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-394">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-394">&#x00a7;</a>
              </div>
              <p>Validate that the properties correspond to their expected values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> serverValue = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> propertyInfo = <span class="hljs-title function_">getPropertyInfo</span>(propKey);

        <span class="hljs-keyword">if</span> (suppressHydrationWarning); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">SUPPRESS_CONTENT_EDITABLE_WARNING</span> || propKey === <span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span> || <span class="hljs-comment">// Controlled attributes are not validated</span></pre></div></div>
            
        </li>
        
        
        <li id="section-395">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-395">&#x00a7;</a>
              </div>
              <p>TODO: Only ignore them on controlled tags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          propKey === <span class="hljs-string">&#x27;value&#x27;</span> || propKey === <span class="hljs-string">&#x27;checked&#x27;</span> || propKey === <span class="hljs-string">&#x27;selected&#x27;</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">DANGEROUSLY_SET_INNER_HTML</span>) {
            <span class="hljs-keyword">var</span> serverHTML = domElement.<span class="hljs-property">innerHTML</span>;
            <span class="hljs-keyword">var</span> nextHtml = nextProp ? nextProp[<span class="hljs-variable constant_">HTML</span>$<span class="hljs-number">1</span>] : <span class="hljs-literal">undefined</span>;

            <span class="hljs-keyword">if</span> (nextHtml != <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> expectedHTML = <span class="hljs-title function_">normalizeHTML</span>(domElement, nextHtml);

              <span class="hljs-keyword">if</span> (expectedHTML !== serverHTML) {
                <span class="hljs-title function_">warnForPropDifference</span>(propKey, serverHTML, expectedHTML);
              }
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propKey === <span class="hljs-variable constant_">STYLE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-396">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-396">&#x00a7;</a>
              </div>
              <p>$FlowFixMe - Should be inferred as not undefined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            extraAttributeNames.<span class="hljs-title function_">delete</span>(propKey);

            <span class="hljs-keyword">if</span> (canDiffStyleForHydrationWarning) {
              <span class="hljs-keyword">var</span> expectedStyle = <span class="hljs-title function_">createDangerousStringForStyles</span>(nextProp);
              serverValue = domElement.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;style&#x27;</span>);

              <span class="hljs-keyword">if</span> (expectedStyle !== serverValue) {
                <span class="hljs-title function_">warnForPropDifference</span>(propKey, serverValue, expectedStyle);
              }
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isCustomComponentTag) {</pre></div></div>
            
        </li>
        
        
        <li id="section-397">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-397">&#x00a7;</a>
              </div>
              <p>$FlowFixMe - Should be inferred as not undefined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            extraAttributeNames.<span class="hljs-title function_">delete</span>(propKey.<span class="hljs-title function_">toLowerCase</span>());
            serverValue = <span class="hljs-title function_">getValueForAttribute</span>(domElement, propKey, nextProp);

            <span class="hljs-keyword">if</span> (nextProp !== serverValue) {
              <span class="hljs-title function_">warnForPropDifference</span>(propKey, serverValue, nextProp);
            }
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">shouldIgnoreAttribute</span>(propKey, propertyInfo, isCustomComponentTag) &amp;&amp; !<span class="hljs-title function_">shouldRemoveAttribute</span>(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
            <span class="hljs-keyword">var</span> isMismatchDueToBadCasing = <span class="hljs-literal">false</span>;

            <span class="hljs-keyword">if</span> (propertyInfo !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-398">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-398">&#x00a7;</a>
              </div>
              <p>$FlowFixMe - Should be inferred as not undefined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              extraAttributeNames.<span class="hljs-title function_">delete</span>(propertyInfo.<span class="hljs-property">attributeName</span>);
              serverValue = <span class="hljs-title function_">getValueForProperty</span>(domElement, propKey, nextProp, propertyInfo);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> ownNamespace = parentNamespace;

              <span class="hljs-keyword">if</span> (ownNamespace === <span class="hljs-variable constant_">HTML_NAMESPACE</span>$<span class="hljs-number">1</span>) {
                ownNamespace = <span class="hljs-title function_">getIntrinsicNamespace</span>(tag);
              }

              <span class="hljs-keyword">if</span> (ownNamespace === <span class="hljs-variable constant_">HTML_NAMESPACE</span>$<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-399">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-399">&#x00a7;</a>
              </div>
              <p>$FlowFixMe - Should be inferred as not undefined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                extraAttributeNames.<span class="hljs-title function_">delete</span>(propKey.<span class="hljs-title function_">toLowerCase</span>());
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">var</span> standardName = <span class="hljs-title function_">getPossibleStandardName</span>(propKey);

                <span class="hljs-keyword">if</span> (standardName !== <span class="hljs-literal">null</span> &amp;&amp; standardName !== propKey) {</pre></div></div>
            
        </li>
        
        
        <li id="section-400">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-400">&#x00a7;</a>
              </div>
              <p>If an SVG prop is supplied with bad casing, it will
be successfully parsed from HTML, but will produce a mismatch
(and would be incorrectly rendered on the client).
However, we already warn about bad casing elsewhere.
So we’ll skip the misleading extra mismatch warning in this case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  isMismatchDueToBadCasing = <span class="hljs-literal">true</span>; <span class="hljs-comment">// $FlowFixMe - Should be inferred as not undefined.</span>

                  extraAttributeNames.<span class="hljs-title function_">delete</span>(standardName);
                } <span class="hljs-comment">// $FlowFixMe - Should be inferred as not undefined.</span>


                extraAttributeNames.<span class="hljs-title function_">delete</span>(propKey);
              }

              serverValue = <span class="hljs-title function_">getValueForAttribute</span>(domElement, propKey, nextProp);
            }

            <span class="hljs-keyword">if</span> (nextProp !== serverValue &amp;&amp; !isMismatchDueToBadCasing) {
              <span class="hljs-title function_">warnForPropDifference</span>(propKey, serverValue, nextProp);
            }
          }
      }
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-401">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-401">&#x00a7;</a>
              </div>
              <p>$FlowFixMe - Should be inferred as not undefined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (extraAttributeNames.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span> &amp;&amp; !suppressHydrationWarning) {</pre></div></div>
            
        </li>
        
        
        <li id="section-402">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-402">&#x00a7;</a>
              </div>
              <p>$FlowFixMe - Should be inferred as not undefined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">warnForExtraAttributes</span>(extraAttributeNames);
      }
    }

    <span class="hljs-keyword">switch</span> (tag) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-403">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-403">&#x00a7;</a>
              </div>
              <p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">track</span>(domElement);
        <span class="hljs-title function_">postMountWrapper</span>(domElement, rawProps, <span class="hljs-literal">true</span>);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-404">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-404">&#x00a7;</a>
              </div>
              <p>TODO: Make sure we check if this is still unmounted or do any clean
up necessary since we never stop tracking anymore.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">track</span>(domElement);
        <span class="hljs-title function_">postMountWrapper$3</span>(domElement);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;option&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-405">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-405">&#x00a7;</a>
              </div>
              <p>For input and textarea we current always set the value property at
post mount to force it to diverge from attributes. However, for
option and select we don’t quite do the same thing and select
is not resilient to the DOM state changing so we don’t do that here.
TODO: Consider not doing this for input and textarea.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">break</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> rawProps.<span class="hljs-property">onClick</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-406">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-406">&#x00a7;</a>
              </div>
              <p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">trapClickOnNonInteractiveElement</span>(domElement);
        }

        <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">return</span> updatePayload;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">diffHydratedText</span>(<span class="hljs-params">textNode, text</span>) {
    <span class="hljs-keyword">var</span> isDifferent = textNode.<span class="hljs-property">nodeValue</span> !== text;
    <span class="hljs-keyword">return</span> isDifferent;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnForUnmatchedText</span>(<span class="hljs-params">textNode, text</span>) {
    {
      <span class="hljs-title function_">warnForTextDifference</span>(textNode.<span class="hljs-property">nodeValue</span>, text);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnForDeletedHydratableElement</span>(<span class="hljs-params">parentNode, child</span>) {
    {
      <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
        <span class="hljs-keyword">return</span>;
      }

      didWarnInvalidHydration = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Did not expect server HTML to contain a &lt;%s&gt; in &lt;%s&gt;.&#x27;</span>, child.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>(), parentNode.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>());
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnForDeletedHydratableText</span>(<span class="hljs-params">parentNode, child</span>) {
    {
      <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
        <span class="hljs-keyword">return</span>;
      }

      didWarnInvalidHydration = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Did not expect server HTML to contain the text node &quot;%s&quot; in &lt;%s&gt;.&#x27;</span>, child.<span class="hljs-property">nodeValue</span>, parentNode.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>());
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnForInsertedHydratedElement</span>(<span class="hljs-params">parentNode, tag, props</span>) {
    {
      <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
        <span class="hljs-keyword">return</span>;
      }

      didWarnInvalidHydration = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected server HTML to contain a matching &lt;%s&gt; in &lt;%s&gt;.&#x27;</span>, tag, parentNode.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>());
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnForInsertedHydratedText</span>(<span class="hljs-params">parentNode, text</span>) {
    {
      <span class="hljs-keyword">if</span> (text === <span class="hljs-string">&#x27;&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-407">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-407">&#x00a7;</a>
              </div>
              <p>We expect to insert empty text nodes since they’re not represented in
the HTML.
TODO: Remove this special case if we can just avoid inserting empty
text nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (didWarnInvalidHydration) {
        <span class="hljs-keyword">return</span>;
      }

      didWarnInvalidHydration = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected server HTML to contain a matching text node for &quot;%s&quot; in &lt;%s&gt;.&#x27;</span>, text, parentNode.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>());
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">restoreControlledState$3</span>(<span class="hljs-params">domElement, tag, props</span>) {
    <span class="hljs-keyword">switch</span> (tag) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:
        <span class="hljs-title function_">restoreControlledState</span>(domElement, props);
        <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:
        <span class="hljs-title function_">restoreControlledState$2</span>(domElement, props);
        <span class="hljs-keyword">return</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
        <span class="hljs-title function_">restoreControlledState$1</span>(domElement, props);
        <span class="hljs-keyword">return</span>;
    }
  }

  <span class="hljs-keyword">var</span> validateDOMNesting = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };

  <span class="hljs-keyword">var</span> updatedAncestorInfo = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-408">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-408">&#x00a7;</a>
              </div>
              <p>This validation code was written based on the HTML5 parsing spec:
<a href="https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope">https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope</a></p>
<p>Note: this does not catch all invalid nesting, nor does it try to (as it’s
not clear what practical benefit doing so provides); instead, we warn only
for cases where the parser will give a parse tree differing from what React
intended. For example, <b><div></div></b> is invalid but we don’t warn
because it still parses correctly; we do warn for other cases like nested</p>
<p> tags where the beginning of the second element implicitly closes the
first, causing a confusing mess.
https://html.spec.whatwg.org/multipage/syntax.html#special

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> specialTags = [<span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-string">&#x27;applet&#x27;</span>, <span class="hljs-string">&#x27;area&#x27;</span>, <span class="hljs-string">&#x27;article&#x27;</span>, <span class="hljs-string">&#x27;aside&#x27;</span>, <span class="hljs-string">&#x27;base&#x27;</span>, <span class="hljs-string">&#x27;basefont&#x27;</span>, <span class="hljs-string">&#x27;bgsound&#x27;</span>, <span class="hljs-string">&#x27;blockquote&#x27;</span>, <span class="hljs-string">&#x27;body&#x27;</span>, <span class="hljs-string">&#x27;br&#x27;</span>, <span class="hljs-string">&#x27;button&#x27;</span>, <span class="hljs-string">&#x27;caption&#x27;</span>, <span class="hljs-string">&#x27;center&#x27;</span>, <span class="hljs-string">&#x27;col&#x27;</span>, <span class="hljs-string">&#x27;colgroup&#x27;</span>, <span class="hljs-string">&#x27;dd&#x27;</span>, <span class="hljs-string">&#x27;details&#x27;</span>, <span class="hljs-string">&#x27;dir&#x27;</span>, <span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-string">&#x27;dl&#x27;</span>, <span class="hljs-string">&#x27;dt&#x27;</span>, <span class="hljs-string">&#x27;embed&#x27;</span>, <span class="hljs-string">&#x27;fieldset&#x27;</span>, <span class="hljs-string">&#x27;figcaption&#x27;</span>, <span class="hljs-string">&#x27;figure&#x27;</span>, <span class="hljs-string">&#x27;footer&#x27;</span>, <span class="hljs-string">&#x27;form&#x27;</span>, <span class="hljs-string">&#x27;frame&#x27;</span>, <span class="hljs-string">&#x27;frameset&#x27;</span>, <span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;h2&#x27;</span>, <span class="hljs-string">&#x27;h3&#x27;</span>, <span class="hljs-string">&#x27;h4&#x27;</span>, <span class="hljs-string">&#x27;h5&#x27;</span>, <span class="hljs-string">&#x27;h6&#x27;</span>, <span class="hljs-string">&#x27;head&#x27;</span>, <span class="hljs-string">&#x27;header&#x27;</span>, <span class="hljs-string">&#x27;hgroup&#x27;</span>, <span class="hljs-string">&#x27;hr&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;iframe&#x27;</span>, <span class="hljs-string">&#x27;img&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;isindex&#x27;</span>, <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-string">&#x27;link&#x27;</span>, <span class="hljs-string">&#x27;listing&#x27;</span>, <span class="hljs-string">&#x27;main&#x27;</span>, <span class="hljs-string">&#x27;marquee&#x27;</span>, <span class="hljs-string">&#x27;menu&#x27;</span>, <span class="hljs-string">&#x27;menuitem&#x27;</span>, <span class="hljs-string">&#x27;meta&#x27;</span>, <span class="hljs-string">&#x27;nav&#x27;</span>, <span class="hljs-string">&#x27;noembed&#x27;</span>, <span class="hljs-string">&#x27;noframes&#x27;</span>, <span class="hljs-string">&#x27;noscript&#x27;</span>, <span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-string">&#x27;ol&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;param&#x27;</span>, <span class="hljs-string">&#x27;plaintext&#x27;</span>, <span class="hljs-string">&#x27;pre&#x27;</span>, <span class="hljs-string">&#x27;script&#x27;</span>, <span class="hljs-string">&#x27;section&#x27;</span>, <span class="hljs-string">&#x27;select&#x27;</span>, <span class="hljs-string">&#x27;source&#x27;</span>, <span class="hljs-string">&#x27;style&#x27;</span>, <span class="hljs-string">&#x27;summary&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>, <span class="hljs-string">&#x27;tbody&#x27;</span>, <span class="hljs-string">&#x27;td&#x27;</span>, <span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-string">&#x27;textarea&#x27;</span>, <span class="hljs-string">&#x27;tfoot&#x27;</span>, <span class="hljs-string">&#x27;th&#x27;</span>, <span class="hljs-string">&#x27;thead&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;tr&#x27;</span>, <span class="hljs-string">&#x27;track&#x27;</span>, <span class="hljs-string">&#x27;ul&#x27;</span>, <span class="hljs-string">&#x27;wbr&#x27;</span>, <span class="hljs-string">&#x27;xmp&#x27;</span>]; <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope</span>

    <span class="hljs-keyword">var</span> inScopeTags = [<span class="hljs-string">&#x27;applet&#x27;</span>, <span class="hljs-string">&#x27;caption&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>, <span class="hljs-string">&#x27;td&#x27;</span>, <span class="hljs-string">&#x27;th&#x27;</span>, <span class="hljs-string">&#x27;marquee&#x27;</span>, <span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-string">&#x27;template&#x27;</span>, <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point</span></pre></div></div>
            
        </li>
        
        
        <li id="section-409">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-409">&#x00a7;</a>
              </div>
              <p>TODO: Distinguish by namespace here – for <title>, including it here
errs on the side of fewer warnings</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-string">&#x27;foreignObject&#x27;</span>, <span class="hljs-string">&#x27;desc&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>]; <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope</span>

    <span class="hljs-keyword">var</span> buttonScopeTags = inScopeTags.<span class="hljs-title function_">concat</span>([<span class="hljs-string">&#x27;button&#x27;</span>]); <span class="hljs-comment">// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags</span>

    <span class="hljs-keyword">var</span> impliedEndTags = [<span class="hljs-string">&#x27;dd&#x27;</span>, <span class="hljs-string">&#x27;dt&#x27;</span>, <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-string">&#x27;option&#x27;</span>, <span class="hljs-string">&#x27;optgroup&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;rp&#x27;</span>, <span class="hljs-string">&#x27;rt&#x27;</span>];
    <span class="hljs-keyword">var</span> emptyAncestorInfo = {
      <span class="hljs-attr">current</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">formTag</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">aTagInScope</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">buttonTagInScope</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">nobrTagInScope</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">pTagInButtonScope</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">listItemTagAutoclosing</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">dlItemTagAutoclosing</span>: <span class="hljs-literal">null</span>
    };

    updatedAncestorInfo = <span class="hljs-keyword">function</span> (<span class="hljs-params">oldInfo, tag</span>) {
      <span class="hljs-keyword">var</span> ancestorInfo = <span class="hljs-title function_">_assign</span>({}, oldInfo || emptyAncestorInfo);

      <span class="hljs-keyword">var</span> info = {
        <span class="hljs-attr">tag</span>: tag
      };

      <span class="hljs-keyword">if</span> (inScopeTags.<span class="hljs-title function_">indexOf</span>(tag) !== -<span class="hljs-number">1</span>) {
        ancestorInfo.<span class="hljs-property">aTagInScope</span> = <span class="hljs-literal">null</span>;
        ancestorInfo.<span class="hljs-property">buttonTagInScope</span> = <span class="hljs-literal">null</span>;
        ancestorInfo.<span class="hljs-property">nobrTagInScope</span> = <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (buttonScopeTags.<span class="hljs-title function_">indexOf</span>(tag) !== -<span class="hljs-number">1</span>) {
        ancestorInfo.<span class="hljs-property">pTagInButtonScope</span> = <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// See rules for &#x27;li&#x27;, &#x27;dd&#x27;, &#x27;dt&#x27; start tags in</span></pre></div></div>
            
        </li>
        
        
        <li id="section-410">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-410">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (specialTags.<span class="hljs-title function_">indexOf</span>(tag) !== -<span class="hljs-number">1</span> &amp;&amp; tag !== <span class="hljs-string">&#x27;address&#x27;</span> &amp;&amp; tag !== <span class="hljs-string">&#x27;div&#x27;</span> &amp;&amp; tag !== <span class="hljs-string">&#x27;p&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">listItemTagAutoclosing</span> = <span class="hljs-literal">null</span>;
        ancestorInfo.<span class="hljs-property">dlItemTagAutoclosing</span> = <span class="hljs-literal">null</span>;
      }

      ancestorInfo.<span class="hljs-property">current</span> = info;

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;form&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">formTag</span> = info;
      }

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;a&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">aTagInScope</span> = info;
      }

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;button&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">buttonTagInScope</span> = info;
      }

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;nobr&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">nobrTagInScope</span> = info;
      }

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;p&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">pTagInButtonScope</span> = info;
      }

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;li&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">listItemTagAutoclosing</span> = info;
      }

      <span class="hljs-keyword">if</span> (tag === <span class="hljs-string">&#x27;dd&#x27;</span> || tag === <span class="hljs-string">&#x27;dt&#x27;</span>) {
        ancestorInfo.<span class="hljs-property">dlItemTagAutoclosing</span> = info;
      }

      <span class="hljs-keyword">return</span> ancestorInfo;
    };
    <span class="hljs-comment">/**
     * Returns whether
     */</span>


    <span class="hljs-keyword">var</span> isTagValidWithParent = <span class="hljs-keyword">function</span> (<span class="hljs-params">tag, parentTag</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-411">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-411">&#x00a7;</a>
              </div>
              <p>First, let’s check if we’re in an unusual parsing mode…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">switch</span> (parentTag) {</pre></div></div>
            
        </li>
        
        
        <li id="section-412">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-412">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;option&#x27;</span> || tag === <span class="hljs-string">&#x27;optgroup&#x27;</span> || tag === <span class="hljs-string">&#x27;#text&#x27;</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;optgroup&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;option&#x27;</span> || tag === <span class="hljs-string">&#x27;#text&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-413">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-413">&#x00a7;</a>
              </div>
              <p>Strictly speaking, seeing an <option> doesn’t mean we’re in a <select>
but</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;option&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;#text&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-414">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-414">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd</a>
<a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption</a>
No special behavior since these rules fall back to “in body” mode for
all except special table nodes which cause bad parsing behavior anyway.
<a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tr&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;th&#x27;</span> || tag === <span class="hljs-string">&#x27;td&#x27;</span> || tag === <span class="hljs-string">&#x27;style&#x27;</span> || tag === <span class="hljs-string">&#x27;script&#x27;</span> || tag === <span class="hljs-string">&#x27;template&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-415">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-415">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tbody&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;thead&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tfoot&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;tr&#x27;</span> || tag === <span class="hljs-string">&#x27;style&#x27;</span> || tag === <span class="hljs-string">&#x27;script&#x27;</span> || tag === <span class="hljs-string">&#x27;template&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-416">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-416">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;colgroup&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;col&#x27;</span> || tag === <span class="hljs-string">&#x27;template&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-417">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-417">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;table&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;caption&#x27;</span> || tag === <span class="hljs-string">&#x27;colgroup&#x27;</span> || tag === <span class="hljs-string">&#x27;tbody&#x27;</span> || tag === <span class="hljs-string">&#x27;tfoot&#x27;</span> || tag === <span class="hljs-string">&#x27;thead&#x27;</span> || tag === <span class="hljs-string">&#x27;style&#x27;</span> || tag === <span class="hljs-string">&#x27;script&#x27;</span> || tag === <span class="hljs-string">&#x27;template&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-418">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-418">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;head&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;base&#x27;</span> || tag === <span class="hljs-string">&#x27;basefont&#x27;</span> || tag === <span class="hljs-string">&#x27;bgsound&#x27;</span> || tag === <span class="hljs-string">&#x27;link&#x27;</span> || tag === <span class="hljs-string">&#x27;meta&#x27;</span> || tag === <span class="hljs-string">&#x27;title&#x27;</span> || tag === <span class="hljs-string">&#x27;noscript&#x27;</span> || tag === <span class="hljs-string">&#x27;noframes&#x27;</span> || tag === <span class="hljs-string">&#x27;style&#x27;</span> || tag === <span class="hljs-string">&#x27;script&#x27;</span> || tag === <span class="hljs-string">&#x27;template&#x27;</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-419">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-419">&#x00a7;</a>
              </div>
              <p><a href="https://html.spec.whatwg.org/multipage/semantics.html#the-html-element">https://html.spec.whatwg.org/multipage/semantics.html#the-html-element</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;html&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;head&#x27;</span> || tag === <span class="hljs-string">&#x27;body&#x27;</span> || tag === <span class="hljs-string">&#x27;frameset&#x27;</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;frameset&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;frame&#x27;</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#document&#x27;</span>:
          <span class="hljs-keyword">return</span> tag === <span class="hljs-string">&#x27;html&#x27;</span>;
      } <span class="hljs-comment">// Probably in the &quot;in body&quot; parsing mode, so we outlaw only tag combos</span></pre></div></div>
            
        </li>
        
        
        <li id="section-420">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-420">&#x00a7;</a>
              </div>
              <p>where the parsing rules cause implicit opens or closes to be added.
<a href="https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody">https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h1&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h2&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h3&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h4&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h5&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h6&#x27;</span>:
          <span class="hljs-keyword">return</span> parentTag !== <span class="hljs-string">&#x27;h1&#x27;</span> &amp;&amp; parentTag !== <span class="hljs-string">&#x27;h2&#x27;</span> &amp;&amp; parentTag !== <span class="hljs-string">&#x27;h3&#x27;</span> &amp;&amp; parentTag !== <span class="hljs-string">&#x27;h4&#x27;</span> &amp;&amp; parentTag !== <span class="hljs-string">&#x27;h5&#x27;</span> &amp;&amp; parentTag !== <span class="hljs-string">&#x27;h6&#x27;</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;rp&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;rt&#x27;</span>:
          <span class="hljs-keyword">return</span> impliedEndTags.<span class="hljs-title function_">indexOf</span>(parentTag) === -<span class="hljs-number">1</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;body&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;caption&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;col&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;colgroup&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;frameset&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;frame&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;head&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;html&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tbody&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;td&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tfoot&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;th&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;thead&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tr&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-421">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-421">&#x00a7;</a>
              </div>
              <p>These tags are only valid with a few parents that have special child
parsing rules – if we’re down here, then none of those matched and
so we allow it only if we don’t know what the parent is, as all other
cases are invalid.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> parentTag == <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };
    <span class="hljs-comment">/**
     * Returns whether
     */</span>


    <span class="hljs-keyword">var</span> findInvalidAncestorForTag = <span class="hljs-keyword">function</span> (<span class="hljs-params">tag, ancestorInfo</span>) {
      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;address&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;article&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;aside&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;blockquote&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;center&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;details&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dialog&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dir&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;div&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dl&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;fieldset&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;figcaption&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;figure&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;footer&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;header&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hgroup&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;main&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;menu&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;nav&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ol&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;p&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;section&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;summary&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ul&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;pre&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;listing&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;table&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hr&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;xmp&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h1&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h2&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h3&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h4&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h5&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h6&#x27;</span>:
          <span class="hljs-keyword">return</span> ancestorInfo.<span class="hljs-property">pTagInButtonScope</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;form&#x27;</span>:
          <span class="hljs-keyword">return</span> ancestorInfo.<span class="hljs-property">formTag</span> || ancestorInfo.<span class="hljs-property">pTagInButtonScope</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;li&#x27;</span>:
          <span class="hljs-keyword">return</span> ancestorInfo.<span class="hljs-property">listItemTagAutoclosing</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dd&#x27;</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;dt&#x27;</span>:
          <span class="hljs-keyword">return</span> ancestorInfo.<span class="hljs-property">dlItemTagAutoclosing</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;button&#x27;</span>:
          <span class="hljs-keyword">return</span> ancestorInfo.<span class="hljs-property">buttonTagInScope</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-422">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-422">&#x00a7;</a>
              </div>
              <p>Spec says something about storing a list of markers, but it sounds
equivalent to this check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> ancestorInfo.<span class="hljs-property">aTagInScope</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;nobr&#x27;</span>:
          <span class="hljs-keyword">return</span> ancestorInfo.<span class="hljs-property">nobrTagInScope</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    };

    <span class="hljs-keyword">var</span> didWarn$<span class="hljs-number">1</span> = {};

    validateDOMNesting = <span class="hljs-keyword">function</span> (<span class="hljs-params">childTag, childText, ancestorInfo</span>) {
      ancestorInfo = ancestorInfo || emptyAncestorInfo;
      <span class="hljs-keyword">var</span> parentInfo = ancestorInfo.<span class="hljs-property">current</span>;
      <span class="hljs-keyword">var</span> parentTag = parentInfo &amp;&amp; parentInfo.<span class="hljs-property">tag</span>;

      <span class="hljs-keyword">if</span> (childText != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (childTag != <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;validateDOMNesting: when childText is passed, childTag should be null&#x27;</span>);
        }

        childTag = <span class="hljs-string">&#x27;#text&#x27;</span>;
      }

      <span class="hljs-keyword">var</span> invalidParent = <span class="hljs-title function_">isTagValidWithParent</span>(childTag, parentTag) ? <span class="hljs-literal">null</span> : parentInfo;
      <span class="hljs-keyword">var</span> invalidAncestor = invalidParent ? <span class="hljs-literal">null</span> : <span class="hljs-title function_">findInvalidAncestorForTag</span>(childTag, ancestorInfo);
      <span class="hljs-keyword">var</span> invalidParentOrAncestor = invalidParent || invalidAncestor;

      <span class="hljs-keyword">if</span> (!invalidParentOrAncestor) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> ancestorTag = invalidParentOrAncestor.<span class="hljs-property">tag</span>;
      <span class="hljs-keyword">var</span> warnKey = !!invalidParent + <span class="hljs-string">&#x27;|&#x27;</span> + childTag + <span class="hljs-string">&#x27;|&#x27;</span> + ancestorTag;

      <span class="hljs-keyword">if</span> (didWarn$<span class="hljs-number">1</span>[warnKey]) {
        <span class="hljs-keyword">return</span>;
      }

      didWarn$<span class="hljs-number">1</span>[warnKey] = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> tagDisplayName = childTag;
      <span class="hljs-keyword">var</span> whitespaceInfo = <span class="hljs-string">&#x27;&#x27;</span>;

      <span class="hljs-keyword">if</span> (childTag === <span class="hljs-string">&#x27;#text&#x27;</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/\S/</span>.<span class="hljs-title function_">test</span>(childText)) {
          tagDisplayName = <span class="hljs-string">&#x27;Text nodes&#x27;</span>;
        } <span class="hljs-keyword">else</span> {
          tagDisplayName = <span class="hljs-string">&#x27;Whitespace text nodes&#x27;</span>;
          whitespaceInfo = <span class="hljs-string">&quot; Make sure you don&#x27;t have any extra whitespace between tags on &quot;</span> + <span class="hljs-string">&#x27;each line of your source code.&#x27;</span>;
        }
      } <span class="hljs-keyword">else</span> {
        tagDisplayName = <span class="hljs-string">&#x27;&lt;&#x27;</span> + childTag + <span class="hljs-string">&#x27;&gt;&#x27;</span>;
      }

      <span class="hljs-keyword">if</span> (invalidParent) {
        <span class="hljs-keyword">var</span> info = <span class="hljs-string">&#x27;&#x27;</span>;

        <span class="hljs-keyword">if</span> (ancestorTag === <span class="hljs-string">&#x27;table&#x27;</span> &amp;&amp; childTag === <span class="hljs-string">&#x27;tr&#x27;</span>) {
          info += <span class="hljs-string">&#x27; Add a &lt;tbody&gt;, &lt;thead&gt; or &lt;tfoot&gt; to your code to match the DOM tree generated by &#x27;</span> + <span class="hljs-string">&#x27;the browser.&#x27;</span>;
        }

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;validateDOMNesting(...): %s cannot appear as a child of &lt;%s&gt;.%s%s&#x27;</span>, tagDisplayName, ancestorTag, whitespaceInfo, info);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;validateDOMNesting(...): %s cannot appear as a descendant of &#x27;</span> + <span class="hljs-string">&#x27;&lt;%s&gt;.&#x27;</span>, tagDisplayName, ancestorTag);
      }
    };
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>$<span class="hljs-number">1</span>;

  {
    <span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>$<span class="hljs-number">1</span> = <span class="hljs-string">&#x27;suppressHydrationWarning&#x27;</span>;
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUSPENSE_START_DATA</span> = <span class="hljs-string">&#x27;$&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUSPENSE_END_DATA</span> = <span class="hljs-string">&#x27;/$&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUSPENSE_PENDING_START_DATA</span> = <span class="hljs-string">&#x27;$?&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUSPENSE_FALLBACK_START_DATA</span> = <span class="hljs-string">&#x27;$!&#x27;</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">STYLE</span>$<span class="hljs-number">1</span> = <span class="hljs-string">&#x27;style&#x27;</span>;
  <span class="hljs-keyword">var</span> eventsEnabled = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> selectionInformation = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldAutoFocusHostComponent</span>(<span class="hljs-params">type, props</span>) {
    <span class="hljs-keyword">switch</span> (type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;button&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;input&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;select&#x27;</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;textarea&#x27;</span>:
        <span class="hljs-keyword">return</span> !!props.<span class="hljs-property">autoFocus</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRootHostContext</span>(<span class="hljs-params">rootContainerInstance</span>) {
    <span class="hljs-keyword">var</span> type;
    <span class="hljs-keyword">var</span> namespace;
    <span class="hljs-keyword">var</span> nodeType = rootContainerInstance.<span class="hljs-property">nodeType</span>;

    <span class="hljs-keyword">switch</span> (nodeType) {
      <span class="hljs-keyword">case</span> <span class="hljs-attr">DOCUMENT_NODE</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-attr">DOCUMENT_FRAGMENT_NODE</span>:
        {
          type = nodeType === <span class="hljs-variable constant_">DOCUMENT_NODE</span> ? <span class="hljs-string">&#x27;#document&#x27;</span> : <span class="hljs-string">&#x27;#fragment&#x27;</span>;
          <span class="hljs-keyword">var</span> root = rootContainerInstance.<span class="hljs-property">documentElement</span>;
          namespace = root ? root.<span class="hljs-property">namespaceURI</span> : <span class="hljs-title function_">getChildNamespace</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;&#x27;</span>);
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-attr">default</span>:
        {
          <span class="hljs-keyword">var</span> container = nodeType === <span class="hljs-variable constant_">COMMENT_NODE</span> ? rootContainerInstance.<span class="hljs-property">parentNode</span> : rootContainerInstance;
          <span class="hljs-keyword">var</span> ownNamespace = container.<span class="hljs-property">namespaceURI</span> || <span class="hljs-literal">null</span>;
          type = container.<span class="hljs-property">tagName</span>;
          namespace = <span class="hljs-title function_">getChildNamespace</span>(ownNamespace, type);
          <span class="hljs-keyword">break</span>;
        }
    }

    {
      <span class="hljs-keyword">var</span> validatedTag = type.<span class="hljs-title function_">toLowerCase</span>();
      <span class="hljs-keyword">var</span> ancestorInfo = <span class="hljs-title function_">updatedAncestorInfo</span>(<span class="hljs-literal">null</span>, validatedTag);
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">namespace</span>: namespace,
        <span class="hljs-attr">ancestorInfo</span>: ancestorInfo
      };
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getChildHostContext</span>(<span class="hljs-params">parentHostContext, type, rootContainerInstance</span>) {
    {
      <span class="hljs-keyword">var</span> parentHostContextDev = parentHostContext;
      <span class="hljs-keyword">var</span> namespace = <span class="hljs-title function_">getChildNamespace</span>(parentHostContextDev.<span class="hljs-property">namespace</span>, type);
      <span class="hljs-keyword">var</span> ancestorInfo = <span class="hljs-title function_">updatedAncestorInfo</span>(parentHostContextDev.<span class="hljs-property">ancestorInfo</span>, type);
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">namespace</span>: namespace,
        <span class="hljs-attr">ancestorInfo</span>: ancestorInfo
      };
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPublicInstance</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">return</span> instance;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareForCommit</span>(<span class="hljs-params">containerInfo</span>) {
    eventsEnabled = <span class="hljs-title function_">isEnabled</span>();
    selectionInformation = <span class="hljs-title function_">getSelectionInformation</span>();
    <span class="hljs-keyword">var</span> activeInstance = <span class="hljs-literal">null</span>;

    <span class="hljs-title function_">setEnabled</span>(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">return</span> activeInstance;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetAfterCommit</span>(<span class="hljs-params">containerInfo</span>) {
    <span class="hljs-title function_">restoreSelection</span>(selectionInformation);
    <span class="hljs-title function_">setEnabled</span>(eventsEnabled);
    eventsEnabled = <span class="hljs-literal">null</span>;
    selectionInformation = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params">type, props, rootContainerInstance, hostContext, internalInstanceHandle</span>) {
    <span class="hljs-keyword">var</span> parentNamespace;

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-423">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-423">&#x00a7;</a>
              </div>
              <p>TODO: take namespace into account when validating.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> hostContextDev = hostContext;
      <span class="hljs-title function_">validateDOMNesting</span>(type, <span class="hljs-literal">null</span>, hostContextDev.<span class="hljs-property">ancestorInfo</span>);

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> props.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> props.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;&#x27;</span> + props.<span class="hljs-property">children</span>;
        <span class="hljs-keyword">var</span> ownAncestorInfo = <span class="hljs-title function_">updatedAncestorInfo</span>(hostContextDev.<span class="hljs-property">ancestorInfo</span>, type);
        <span class="hljs-title function_">validateDOMNesting</span>(<span class="hljs-literal">null</span>, string, ownAncestorInfo);
      }

      parentNamespace = hostContextDev.<span class="hljs-property">namespace</span>;
    }

    <span class="hljs-keyword">var</span> domElement = <span class="hljs-title function_">createElement</span>(type, props, rootContainerInstance, parentNamespace);
    <span class="hljs-title function_">precacheFiberNode</span>(internalInstanceHandle, domElement);
    <span class="hljs-title function_">updateFiberProps</span>(domElement, props);
    <span class="hljs-keyword">return</span> domElement;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">appendInitialChild</span>(<span class="hljs-params">parentInstance, child</span>) {
    parentInstance.<span class="hljs-title function_">appendChild</span>(child);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">finalizeInitialChildren</span>(<span class="hljs-params">domElement, type, props, rootContainerInstance, hostContext</span>) {
    <span class="hljs-title function_">setInitialProperties</span>(domElement, type, props, rootContainerInstance);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">shouldAutoFocusHostComponent</span>(type, props);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareUpdate</span>(<span class="hljs-params">domElement, type, oldProps, newProps, rootContainerInstance, hostContext</span>) {
    {
      <span class="hljs-keyword">var</span> hostContextDev = hostContext;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newProps.<span class="hljs-property">children</span> !== <span class="hljs-keyword">typeof</span> oldProps.<span class="hljs-property">children</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> newProps.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> newProps.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;number&#x27;</span>)) {
        <span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;&#x27;</span> + newProps.<span class="hljs-property">children</span>;
        <span class="hljs-keyword">var</span> ownAncestorInfo = <span class="hljs-title function_">updatedAncestorInfo</span>(hostContextDev.<span class="hljs-property">ancestorInfo</span>, type);
        <span class="hljs-title function_">validateDOMNesting</span>(<span class="hljs-literal">null</span>, string, ownAncestorInfo);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">diffProperties</span>(domElement, type, oldProps, newProps);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldSetTextContent</span>(<span class="hljs-params">type, props</span>) {
    <span class="hljs-keyword">return</span> type === <span class="hljs-string">&#x27;textarea&#x27;</span> || type === <span class="hljs-string">&#x27;option&#x27;</span> || type === <span class="hljs-string">&#x27;noscript&#x27;</span> || <span class="hljs-keyword">typeof</span> props.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> props.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;number&#x27;</span> || <span class="hljs-keyword">typeof</span> props.<span class="hljs-property">dangerouslySetInnerHTML</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; props.<span class="hljs-property">dangerouslySetInnerHTML</span> !== <span class="hljs-literal">null</span> &amp;&amp; props.<span class="hljs-property">dangerouslySetInnerHTML</span>.<span class="hljs-property">__html</span> != <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextInstance</span>(<span class="hljs-params">text, rootContainerInstance, hostContext, internalInstanceHandle</span>) {
    {
      <span class="hljs-keyword">var</span> hostContextDev = hostContext;
      <span class="hljs-title function_">validateDOMNesting</span>(<span class="hljs-literal">null</span>, text, hostContextDev.<span class="hljs-property">ancestorInfo</span>);
    }

    <span class="hljs-keyword">var</span> textNode = <span class="hljs-title function_">createTextNode</span>(text, rootContainerInstance);
    <span class="hljs-title function_">precacheFiberNode</span>(internalInstanceHandle, textNode);
    <span class="hljs-keyword">return</span> textNode;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-424">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-424">&#x00a7;</a>
              </div>
              <p>if a component just imports ReactDOM (e.g. for findDOMNode).
Some environments might not have setTimeout or clearTimeout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> scheduleTimeout = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">setTimeout</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-built_in">setTimeout</span> : <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">var</span> cancelTimeout = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">clearTimeout</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-built_in">clearTimeout</span> : <span class="hljs-literal">undefined</span>;
  <span class="hljs-keyword">var</span> noTimeout = -<span class="hljs-number">1</span>; <span class="hljs-comment">// -------------------</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitMount</span>(<span class="hljs-params">domElement, type, newProps, internalInstanceHandle</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-425">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-425">&#x00a7;</a>
              </div>
              <p>Despite the naming that might imply otherwise, this method only
fires if there is an <code>Update</code> effect scheduled during mounting.
This happens if <code>finalizeInitialChildren</code> returns <code>true</code> (which it
does to implement the <code>autoFocus</code> attribute on the client). But
there are also other cases when this might happen (such as patching
up text content during hydration mismatch). So we’ll check this again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldAutoFocusHostComponent</span>(type, newProps)) {
      domElement.<span class="hljs-title function_">focus</span>();
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitUpdate</span>(<span class="hljs-params">domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-426">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-426">&#x00a7;</a>
              </div>
              <p>Update the props handle so that we know which props are the ones with
with current event handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">updateFiberProps</span>(domElement, newProps); <span class="hljs-comment">// Apply the diff to the DOM node.</span>

    <span class="hljs-title function_">updateProperties</span>(domElement, updatePayload, type, oldProps, newProps);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetTextContent</span>(<span class="hljs-params">domElement</span>) {
    <span class="hljs-title function_">setTextContent</span>(domElement, <span class="hljs-string">&#x27;&#x27;</span>);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitTextUpdate</span>(<span class="hljs-params">textInstance, oldText, newText</span>) {
    textInstance.<span class="hljs-property">nodeValue</span> = newText;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">appendChild</span>(<span class="hljs-params">parentInstance, child</span>) {
    parentInstance.<span class="hljs-title function_">appendChild</span>(child);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">appendChildToContainer</span>(<span class="hljs-params">container, child</span>) {
    <span class="hljs-keyword">var</span> parentNode;

    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
      parentNode = container.<span class="hljs-property">parentNode</span>;
      parentNode.<span class="hljs-title function_">insertBefore</span>(child, container);
    } <span class="hljs-keyword">else</span> {
      parentNode = container;
      parentNode.<span class="hljs-title function_">appendChild</span>(child);
    } <span class="hljs-comment">// This container might be used for a portal.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-427">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-427">&#x00a7;</a>
              </div>
              <p>If something inside a portal is clicked, that click should bubble
through the React tree. However, on Mobile Safari the click would
never bubble through the <em>DOM</em> tree unless an ancestor with onclick
event exists. So we wouldn’t see it and dispatch it.
This is why we ensure that non React root containers have inline onclick
defined.
<a href="https://github.com/facebook/react/issues/11918">https://github.com/facebook/react/issues/11918</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> reactRootContainer = container.<span class="hljs-property">_reactRootContainer</span>;

    <span class="hljs-keyword">if</span> ((reactRootContainer === <span class="hljs-literal">null</span> || reactRootContainer === <span class="hljs-literal">undefined</span>) &amp;&amp; parentNode.<span class="hljs-property">onclick</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-428">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-428">&#x00a7;</a>
              </div>
              <p>TODO: This cast may not be sound for SVG, MathML or custom elements.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">trapClickOnNonInteractiveElement</span>(parentNode);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">insertBefore</span>(<span class="hljs-params">parentInstance, child, beforeChild</span>) {
    parentInstance.<span class="hljs-title function_">insertBefore</span>(child, beforeChild);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">insertInContainerBefore</span>(<span class="hljs-params">container, child, beforeChild</span>) {
    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
      container.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">insertBefore</span>(child, beforeChild);
    } <span class="hljs-keyword">else</span> {
      container.<span class="hljs-title function_">insertBefore</span>(child, beforeChild);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">removeChild</span>(<span class="hljs-params">parentInstance, child</span>) {
    parentInstance.<span class="hljs-title function_">removeChild</span>(child);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">removeChildFromContainer</span>(<span class="hljs-params">container, child</span>) {
    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
      container.<span class="hljs-property">parentNode</span>.<span class="hljs-title function_">removeChild</span>(child);
    } <span class="hljs-keyword">else</span> {
      container.<span class="hljs-title function_">removeChild</span>(child);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clearSuspenseBoundary</span>(<span class="hljs-params">parentInstance, suspenseInstance</span>) {
    <span class="hljs-keyword">var</span> node = suspenseInstance; <span class="hljs-comment">// Delete all nodes within this suspense boundary.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-429">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-429">&#x00a7;</a>
              </div>
              <p>There might be nested nodes so we need to keep track of how
deep we are and only break out when we’re back on top.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> depth = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">var</span> nextNode = node.<span class="hljs-property">nextSibling</span>;
      parentInstance.<span class="hljs-title function_">removeChild</span>(node);

      <span class="hljs-keyword">if</span> (nextNode &amp;&amp; nextNode.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
        <span class="hljs-keyword">var</span> data = nextNode.<span class="hljs-property">data</span>;

        <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_END_DATA</span>) {
          <span class="hljs-keyword">if</span> (depth === <span class="hljs-number">0</span>) {
            parentInstance.<span class="hljs-title function_">removeChild</span>(nextNode); <span class="hljs-comment">// Retry if any event replaying was blocked on this.</span>

            <span class="hljs-title function_">retryIfBlockedOn</span>(suspenseInstance);
            <span class="hljs-keyword">return</span>;
          } <span class="hljs-keyword">else</span> {
            depth--;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_START_DATA</span> || data === <span class="hljs-variable constant_">SUSPENSE_PENDING_START_DATA</span> || data === <span class="hljs-variable constant_">SUSPENSE_FALLBACK_START_DATA</span>) {
          depth++;
        }
      }

      node = nextNode;
    } <span class="hljs-keyword">while</span> (node); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Warn, we didn&#x27;t find the end comment boundary.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-430">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-430">&#x00a7;</a>
              </div>
              <p>Retry if any event replaying was blocked on this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-title function_">retryIfBlockedOn</span>(suspenseInstance);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clearSuspenseBoundaryFromContainer</span>(<span class="hljs-params">container, suspenseInstance</span>) {
    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
      <span class="hljs-title function_">clearSuspenseBoundary</span>(container.<span class="hljs-property">parentNode</span>, suspenseInstance);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span>) {
      <span class="hljs-title function_">clearSuspenseBoundary</span>(container, suspenseInstance);
    } <span class="hljs-comment">// Retry if any event replaying was blocked on this.</span>


    <span class="hljs-title function_">retryIfBlockedOn</span>(container);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hideInstance</span>(<span class="hljs-params">instance</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-431">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-431">&#x00a7;</a>
              </div>
              <p>TODO: Does this work for all element types? What about MathML? Should we
pass host context to this method?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    instance = instance;
    <span class="hljs-keyword">var</span> style = instance.<span class="hljs-property">style</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> style.<span class="hljs-property">setProperty</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      style.<span class="hljs-title function_">setProperty</span>(<span class="hljs-string">&#x27;display&#x27;</span>, <span class="hljs-string">&#x27;none&#x27;</span>, <span class="hljs-string">&#x27;important&#x27;</span>);
    } <span class="hljs-keyword">else</span> {
      style.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hideTextInstance</span>(<span class="hljs-params">textInstance</span>) {
    textInstance.<span class="hljs-property">nodeValue</span> = <span class="hljs-string">&#x27;&#x27;</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unhideInstance</span>(<span class="hljs-params">instance, props</span>) {
    instance = instance;
    <span class="hljs-keyword">var</span> styleProp = props[<span class="hljs-variable constant_">STYLE</span>$<span class="hljs-number">1</span>];
    <span class="hljs-keyword">var</span> display = styleProp !== <span class="hljs-literal">undefined</span> &amp;&amp; styleProp !== <span class="hljs-literal">null</span> &amp;&amp; styleProp.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;display&#x27;</span>) ? styleProp.<span class="hljs-property">display</span> : <span class="hljs-literal">null</span>;
    instance.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-title function_">dangerousStyleValue</span>(<span class="hljs-string">&#x27;display&#x27;</span>, display);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unhideTextInstance</span>(<span class="hljs-params">textInstance, text</span>) {
    textInstance.<span class="hljs-property">nodeValue</span> = text;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">clearContainer</span>(<span class="hljs-params">container</span>) {
    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span>) {
      container.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_NODE</span>) {
      <span class="hljs-keyword">var</span> body = container.<span class="hljs-property">body</span>;

      <span class="hljs-keyword">if</span> (body != <span class="hljs-literal">null</span>) {
        body.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;&#x27;</span>;
      }
    }
  } <span class="hljs-comment">// -------------------</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">canHydrateInstance</span>(<span class="hljs-params">instance, type, props</span>) {
    <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">nodeType</span> !== <span class="hljs-variable constant_">ELEMENT_NODE</span> || type.<span class="hljs-title function_">toLowerCase</span>() !== instance.<span class="hljs-property">nodeName</span>.<span class="hljs-title function_">toLowerCase</span>()) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// This has now been refined to an element node.</span>


    <span class="hljs-keyword">return</span> instance;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">canHydrateTextInstance</span>(<span class="hljs-params">instance, text</span>) {
    <span class="hljs-keyword">if</span> (text === <span class="hljs-string">&#x27;&#x27;</span> || instance.<span class="hljs-property">nodeType</span> !== <span class="hljs-variable constant_">TEXT_NODE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-432">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-432">&#x00a7;</a>
              </div>
              <p>Empty strings are not parsed by HTML so there won’t be a correct match here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// This has now been refined to a text node.</span>


    <span class="hljs-keyword">return</span> instance;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">canHydrateSuspenseInstance</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">nodeType</span> !== <span class="hljs-variable constant_">COMMENT_NODE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-433">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-433">&#x00a7;</a>
              </div>
              <p>Empty strings are not parsed by HTML so there won’t be a correct match here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// This has now been refined to a suspense node.</span>


    <span class="hljs-keyword">return</span> instance;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isSuspenseInstancePending</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">return</span> instance.<span class="hljs-property">data</span> === <span class="hljs-variable constant_">SUSPENSE_PENDING_START_DATA</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isSuspenseInstanceFallback</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">return</span> instance.<span class="hljs-property">data</span> === <span class="hljs-variable constant_">SUSPENSE_FALLBACK_START_DATA</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerSuspenseInstanceRetry</span>(<span class="hljs-params">instance, callback</span>) {
    instance.<span class="hljs-property">_reactRetry</span> = callback;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNextHydratable</span>(<span class="hljs-params">node</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-434">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-434">&#x00a7;</a>
              </div>
              <p>Skip non-hydratable nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">for</span> (; node != <span class="hljs-literal">null</span>; node = node.<span class="hljs-property">nextSibling</span>) {
      <span class="hljs-keyword">var</span> nodeType = node.<span class="hljs-property">nodeType</span>;

      <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-variable constant_">ELEMENT_NODE</span> || nodeType === <span class="hljs-variable constant_">TEXT_NODE</span>) {
        <span class="hljs-keyword">break</span>;
      }

      {
        <span class="hljs-keyword">if</span> (nodeType === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
          <span class="hljs-keyword">var</span> nodeData = node.<span class="hljs-property">data</span>;

          <span class="hljs-keyword">if</span> (nodeData === <span class="hljs-variable constant_">SUSPENSE_START_DATA</span> || nodeData === <span class="hljs-variable constant_">SUSPENSE_FALLBACK_START_DATA</span> || nodeData === <span class="hljs-variable constant_">SUSPENSE_PENDING_START_DATA</span>) {
            <span class="hljs-keyword">break</span>;
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> node;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNextHydratableSibling</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getNextHydratable</span>(instance.<span class="hljs-property">nextSibling</span>);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFirstHydratableChild</span>(<span class="hljs-params">parentInstance</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getNextHydratable</span>(parentInstance.<span class="hljs-property">firstChild</span>);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hydrateInstance</span>(<span class="hljs-params">instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle</span>) {
    <span class="hljs-title function_">precacheFiberNode</span>(internalInstanceHandle, instance); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Possibly defer this until the commit phase where all the events</span></pre></div></div>
            
        </li>
        
        
        <li id="section-435">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-435">&#x00a7;</a>
              </div>
              <p>get attached.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title function_">updateFiberProps</span>(instance, props);
    <span class="hljs-keyword">var</span> parentNamespace;

    {
      <span class="hljs-keyword">var</span> hostContextDev = hostContext;
      parentNamespace = hostContextDev.<span class="hljs-property">namespace</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">diffHydratedProperties</span>(instance, type, props, parentNamespace);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hydrateTextInstance</span>(<span class="hljs-params">textInstance, text, internalInstanceHandle</span>) {
    <span class="hljs-title function_">precacheFiberNode</span>(internalInstanceHandle, textInstance);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">diffHydratedText</span>(textInstance, text);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hydrateSuspenseInstance</span>(<span class="hljs-params">suspenseInstance, internalInstanceHandle</span>) {
    <span class="hljs-title function_">precacheFiberNode</span>(internalInstanceHandle, suspenseInstance);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNextHydratableInstanceAfterSuspenseInstance</span>(<span class="hljs-params">suspenseInstance</span>) {
    <span class="hljs-keyword">var</span> node = suspenseInstance.<span class="hljs-property">nextSibling</span>; <span class="hljs-comment">// Skip past all nodes within this suspense boundary.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-436">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-436">&#x00a7;</a>
              </div>
              <p>There might be nested nodes so we need to keep track of how
deep we are and only break out when we’re back on top.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> depth = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (node) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
        <span class="hljs-keyword">var</span> data = node.<span class="hljs-property">data</span>;

        <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_END_DATA</span>) {
          <span class="hljs-keyword">if</span> (depth === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">getNextHydratableSibling</span>(node);
          } <span class="hljs-keyword">else</span> {
            depth--;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_START_DATA</span> || data === <span class="hljs-variable constant_">SUSPENSE_FALLBACK_START_DATA</span> || data === <span class="hljs-variable constant_">SUSPENSE_PENDING_START_DATA</span>) {
          depth++;
        }
      }

      node = node.<span class="hljs-property">nextSibling</span>;
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Warn, we didn&#x27;t find the end comment boundary.</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  } <span class="hljs-comment">// Returns the SuspenseInstance if this node is a direct child of a</span></pre></div></div>
            
        </li>
        
        
        <li id="section-437">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-437">&#x00a7;</a>
              </div>
              <p>SuspenseInstance. I.e. if its previous sibling is a Comment with
SUSPENSE_x_START_DATA. Otherwise, null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getParentSuspenseInstance</span>(<span class="hljs-params">targetInstance</span>) {
    <span class="hljs-keyword">var</span> node = targetInstance.<span class="hljs-property">previousSibling</span>; <span class="hljs-comment">// Skip past all nodes within this suspense boundary.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-438">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-438">&#x00a7;</a>
              </div>
              <p>There might be nested nodes so we need to keep track of how
deep we are and only break out when we’re back on top.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> depth = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (node) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>) {
        <span class="hljs-keyword">var</span> data = node.<span class="hljs-property">data</span>;

        <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_START_DATA</span> || data === <span class="hljs-variable constant_">SUSPENSE_FALLBACK_START_DATA</span> || data === <span class="hljs-variable constant_">SUSPENSE_PENDING_START_DATA</span>) {
          <span class="hljs-keyword">if</span> (depth === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> node;
          } <span class="hljs-keyword">else</span> {
            depth--;
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data === <span class="hljs-variable constant_">SUSPENSE_END_DATA</span>) {
          depth++;
        }
      }

      node = node.<span class="hljs-property">previousSibling</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitHydratedContainer</span>(<span class="hljs-params">container</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-439">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-439">&#x00a7;</a>
              </div>
              <p>Retry if any event replaying was blocked on this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">retryIfBlockedOn</span>(container);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitHydratedSuspenseInstance</span>(<span class="hljs-params">suspenseInstance</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-440">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-440">&#x00a7;</a>
              </div>
              <p>Retry if any event replaying was blocked on this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">retryIfBlockedOn</span>(suspenseInstance);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotMatchHydratedContainerTextInstance</span>(<span class="hljs-params">parentContainer, textInstance, text</span>) {
    {
      <span class="hljs-title function_">warnForUnmatchedText</span>(textInstance, text);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotMatchHydratedTextInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, textInstance, text</span>) {
    <span class="hljs-keyword">if</span> (parentProps[<span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
      <span class="hljs-title function_">warnForUnmatchedText</span>(textInstance, text);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotHydrateContainerInstance</span>(<span class="hljs-params">parentContainer, instance</span>) {
    {
      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span>) {
        <span class="hljs-title function_">warnForDeletedHydratableElement</span>(parentContainer, instance);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>); <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">warnForDeletedHydratableText</span>(parentContainer, instance);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotHydrateInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, instance</span>) {
    <span class="hljs-keyword">if</span> (parentProps[<span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span>) {
        <span class="hljs-title function_">warnForDeletedHydratableElement</span>(parentInstance, instance);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span>); <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">warnForDeletedHydratableText</span>(parentInstance, instance);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotFindHydratableContainerInstance</span>(<span class="hljs-params">parentContainer, type, props</span>) {
    {
      <span class="hljs-title function_">warnForInsertedHydratedElement</span>(parentContainer, type);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotFindHydratableContainerTextInstance</span>(<span class="hljs-params">parentContainer, text</span>) {
    {
      <span class="hljs-title function_">warnForInsertedHydratedText</span>(parentContainer, text);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotFindHydratableInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, type, props</span>) {
    <span class="hljs-keyword">if</span> (parentProps[<span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
      <span class="hljs-title function_">warnForInsertedHydratedElement</span>(parentInstance, type);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotFindHydratableTextInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance, text</span>) {
    <span class="hljs-keyword">if</span> (parentProps[<span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>) {
      <span class="hljs-title function_">warnForInsertedHydratedText</span>(parentInstance, text);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">didNotFindHydratableSuspenseInstance</span>(<span class="hljs-params">parentType, parentProps, parentInstance</span>) {
    <span class="hljs-keyword">if</span> (parentProps[<span class="hljs-variable constant_">SUPPRESS_HYDRATION_WARNING</span>$<span class="hljs-number">1</span>] !== <span class="hljs-literal">true</span>);
  }
  <span class="hljs-keyword">var</span> clientId = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeClientIdInDEV</span>(<span class="hljs-params">warnOnAccessInDEV</span>) {
    <span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;r:&#x27;</span> + (clientId++).<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>);
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">warnOnAccessInDEV</span>();
        <span class="hljs-keyword">return</span> id;
      },
      <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">warnOnAccessInDEV</span>();
        <span class="hljs-keyword">return</span> id;
      }
    };
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isOpaqueHydratingObject</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">return</span> value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; value.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_OPAQUE_ID_TYPE</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">makeOpaqueHydratingObject</span>(<span class="hljs-params">attemptToReadValue</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_OPAQUE_ID_TYPE</span>,
      <span class="hljs-attr">toString</span>: attemptToReadValue,
      <span class="hljs-attr">valueOf</span>: attemptToReadValue
    };
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">preparePortalMount</span>(<span class="hljs-params">portalInstance</span>) {
    {
      <span class="hljs-title function_">listenToAllSupportedEvents</span>(portalInstance);
    }
  }

  <span class="hljs-keyword">var</span> randomKey = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>().<span class="hljs-title function_">toString</span>(<span class="hljs-number">36</span>).<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);
  <span class="hljs-keyword">var</span> internalInstanceKey = <span class="hljs-string">&#x27;__reactFiber$&#x27;</span> + randomKey;
  <span class="hljs-keyword">var</span> internalPropsKey = <span class="hljs-string">&#x27;__reactProps$&#x27;</span> + randomKey;
  <span class="hljs-keyword">var</span> internalContainerInstanceKey = <span class="hljs-string">&#x27;__reactContainer$&#x27;</span> + randomKey;
  <span class="hljs-keyword">var</span> internalEventHandlersKey = <span class="hljs-string">&#x27;__reactEvents$&#x27;</span> + randomKey;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">precacheFiberNode</span>(<span class="hljs-params">hostInst, node</span>) {
    node[internalInstanceKey] = hostInst;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markContainerAsRoot</span>(<span class="hljs-params">hostRoot, node</span>) {
    node[internalContainerInstanceKey] = hostRoot;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unmarkContainerAsRoot</span>(<span class="hljs-params">node</span>) {
    node[internalContainerInstanceKey] = <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isContainerMarkedAsRoot</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> !!node[internalContainerInstanceKey];
  } <span class="hljs-comment">// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-441">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-441">&#x00a7;</a>
              </div>
              <p>If the target node is part of a hydrated or not yet rendered subtree, then
this may also return a SuspenseComponent or HostRoot to indicate that.
Conceptually the HostRoot fiber is a child of the Container node. So if you
pass the Container node as the targetNode, you will not actually get the
HostRoot back. To get to the HostRoot, you need to pass a child of it.
The same thing applies to Suspense boundaries.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getClosestInstanceFromNode</span>(<span class="hljs-params">targetNode</span>) {
    <span class="hljs-keyword">var</span> targetInst = targetNode[internalInstanceKey];

    <span class="hljs-keyword">if</span> (targetInst) {</pre></div></div>
            
        </li>
        
        
        <li id="section-442">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-442">&#x00a7;</a>
              </div>
              <p>Don’t return HostRoot or SuspenseComponent here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> targetInst;
    } <span class="hljs-comment">// If the direct event target isn&#x27;t a React owned DOM node, we need to look</span></pre></div></div>
            
        </li>
        
        
        <li id="section-443">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-443">&#x00a7;</a>
              </div>
              <p>to see if one of its parents is a React owned DOM node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> parentNode = targetNode.<span class="hljs-property">parentNode</span>;

    <span class="hljs-keyword">while</span> (parentNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-444">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-444">&#x00a7;</a>
              </div>
              <p>We’ll check if this is a container root that could include
React nodes in the future. We need to check this first because
if we’re a child of a dehydrated container, we need to first
find that inner container before moving on to finding the parent
instance. Note that we don’t check this field on  the targetNode
itself because the fibers are conceptually between the container
node and the first child. It isn’t surrounding the container node.
If it’s not a container, we check if it’s an instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];

      <span class="hljs-keyword">if</span> (targetInst) {</pre></div></div>
            
        </li>
        
        
        <li id="section-445">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-445">&#x00a7;</a>
              </div>
              <p>Since this wasn’t the direct target of the event, we might have
stepped past dehydrated DOM nodes to get here. However they could
also have been non-React nodes. We need to answer which one.
If we the instance doesn’t have any children, then there can’t be
a nested suspense boundary within it. So we can use this as a fast
bailout. Most of the time, when people add non-React children to
the tree, it is using a ref to a child-less DOM node.
Normally we’d only need to check one of the fibers because if it
has ever gone from having children to deleting them or vice versa
it would have deleted the dehydrated boundary nested inside already.
However, since the HostRoot starts out with an alternate it might
have one on the alternate so we need to check in case this was a
root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> alternate = targetInst.<span class="hljs-property">alternate</span>;

        <span class="hljs-keyword">if</span> (targetInst.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span> || alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-446">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-446">&#x00a7;</a>
              </div>
              <p>Next we need to figure out if the node that skipped past is
nested within a dehydrated boundary and if so, which one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> suspenseInstance = <span class="hljs-title function_">getParentSuspenseInstance</span>(targetNode);

          <span class="hljs-keyword">while</span> (suspenseInstance !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-447">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-447">&#x00a7;</a>
              </div>
              <p>We found a suspense instance. That means that we haven’t
hydrated it yet. Even though we leave the comments in the
DOM after hydrating, and there are boundaries in the DOM
that could already be hydrated, we wouldn’t have found them
through this pass since if the target is hydrated it would
have had an internalInstanceKey on it.
Let’s get the fiber associated with the SuspenseComponent
as the deepest instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> targetSuspenseInst = suspenseInstance[internalInstanceKey];

            <span class="hljs-keyword">if</span> (targetSuspenseInst) {
              <span class="hljs-keyword">return</span> targetSuspenseInst;
            } <span class="hljs-comment">// If we don&#x27;t find a Fiber on the comment, it might be because</span></pre></div></div>
            
        </li>
        
        
        <li id="section-448">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-448">&#x00a7;</a>
              </div>
              <p>we haven’t gotten to hydrate it yet. There might still be a
parent boundary that hasn’t above this one so we need to find
the outer most that is known.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

            suspenseInstance = <span class="hljs-title function_">getParentSuspenseInstance</span>(suspenseInstance); <span class="hljs-comment">// If we don&#x27;t find one, then that should mean that the parent</span></pre></div></div>
            
        </li>
        
        
        <li id="section-449">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-449">&#x00a7;</a>
              </div>
              <p>host component also hasn’t hydrated yet. We can return it
below since it will bail out on the isMounted check later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          }
        }

        <span class="hljs-keyword">return</span> targetInst;
      }

      targetNode = parentNode;
      parentNode = targetNode.<span class="hljs-property">parentNode</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">/**
   * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
   * instance, or null if the node was not rendered by this React.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getInstanceFromNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">var</span> inst = node[internalInstanceKey] || node[internalContainerInstanceKey];

    <span class="hljs-keyword">if</span> (inst) {
      <span class="hljs-keyword">if</span> (inst.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span> || inst.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span> || inst.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span> || inst.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>) {
        <span class="hljs-keyword">return</span> inst;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-comment">/**
   * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
   * DOM node.
   */</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNodeFromInstance</span>(<span class="hljs-params">inst</span>) {
    <span class="hljs-keyword">if</span> (inst.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span> || inst.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-450">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-450">&#x00a7;</a>
              </div>
              <p>In Fiber this, is just the state node right now. We assume it will be
a host component or host text.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> inst.<span class="hljs-property">stateNode</span>;
    } <span class="hljs-comment">// Without this first invariant, passing a non-DOM-component triggers the next</span></pre></div></div>
            
        </li>
        
        
        <li id="section-451">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-451">&#x00a7;</a>
              </div>
              <p>invariant for a missing parent, which is super confusing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;getNodeFromInstance: Invalid argument.&quot;</span>);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getFiberCurrentPropsFromNode</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> node[internalPropsKey] || <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFiberProps</span>(<span class="hljs-params">node, props</span>) {
    node[internalPropsKey] = props;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getEventListenerSet</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">var</span> elementListenerSet = node[internalEventHandlersKey];

    <span class="hljs-keyword">if</span> (elementListenerSet === <span class="hljs-literal">undefined</span>) {
      elementListenerSet = node[internalEventHandlersKey] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    }

    <span class="hljs-keyword">return</span> elementListenerSet;
  }

  <span class="hljs-keyword">var</span> loggedTypeFailures = {};
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactDebugCurrentFrame</span>$<span class="hljs-number">1</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactDebugCurrentFrame</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setCurrentlyValidatingElement</span>(<span class="hljs-params">element</span>) {
    {
      <span class="hljs-keyword">if</span> (element) {
        <span class="hljs-keyword">var</span> owner = element.<span class="hljs-property">_owner</span>;
        <span class="hljs-keyword">var</span> stack = <span class="hljs-title function_">describeUnknownElementTypeFrameInDEV</span>(element.<span class="hljs-property">type</span>, element.<span class="hljs-property">_source</span>, owner ? owner.<span class="hljs-property">type</span> : <span class="hljs-literal">null</span>);
        <span class="hljs-title class_">ReactDebugCurrentFrame</span>$<span class="hljs-number">1.</span><span class="hljs-title function_">setExtraStackFrame</span>(stack);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title class_">ReactDebugCurrentFrame</span>$<span class="hljs-number">1.</span><span class="hljs-title function_">setExtraStackFrame</span>(<span class="hljs-literal">null</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkPropTypes</span>(<span class="hljs-params">typeSpecs, values, location, componentName, element</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-452">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-452">&#x00a7;</a>
              </div>
              <p>$FlowFixMe This is okay but Flow doesn’t know it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> has = <span class="hljs-title class_">Function</span>.<span class="hljs-property">call</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>);

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> typeSpecName <span class="hljs-keyword">in</span> typeSpecs) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">has</span>(typeSpecs, typeSpecName)) {
          <span class="hljs-keyword">var</span> error$<span class="hljs-number">1</span> = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Prop type validation may throw. In case they do, we don&#x27;t want to</span></pre></div></div>
            
        </li>
        
        
        <li id="section-453">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-453">&#x00a7;</a>
              </div>
              <p>fail the render phase where it didn’t fail before. So we log it.
After these have been cleaned up, we’ll let them throw.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-454">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-454">&#x00a7;</a>
              </div>
              <p>This is intentionally an invariant that gets caught. It’s the same
behavior as without this statement except with a better message.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> typeSpecs[typeSpecName] !== <span class="hljs-string">&#x27;function&#x27;</span>) {
              <span class="hljs-keyword">var</span> err = <span class="hljs-title class_">Error</span>((componentName || <span class="hljs-string">&#x27;React class&#x27;</span>) + <span class="hljs-string">&#x27;: &#x27;</span> + location + <span class="hljs-string">&#x27; type `&#x27;</span> + typeSpecName + <span class="hljs-string">&#x27;` is invalid; &#x27;</span> + <span class="hljs-string">&#x27;it must be a function, usually from the `prop-types` package, but received `&#x27;</span> + <span class="hljs-keyword">typeof</span> typeSpecs[typeSpecName] + <span class="hljs-string">&#x27;`.&#x27;</span> + <span class="hljs-string">&#x27;This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.&#x27;</span>);
              err.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Invariant Violation&#x27;</span>;
              <span class="hljs-keyword">throw</span> err;
            }

            error$<span class="hljs-number">1</span> = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED&#x27;</span>);
          } <span class="hljs-keyword">catch</span> (ex) {
            error$<span class="hljs-number">1</span> = ex;
          }

          <span class="hljs-keyword">if</span> (error$<span class="hljs-number">1</span> &amp;&amp; !(error$<span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>)) {
            <span class="hljs-title function_">setCurrentlyValidatingElement</span>(element);

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: type specification of %s&#x27;</span> + <span class="hljs-string">&#x27; `%s` is invalid; the type checker &#x27;</span> + <span class="hljs-string">&#x27;function must return `null` or an `Error` but returned a %s. &#x27;</span> + <span class="hljs-string">&#x27;You may have forgotten to pass an argument to the type checker &#x27;</span> + <span class="hljs-string">&#x27;creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and &#x27;</span> + <span class="hljs-string">&#x27;shape all require an argument).&#x27;</span>, componentName || <span class="hljs-string">&#x27;React class&#x27;</span>, location, typeSpecName, <span class="hljs-keyword">typeof</span> error$<span class="hljs-number">1</span>);

            <span class="hljs-title function_">setCurrentlyValidatingElement</span>(<span class="hljs-literal">null</span>);
          }

          <span class="hljs-keyword">if</span> (error$<span class="hljs-number">1</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span> &amp;&amp; !(error$<span class="hljs-number">1.</span>message <span class="hljs-keyword">in</span> loggedTypeFailures)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-455">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-455">&#x00a7;</a>
              </div>
              <p>Only monitor this failure once because there tends to be a lot of the
same error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            loggedTypeFailures[error$<span class="hljs-number">1.</span>message] = <span class="hljs-literal">true</span>;
            <span class="hljs-title function_">setCurrentlyValidatingElement</span>(element);

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Failed %s type: %s&#x27;</span>, location, error$<span class="hljs-number">1.</span>message);

            <span class="hljs-title function_">setCurrentlyValidatingElement</span>(<span class="hljs-literal">null</span>);
          }
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> valueStack = [];
  <span class="hljs-keyword">var</span> fiberStack;

  {
    fiberStack = [];
  }

  <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createCursor</span>(<span class="hljs-params">defaultValue</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">current</span>: defaultValue
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pop</span>(<span class="hljs-params">cursor, fiber</span>) {
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) {
      {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unexpected pop.&#x27;</span>);
      }

      <span class="hljs-keyword">return</span>;
    }

    {
      <span class="hljs-keyword">if</span> (fiber !== fiberStack[index]) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unexpected Fiber popped.&#x27;</span>);
      }
    }

    cursor.<span class="hljs-property">current</span> = valueStack[index];
    valueStack[index] = <span class="hljs-literal">null</span>;

    {
      fiberStack[index] = <span class="hljs-literal">null</span>;
    }

    index--;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">cursor, value, fiber</span>) {
    index++;
    valueStack[index] = cursor.<span class="hljs-property">current</span>;

    {
      fiberStack[index] = fiber;
    }

    cursor.<span class="hljs-property">current</span> = value;
  }

  <span class="hljs-keyword">var</span> warnedAboutMissingGetChildContext;

  {
    warnedAboutMissingGetChildContext = {};
  }

  <span class="hljs-keyword">var</span> emptyContextObject = {};

  {
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(emptyContextObject);
  } <span class="hljs-comment">// A cursor to the current merged context object on the stack.</span>


  <span class="hljs-keyword">var</span> contextStackCursor = <span class="hljs-title function_">createCursor</span>(emptyContextObject); <span class="hljs-comment">// A cursor to a boolean indicating whether the context has changed.</span>

  <span class="hljs-keyword">var</span> didPerformWorkStackCursor = <span class="hljs-title function_">createCursor</span>(<span class="hljs-literal">false</span>); <span class="hljs-comment">// Keep track of the previous context object that was on the stack.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-456">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-456">&#x00a7;</a>
              </div>
              <p>We use this to get access to the parent context after we have already
pushed the next context provider, and now need to merge their contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> previousContext = emptyContextObject;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUnmaskedContext</span>(<span class="hljs-params">workInProgress, Component, didPushOwnContextIfProvider</span>) {
    {
      <span class="hljs-keyword">if</span> (didPushOwnContextIfProvider &amp;&amp; <span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-457">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-457">&#x00a7;</a>
              </div>
              <p>If the fiber is a context provider itself, when we read its context
we may have already pushed its own child context on the stack. A context
provider should not “see” its own child context. Therefore we read the
previous (parent) context instead for a context provider.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> previousContext;
      }

      <span class="hljs-keyword">return</span> contextStackCursor.<span class="hljs-property">current</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cacheContext</span>(<span class="hljs-params">workInProgress, unmaskedContext, maskedContext</span>) {
    {
      <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;
      instance.<span class="hljs-property">__reactInternalMemoizedUnmaskedChildContext</span> = unmaskedContext;
      instance.<span class="hljs-property">__reactInternalMemoizedMaskedChildContext</span> = maskedContext;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMaskedContext</span>(<span class="hljs-params">workInProgress, unmaskedContext</span>) {
    {
      <span class="hljs-keyword">var</span> type = workInProgress.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">var</span> contextTypes = type.<span class="hljs-property">contextTypes</span>;

      <span class="hljs-keyword">if</span> (!contextTypes) {
        <span class="hljs-keyword">return</span> emptyContextObject;
      } <span class="hljs-comment">// Avoid recreating masked context unless unmasked context has changed.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-458">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-458">&#x00a7;</a>
              </div>
              <p>Failing to do this will result in unnecessary calls to componentWillReceiveProps.
This may trigger infinite loops if componentWillReceiveProps calls setState.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;

      <span class="hljs-keyword">if</span> (instance &amp;&amp; instance.<span class="hljs-property">__reactInternalMemoizedUnmaskedChildContext</span> === unmaskedContext) {
        <span class="hljs-keyword">return</span> instance.<span class="hljs-property">__reactInternalMemoizedMaskedChildContext</span>;
      }

      <span class="hljs-keyword">var</span> context = {};

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> contextTypes) {
        context[key] = unmaskedContext[key];
      }

      {
        <span class="hljs-keyword">var</span> name = <span class="hljs-title function_">getComponentName</span>(type) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;
        <span class="hljs-title function_">checkPropTypes</span>(contextTypes, context, <span class="hljs-string">&#x27;context&#x27;</span>, name);
      } <span class="hljs-comment">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-459">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-459">&#x00a7;</a>
              </div>
              <p>Context is created before the class component is instantiated so check for instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (instance) {
        <span class="hljs-title function_">cacheContext</span>(workInProgress, unmaskedContext, context);
      }

      <span class="hljs-keyword">return</span> context;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasContextChanged</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">return</span> didPerformWorkStackCursor.<span class="hljs-property">current</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isContextProvider</span>(<span class="hljs-params">type</span>) {
    {
      <span class="hljs-keyword">var</span> childContextTypes = type.<span class="hljs-property">childContextTypes</span>;
      <span class="hljs-keyword">return</span> childContextTypes !== <span class="hljs-literal">null</span> &amp;&amp; childContextTypes !== <span class="hljs-literal">undefined</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popContext</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-title function_">pop</span>(didPerformWorkStackCursor, fiber);
      <span class="hljs-title function_">pop</span>(contextStackCursor, fiber);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popTopLevelContextObject</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-title function_">pop</span>(didPerformWorkStackCursor, fiber);
      <span class="hljs-title function_">pop</span>(contextStackCursor, fiber);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushTopLevelContextObject</span>(<span class="hljs-params">fiber, context, didChange</span>) {
    {
      <span class="hljs-keyword">if</span> (!(contextStackCursor.<span class="hljs-property">current</span> === emptyContextObject)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }

      <span class="hljs-title function_">push</span>(contextStackCursor, context, fiber);
      <span class="hljs-title function_">push</span>(didPerformWorkStackCursor, didChange, fiber);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">processChildContext</span>(<span class="hljs-params">fiber, type, parentContext</span>) {
    {
      <span class="hljs-keyword">var</span> instance = fiber.<span class="hljs-property">stateNode</span>;
      <span class="hljs-keyword">var</span> childContextTypes = type.<span class="hljs-property">childContextTypes</span>; <span class="hljs-comment">// TODO (bvaughn) Replace this behavior with an invariant() in the future.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-460">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-460">&#x00a7;</a>
              </div>
              <p>It has only been added in Fiber to match the (unintentional) behavior in Stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getChildContext</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {
        {
          <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(type) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

          <span class="hljs-keyword">if</span> (!warnedAboutMissingGetChildContext[componentName]) {
            warnedAboutMissingGetChildContext[componentName] = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.childContextTypes is specified but there is no getChildContext() method &#x27;</span> + <span class="hljs-string">&#x27;on the instance. You can either define getChildContext() on %s or remove &#x27;</span> + <span class="hljs-string">&#x27;childContextTypes from it.&#x27;</span>, componentName, componentName);
          }
        }

        <span class="hljs-keyword">return</span> parentContext;
      }

      <span class="hljs-keyword">var</span> childContext = instance.<span class="hljs-title function_">getChildContext</span>();

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> contextKey <span class="hljs-keyword">in</span> childContext) {
        <span class="hljs-keyword">if</span> (!(contextKey <span class="hljs-keyword">in</span> childContextTypes)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>((<span class="hljs-title function_">getComponentName</span>(type) || <span class="hljs-string">&#x27;Unknown&#x27;</span>) + <span class="hljs-string">&quot;.getChildContext(): key \&quot;&quot;</span> + contextKey + <span class="hljs-string">&quot;\&quot; is not defined in childContextTypes.&quot;</span>);
          }
        }
      }

      {
        <span class="hljs-keyword">var</span> name = <span class="hljs-title function_">getComponentName</span>(type) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;
        <span class="hljs-title function_">checkPropTypes</span>(childContextTypes, childContext, <span class="hljs-string">&#x27;child context&#x27;</span>, name);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-title function_">_assign</span>({}, parentContext, childContext);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushContextProvider</span>(<span class="hljs-params">workInProgress</span>) {
    {
      <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// We push the context as early as possible to ensure stack integrity.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-461">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-461">&#x00a7;</a>
              </div>
              <p>If the instance does not exist yet, we will push null at first,
and replace it on the stack later when invalidating the context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> memoizedMergedChildContext = instance &amp;&amp; instance.<span class="hljs-property">__reactInternalMemoizedMergedChildContext</span> || emptyContextObject; <span class="hljs-comment">// Remember the parent context so we can merge with it later.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-462">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-462">&#x00a7;</a>
              </div>
              <p>Inherit the parent’s did-perform-work value to avoid inadvertently blocking updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      previousContext = contextStackCursor.<span class="hljs-property">current</span>;
      <span class="hljs-title function_">push</span>(contextStackCursor, memoizedMergedChildContext, workInProgress);
      <span class="hljs-title function_">push</span>(didPerformWorkStackCursor, didPerformWorkStackCursor.<span class="hljs-property">current</span>, workInProgress);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">invalidateContextProvider</span>(<span class="hljs-params">workInProgress, type, didChange</span>) {
    {
      <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;

      <span class="hljs-keyword">if</span> (!instance) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }

      <span class="hljs-keyword">if</span> (didChange) {</pre></div></div>
            
        </li>
        
        
        <li id="section-463">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-463">&#x00a7;</a>
              </div>
              <p>Merge parent and own context.
Skip this if we’re not updating due to sCU.
This avoids unnecessarily recomputing memoized values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> mergedContext = <span class="hljs-title function_">processChildContext</span>(workInProgress, type, previousContext);
        instance.<span class="hljs-property">__reactInternalMemoizedMergedChildContext</span> = mergedContext; <span class="hljs-comment">// Replace the old (or empty) context with the new one.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-464">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-464">&#x00a7;</a>
              </div>
              <p>It is important to unwind the context in the reverse order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">pop</span>(didPerformWorkStackCursor, workInProgress);
        <span class="hljs-title function_">pop</span>(contextStackCursor, workInProgress); <span class="hljs-comment">// Now push the new context and mark that it has changed.</span>

        <span class="hljs-title function_">push</span>(contextStackCursor, mergedContext, workInProgress);
        <span class="hljs-title function_">push</span>(didPerformWorkStackCursor, didChange, workInProgress);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">pop</span>(didPerformWorkStackCursor, workInProgress);
        <span class="hljs-title function_">push</span>(didPerformWorkStackCursor, didChange, workInProgress);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findCurrentUnmaskedContext</span>(<span class="hljs-params">fiber</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-465">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-465">&#x00a7;</a>
              </div>
              <p>Currently this is only used with renderSubtreeIntoContainer; not sure if it
makes sense elsewhere</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!(<span class="hljs-title function_">isFiberMounted</span>(fiber) &amp;&amp; fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }

      <span class="hljs-keyword">var</span> node = fiber;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">tag</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
            <span class="hljs-keyword">return</span> node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">context</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
            {
              <span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = node.<span class="hljs-property">type</span>;

              <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
                <span class="hljs-keyword">return</span> node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">__reactInternalMemoizedMergedChildContext</span>;
              }

              <span class="hljs-keyword">break</span>;
            }
        }

        node = node.<span class="hljs-property">return</span>;
      } <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>);

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LegacyRoot</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">BlockingRoot</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ConcurrentRoot</span> = <span class="hljs-number">2</span>;

  <span class="hljs-keyword">var</span> rendererID = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> injectedHook = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> hasLoggedError = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> isDevToolsPresent = <span class="hljs-keyword">typeof</span> __REACT_DEVTOOLS_GLOBAL_HOOK__ !== <span class="hljs-string">&#x27;undefined&#x27;</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectInternals</span>(<span class="hljs-params">internals</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> __REACT_DEVTOOLS_GLOBAL_HOOK__ === <span class="hljs-string">&#x27;undefined&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-466">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-466">&#x00a7;</a>
              </div>
              <p>No DevTools</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

    <span class="hljs-keyword">if</span> (hook.<span class="hljs-property">isDisabled</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-467">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-467">&#x00a7;</a>
              </div>
              <p>This isn’t a real property on the hook, but it can be set to opt out
of DevTools integration and associated warnings and logs.
<a href="https://github.com/facebook/react/issues/3877">https://github.com/facebook/react/issues/3877</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">if</span> (!hook.<span class="hljs-property">supportsFiber</span>) {
      {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The installed version of React DevTools is too old and will not work &#x27;</span> + <span class="hljs-string">&#x27;with the current version of React. Please update React DevTools. &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/react-devtools&#x27;</span>);
      } <span class="hljs-comment">// DevTools exists, even though it doesn&#x27;t support Fiber.</span>


      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">try</span> {
      rendererID = hook.<span class="hljs-title function_">inject</span>(internals); <span class="hljs-comment">// We have successfully injected, so now it is safe to set up hooks.</span>

      injectedHook = hook;
    } <span class="hljs-keyword">catch</span> (err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-468">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-468">&#x00a7;</a>
              </div>
              <p>Catch all errors because it is unsafe to throw during initialization.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React instrumentation encountered an error: %s.&#x27;</span>, err);
      }
    } <span class="hljs-comment">// DevTools exists</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onScheduleRoot</span>(<span class="hljs-params">root, children</span>) {
    {
      <span class="hljs-keyword">if</span> (injectedHook &amp;&amp; <span class="hljs-keyword">typeof</span> injectedHook.<span class="hljs-property">onScheduleFiberRoot</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">try</span> {
          injectedHook.<span class="hljs-title function_">onScheduleFiberRoot</span>(rendererID, root, children);
        } <span class="hljs-keyword">catch</span> (err) {
          <span class="hljs-keyword">if</span> (!hasLoggedError) {
            hasLoggedError = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React instrumentation encountered an error: %s&#x27;</span>, err);
          }
        }
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onCommitRoot</span>(<span class="hljs-params">root, priorityLevel</span>) {
    <span class="hljs-keyword">if</span> (injectedHook &amp;&amp; <span class="hljs-keyword">typeof</span> injectedHook.<span class="hljs-property">onCommitFiberRoot</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> didError = (root.<span class="hljs-property">current</span>.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">DidCapture</span>;

        <span class="hljs-keyword">if</span> (enableProfilerTimer) {
          injectedHook.<span class="hljs-title function_">onCommitFiberRoot</span>(rendererID, root, priorityLevel, didError);
        } <span class="hljs-keyword">else</span> {
          injectedHook.<span class="hljs-title function_">onCommitFiberRoot</span>(rendererID, root, <span class="hljs-literal">undefined</span>, didError);
        }
      } <span class="hljs-keyword">catch</span> (err) {
        {
          <span class="hljs-keyword">if</span> (!hasLoggedError) {
            hasLoggedError = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React instrumentation encountered an error: %s&#x27;</span>, err);
          }
        }
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onCommitUnmount</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">if</span> (injectedHook &amp;&amp; <span class="hljs-keyword">typeof</span> injectedHook.<span class="hljs-property">onCommitFiberUnmount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">try</span> {
        injectedHook.<span class="hljs-title function_">onCommitFiberUnmount</span>(rendererID, fiber);
      } <span class="hljs-keyword">catch</span> (err) {
        {
          <span class="hljs-keyword">if</span> (!hasLoggedError) {
            hasLoggedError = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React instrumentation encountered an error: %s&#x27;</span>, err);
          }
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Scheduler</span>_runWithPriority = unstable_runWithPriority,
    <span class="hljs-title class_">Scheduler</span>_scheduleCallback = unstable_scheduleCallback,
    <span class="hljs-title class_">Scheduler</span>_cancelCallback = unstable_cancelCallback,
    <span class="hljs-title class_">Scheduler</span>_shouldYield = unstable_shouldYield,
    <span class="hljs-title class_">Scheduler</span>_requestPaint = unstable_requestPaint,
    <span class="hljs-title class_">Scheduler</span>_now$<span class="hljs-number">1</span> = unstable_now,
    <span class="hljs-title class_">Scheduler</span>_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel,
    <span class="hljs-title class_">Scheduler</span>_ImmediatePriority = unstable_ImmediatePriority,
    <span class="hljs-title class_">Scheduler</span>_UserBlockingPriority = unstable_UserBlockingPriority,
    <span class="hljs-title class_">Scheduler</span>_NormalPriority = unstable_NormalPriority,
    <span class="hljs-title class_">Scheduler</span>_LowPriority = unstable_LowPriority,
    <span class="hljs-title class_">Scheduler</span>_IdlePriority = unstable_IdlePriority;

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-469">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-469">&#x00a7;</a>
              </div>
              <p>Provide explicit error message when production+profiling bundle of e.g.
react-dom is used with production (non-profiling) bundle of
scheduler/tracing</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!(__interactionsRef != <span class="hljs-literal">null</span> &amp;&amp; __interactionsRef.<span class="hljs-property">current</span> != <span class="hljs-literal">null</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">var</span> fakeCallbackNode = {}; <span class="hljs-comment">// Except for NoPriority, these correspond to Scheduler priorities. We use</span></pre></div></div>
            
        </li>
        
        
        <li id="section-470">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-470">&#x00a7;</a>
              </div>
              <p>ascending numbers so we can compare them like numbers. They start at 90 to
avoid clashing with Scheduler’s priorities.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span> = <span class="hljs-number">99</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">2</span> = <span class="hljs-number">98</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span> = <span class="hljs-number">97</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LowPriority</span>$<span class="hljs-number">1</span> = <span class="hljs-number">96</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IdlePriority</span>$<span class="hljs-number">1</span> = <span class="hljs-number">95</span>; <span class="hljs-comment">// NoPriority is the absence of priority. Also React-only.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoPriority</span>$<span class="hljs-number">1</span> = <span class="hljs-number">90</span>;
  <span class="hljs-keyword">var</span> shouldYield = <span class="hljs-title class_">Scheduler</span>_shouldYield;
  <span class="hljs-keyword">var</span> requestPaint = <span class="hljs-comment">// Fall back gracefully if we&#x27;re running an older version of Scheduler.</span>
    <span class="hljs-title class_">Scheduler</span>_requestPaint !== <span class="hljs-literal">undefined</span> ? <span class="hljs-title class_">Scheduler</span>_requestPaint : <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { };
  <span class="hljs-keyword">var</span> syncQueue = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> immediateQueueCallbackNode = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> isFlushingSyncQueue = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> initialTimeMs$<span class="hljs-number">1</span> = <span class="hljs-title class_">Scheduler</span>_now<span class="hljs-title function_">$1</span>(); <span class="hljs-comment">// If the initial timestamp is reasonably small, use Scheduler&#x27;s `now` directly.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-471">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-471">&#x00a7;</a>
              </div>
              <p>This will be the case for modern browsers that support <code>performance.now</code>. In
older browsers, Scheduler falls back to <code>Date.now</code>, which returns a Unix
timestamp. In that case, subtract the module initialization time to simulate
the behavior of performance.now and keep our times small enough to fit
within 32 bits.
TODO: Consider lifting this into Scheduler.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> now = initialTimeMs$<span class="hljs-number">1</span> &lt; <span class="hljs-number">10000</span> ? <span class="hljs-title class_">Scheduler</span>_now$<span class="hljs-number">1</span> : <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_now<span class="hljs-title function_">$1</span>() - initialTimeMs$<span class="hljs-number">1</span>;
  };
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentPriorityLevel</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">switch</span> (<span class="hljs-title class_">Scheduler</span>_getCurrentPriorityLevel()) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_ImmediatePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_UserBlockingPriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">2</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_NormalPriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_LowPriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">LowPriority</span>$<span class="hljs-number">1</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Scheduler</span><span class="hljs-attr">_IdlePriority</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">IdlePriority</span>$<span class="hljs-number">1</span>;

      <span class="hljs-attr">default</span>:
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unknown priority level.&quot;</span>);
          }
        }

    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reactPriorityToSchedulerPriority</span>(<span class="hljs-params">reactPriorityLevel</span>) {
    <span class="hljs-keyword">switch</span> (reactPriorityLevel) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ImmediatePriority</span><span class="hljs-attr">$1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_ImmediatePriority;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">UserBlockingPriority</span><span class="hljs-attr">$2</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_UserBlockingPriority;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">NormalPriority</span><span class="hljs-attr">$1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_NormalPriority;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LowPriority</span><span class="hljs-attr">$1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_LowPriority;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IdlePriority</span><span class="hljs-attr">$1</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_IdlePriority;

      <span class="hljs-attr">default</span>:
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unknown priority level.&quot;</span>);
          }
        }

    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">runWithPriority$1</span>(<span class="hljs-params">reactPriorityLevel, fn</span>) {
    <span class="hljs-keyword">var</span> priorityLevel = <span class="hljs-title function_">reactPriorityToSchedulerPriority</span>(reactPriorityLevel);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_runWithPriority(priorityLevel, fn);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-params">reactPriorityLevel, callback, options</span>) {
    <span class="hljs-keyword">var</span> priorityLevel = <span class="hljs-title function_">reactPriorityToSchedulerPriority</span>(reactPriorityLevel);
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Scheduler</span>_scheduleCallback(priorityLevel, callback, options);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleSyncCallback</span>(<span class="hljs-params">callback</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-472">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-472">&#x00a7;</a>
              </div>
              <p>Push this callback into an internal queue. We’ll flush these either in
the next tick, or earlier if something calls <code>flushSyncCallbackQueue</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (syncQueue === <span class="hljs-literal">null</span>) {
      syncQueue = [callback]; <span class="hljs-comment">// Flush the queue in the next tick, at the earliest.</span>

      immediateQueueCallbackNode = <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<span class="hljs-title class_">Scheduler</span>_ImmediatePriority, flushSyncCallbackQueueImpl);
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-473">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-473">&#x00a7;</a>
              </div>
              <p>Push onto existing queue. Don’t need to schedule a callback because
we already scheduled one when we created the queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      syncQueue.<span class="hljs-title function_">push</span>(callback);
    }

    <span class="hljs-keyword">return</span> fakeCallbackNode;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cancelCallback</span>(<span class="hljs-params">callbackNode</span>) {
    <span class="hljs-keyword">if</span> (callbackNode !== fakeCallbackNode) {
      <span class="hljs-title class_">Scheduler</span>_cancelCallback(callbackNode);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSyncCallbackQueue</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (immediateQueueCallbackNode !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> node = immediateQueueCallbackNode;
      immediateQueueCallbackNode = <span class="hljs-literal">null</span>;
      <span class="hljs-title class_">Scheduler</span>_cancelCallback(node);
    }

    <span class="hljs-title function_">flushSyncCallbackQueueImpl</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSyncCallbackQueueImpl</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!isFlushingSyncQueue &amp;&amp; syncQueue !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-474">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-474">&#x00a7;</a>
              </div>
              <p>Prevent re-entrancy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      isFlushingSyncQueue = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;

      {
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> _isSync2 = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">var</span> _queue = syncQueue;
          <span class="hljs-title function_">runWithPriority$1</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">for</span> (; i &lt; _queue.<span class="hljs-property">length</span>; i++) {
              <span class="hljs-keyword">var</span> callback = _queue[i];

              <span class="hljs-keyword">do</span> {
                callback = <span class="hljs-title function_">callback</span>(_isSync2);
              } <span class="hljs-keyword">while</span> (callback !== <span class="hljs-literal">null</span>);
            }
          });
          syncQueue = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>
            
        </li>
        
        
        <li id="section-475">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-475">&#x00a7;</a>
              </div>
              <p>If something throws, leave the remaining callbacks on the queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (syncQueue !== <span class="hljs-literal">null</span>) {
            syncQueue = syncQueue.<span class="hljs-title function_">slice</span>(i + <span class="hljs-number">1</span>);
          } <span class="hljs-comment">// Resume flushing in the next tick</span>


          <span class="hljs-title class_">Scheduler</span>_scheduleCallback(<span class="hljs-title class_">Scheduler</span>_ImmediatePriority, flushSyncCallbackQueue);
          <span class="hljs-keyword">throw</span> error;
        } <span class="hljs-keyword">finally</span> {
          isFlushingSyncQueue = <span class="hljs-literal">false</span>;
        }
      }
    }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-476">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-476">&#x00a7;</a>
              </div>
              <p>TODO: this is special because it gets imported during build.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactVersion</span> = <span class="hljs-string">&#x27;17.0.0&#x27;</span>;

  <span class="hljs-comment">/**
   * If performance exists and supports the subset of the User Timing API that we
   * require.
   */</span>

  <span class="hljs-keyword">var</span> supportsUserTiming = <span class="hljs-keyword">typeof</span> performance !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> performance.<span class="hljs-property">mark</span> === <span class="hljs-string">&#x27;function&#x27;</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">formatLanes</span>(<span class="hljs-params">laneOrLanes</span>) {
    <span class="hljs-keyword">return</span> laneOrLanes.<span class="hljs-title function_">toString</span>();
  } <span class="hljs-comment">// Create a mark on React initialization</span>


  {
    <span class="hljs-keyword">if</span> (supportsUserTiming) {
      performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--react-init-&quot;</span> + <span class="hljs-title class_">ReactVersion</span>);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markCommitStarted</span>(<span class="hljs-params">lanes</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--commit-start-&quot;</span> + <span class="hljs-title function_">formatLanes</span>(lanes));
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markCommitStopped</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&#x27;--commit-stop&#x27;</span>);
      }
    }
  }
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">PossiblyWeakMap</span>$<span class="hljs-number">1</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WeakMap</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title class_">WeakMap</span> : <span class="hljs-title class_">Map</span>; <span class="hljs-comment">// $FlowFixMe: Flow cannot handle polymorphic WeakMaps</span>

  <span class="hljs-keyword">var</span> wakeableIDs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PossiblyWeakMap</span><span class="hljs-title function_">$1</span>();
  <span class="hljs-keyword">var</span> wakeableID = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getWakeableID</span>(<span class="hljs-params">wakeable</span>) {
    <span class="hljs-keyword">if</span> (!wakeableIDs.<span class="hljs-title function_">has</span>(wakeable)) {
      wakeableIDs.<span class="hljs-title function_">set</span>(wakeable, wakeableID++);
    }

    <span class="hljs-keyword">return</span> wakeableIDs.<span class="hljs-title function_">get</span>(wakeable);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markComponentSuspended</span>(<span class="hljs-params">fiber, wakeable</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        <span class="hljs-keyword">var</span> id = <span class="hljs-title function_">getWakeableID</span>(wakeable);
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>; <span class="hljs-comment">// TODO Add component stack id</span>

        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--suspense-suspend-&quot;</span> + id + <span class="hljs-string">&quot;-&quot;</span> + componentName);
        wakeable.<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">return</span> performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--suspense-resolved-&quot;</span> + id + <span class="hljs-string">&quot;-&quot;</span> + componentName);
        }, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">return</span> performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--suspense-rejected-&quot;</span> + id + <span class="hljs-string">&quot;-&quot;</span> + componentName);
        });
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markLayoutEffectsStarted</span>(<span class="hljs-params">lanes</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--layout-effects-start-&quot;</span> + <span class="hljs-title function_">formatLanes</span>(lanes));
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markLayoutEffectsStopped</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&#x27;--layout-effects-stop&#x27;</span>);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markPassiveEffectsStarted</span>(<span class="hljs-params">lanes</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--passive-effects-start-&quot;</span> + <span class="hljs-title function_">formatLanes</span>(lanes));
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markPassiveEffectsStopped</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&#x27;--passive-effects-stop&#x27;</span>);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRenderStarted</span>(<span class="hljs-params">lanes</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--render-start-&quot;</span> + <span class="hljs-title function_">formatLanes</span>(lanes));
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRenderYielded</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&#x27;--render-yield&#x27;</span>);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRenderStopped</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&#x27;--render-stop&#x27;</span>);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRenderScheduled</span>(<span class="hljs-params">lane</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--schedule-render-&quot;</span> + <span class="hljs-title function_">formatLanes</span>(lane));
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markForceUpdateScheduled</span>(<span class="hljs-params">fiber, lane</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>; <span class="hljs-comment">// TODO Add component stack id</span>

        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--schedule-forced-update-&quot;</span> + <span class="hljs-title function_">formatLanes</span>(lane) + <span class="hljs-string">&quot;-&quot;</span> + componentName);
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markStateUpdateScheduled</span>(<span class="hljs-params">fiber, lane</span>) {
    {
      <span class="hljs-keyword">if</span> (supportsUserTiming) {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>; <span class="hljs-comment">// TODO Add component stack id</span>

        performance.<span class="hljs-title function_">mark</span>(<span class="hljs-string">&quot;--schedule-state-update-&quot;</span> + <span class="hljs-title function_">formatLanes</span>(lane) + <span class="hljs-string">&quot;-&quot;</span> + componentName);
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoMode</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">StrictMode</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove BlockingMode and ConcurrentMode by reading from the root</span></pre></div></div>
            
        </li>
        
        
        <li id="section-477">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-477">&#x00a7;</a>
              </div>
              <p>tag instead</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">BlockingMode</span> = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ConcurrentMode</span> = <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ProfileMode</span> = <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DebugTracingMode</span> = <span class="hljs-number">16</span>;

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentBatchConfig</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentBatchConfig</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoTransition</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">requestCurrentTransition</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactCurrentBatchConfig</span>.<span class="hljs-property">transition</span>;
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactStrictModeWarnings</span> = {
    <span class="hljs-attr">recordUnsafeLifecycleWarnings</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) { },
    <span class="hljs-attr">flushPendingUnsafeLifecycleWarnings</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { },
    <span class="hljs-attr">recordLegacyContextWarning</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) { },
    <span class="hljs-attr">flushLegacyContextWarning</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { },
    <span class="hljs-attr">discardPendingWarnings</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { }
  };

  {
    <span class="hljs-keyword">var</span> findStrictRoot = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
      <span class="hljs-keyword">var</span> maybeStrictRoot = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> node = fiber;

      <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
          maybeStrictRoot = node;
        }

        node = node.<span class="hljs-property">return</span>;
      }

      <span class="hljs-keyword">return</span> maybeStrictRoot;
    };

    <span class="hljs-keyword">var</span> setToSortedString = <span class="hljs-keyword">function</span> (<span class="hljs-params">set</span>) {
      <span class="hljs-keyword">var</span> array = [];
      set.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        array.<span class="hljs-title function_">push</span>(value);
      });
      <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>);
    };

    <span class="hljs-keyword">var</span> pendingComponentWillMountWarnings = [];
    <span class="hljs-keyword">var</span> pendingUNSAFE_ComponentWillMountWarnings = [];
    <span class="hljs-keyword">var</span> pendingComponentWillReceivePropsWarnings = [];
    <span class="hljs-keyword">var</span> pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    <span class="hljs-keyword">var</span> pendingComponentWillUpdateWarnings = [];
    <span class="hljs-keyword">var</span> pendingUNSAFE_ComponentWillUpdateWarnings = []; <span class="hljs-comment">// Tracks components we have already warned about.</span>

    <span class="hljs-keyword">var</span> didWarnAboutUnsafeLifecycles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

    <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-property">recordUnsafeLifecycleWarnings</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-478">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-478">&#x00a7;</a>
              </div>
              <p>Dedup strategy: Warn once per component.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (didWarnAboutUnsafeLifecycles.<span class="hljs-title function_">has</span>(fiber.<span class="hljs-property">type</span>)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-comment">// Don&#x27;t warn about react-lifecycles-compat polyfilled components.</span>
        instance.<span class="hljs-property">componentWillMount</span>.<span class="hljs-property">__suppressDeprecationWarning</span> !== <span class="hljs-literal">true</span>) {
        pendingComponentWillMountWarnings.<span class="hljs-title function_">push</span>(fiber);
      }

      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        pendingUNSAFE_ComponentWillMountWarnings.<span class="hljs-title function_">push</span>(fiber);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; instance.<span class="hljs-property">componentWillReceiveProps</span>.<span class="hljs-property">__suppressDeprecationWarning</span> !== <span class="hljs-literal">true</span>) {
        pendingComponentWillReceivePropsWarnings.<span class="hljs-title function_">push</span>(fiber);
      }

      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        pendingUNSAFE_ComponentWillReceivePropsWarnings.<span class="hljs-title function_">push</span>(fiber);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; instance.<span class="hljs-property">componentWillUpdate</span>.<span class="hljs-property">__suppressDeprecationWarning</span> !== <span class="hljs-literal">true</span>) {
        pendingComponentWillUpdateWarnings.<span class="hljs-title function_">push</span>(fiber);
      }

      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        pendingUNSAFE_ComponentWillUpdateWarnings.<span class="hljs-title function_">push</span>(fiber);
      }
    };

    <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-property">flushPendingUnsafeLifecycleWarnings</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-479">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-479">&#x00a7;</a>
              </div>
              <p>We do an initial pass to gather component names</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> componentWillMountUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

      <span class="hljs-keyword">if</span> (pendingComponentWillMountWarnings.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        pendingComponentWillMountWarnings.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
          componentWillMountUniqueNames.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
          didWarnAboutUnsafeLifecycles.<span class="hljs-title function_">add</span>(fiber.<span class="hljs-property">type</span>);
        });
        pendingComponentWillMountWarnings = [];
      }

      <span class="hljs-keyword">var</span> UNSAFE_componentWillMountUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

      <span class="hljs-keyword">if</span> (pendingUNSAFE_ComponentWillMountWarnings.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        pendingUNSAFE_ComponentWillMountWarnings.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
          UNSAFE_componentWillMountUniqueNames.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
          didWarnAboutUnsafeLifecycles.<span class="hljs-title function_">add</span>(fiber.<span class="hljs-property">type</span>);
        });
        pendingUNSAFE_ComponentWillMountWarnings = [];
      }

      <span class="hljs-keyword">var</span> componentWillReceivePropsUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

      <span class="hljs-keyword">if</span> (pendingComponentWillReceivePropsWarnings.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        pendingComponentWillReceivePropsWarnings.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
          componentWillReceivePropsUniqueNames.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
          didWarnAboutUnsafeLifecycles.<span class="hljs-title function_">add</span>(fiber.<span class="hljs-property">type</span>);
        });
        pendingComponentWillReceivePropsWarnings = [];
      }

      <span class="hljs-keyword">var</span> UNSAFE_componentWillReceivePropsUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

      <span class="hljs-keyword">if</span> (pendingUNSAFE_ComponentWillReceivePropsWarnings.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        pendingUNSAFE_ComponentWillReceivePropsWarnings.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
          UNSAFE_componentWillReceivePropsUniqueNames.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
          didWarnAboutUnsafeLifecycles.<span class="hljs-title function_">add</span>(fiber.<span class="hljs-property">type</span>);
        });
        pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      }

      <span class="hljs-keyword">var</span> componentWillUpdateUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

      <span class="hljs-keyword">if</span> (pendingComponentWillUpdateWarnings.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        pendingComponentWillUpdateWarnings.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
          componentWillUpdateUniqueNames.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
          didWarnAboutUnsafeLifecycles.<span class="hljs-title function_">add</span>(fiber.<span class="hljs-property">type</span>);
        });
        pendingComponentWillUpdateWarnings = [];
      }

      <span class="hljs-keyword">var</span> UNSAFE_componentWillUpdateUniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

      <span class="hljs-keyword">if</span> (pendingUNSAFE_ComponentWillUpdateWarnings.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
        pendingUNSAFE_ComponentWillUpdateWarnings.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
          UNSAFE_componentWillUpdateUniqueNames.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
          didWarnAboutUnsafeLifecycles.<span class="hljs-title function_">add</span>(fiber.<span class="hljs-property">type</span>);
        });
        pendingUNSAFE_ComponentWillUpdateWarnings = [];
      } <span class="hljs-comment">// Finally, we flush all the warnings</span></pre></div></div>
            
        </li>
        
        
        <li id="section-480">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-480">&#x00a7;</a>
              </div>
              <p>UNSAFE_ ones before the deprecated ones, since they’ll be ‘louder’</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (UNSAFE_componentWillMountUniqueNames.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> sortedNames = <span class="hljs-title function_">setToSortedString</span>(UNSAFE_componentWillMountUniqueNames);

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. &#x27;</span> + <span class="hljs-string">&#x27;See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n&#x27;</span> + <span class="hljs-string">&#x27;* Move code with side effects to componentDidMount, and set initial state in the constructor.\n&#x27;</span> + <span class="hljs-string">&#x27;\nPlease update the following components: %s&#x27;</span>, sortedNames);
      }

      <span class="hljs-keyword">if</span> (UNSAFE_componentWillReceivePropsUniqueNames.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> _sortedNames = <span class="hljs-title function_">setToSortedString</span>(UNSAFE_componentWillReceivePropsUniqueNames);

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Using UNSAFE_componentWillReceiveProps in strict mode is not recommended &#x27;</span> + <span class="hljs-string">&#x27;and may indicate bugs in your code. &#x27;</span> + <span class="hljs-string">&#x27;See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n&#x27;</span> + <span class="hljs-string">&#x27;* Move data fetching code or side effects to componentDidUpdate.\n&#x27;</span> + <span class="hljs-string">&quot;* If you&#x27;re updating state whenever props change, &quot;</span> + <span class="hljs-string">&#x27;refactor your code to use memoization techniques or move it to &#x27;</span> + <span class="hljs-string">&#x27;static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n&#x27;</span> + <span class="hljs-string">&#x27;\nPlease update the following components: %s&#x27;</span>, _sortedNames);
      }

      <span class="hljs-keyword">if</span> (UNSAFE_componentWillUpdateUniqueNames.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> _sortedNames2 = <span class="hljs-title function_">setToSortedString</span>(UNSAFE_componentWillUpdateUniqueNames);

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Using UNSAFE_componentWillUpdate in strict mode is not recommended &#x27;</span> + <span class="hljs-string">&#x27;and may indicate bugs in your code. &#x27;</span> + <span class="hljs-string">&#x27;See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n&#x27;</span> + <span class="hljs-string">&#x27;* Move data fetching code or side effects to componentDidUpdate.\n&#x27;</span> + <span class="hljs-string">&#x27;\nPlease update the following components: %s&#x27;</span>, _sortedNames2);
      }

      <span class="hljs-keyword">if</span> (componentWillMountUniqueNames.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> _sortedNames3 = <span class="hljs-title function_">setToSortedString</span>(componentWillMountUniqueNames);

        <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;componentWillMount has been renamed, and is not recommended for use. &#x27;</span> + <span class="hljs-string">&#x27;See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n&#x27;</span> + <span class="hljs-string">&#x27;* Move code with side effects to componentDidMount, and set initial state in the constructor.\n&#x27;</span> + <span class="hljs-string">&#x27;* Rename componentWillMount to UNSAFE_componentWillMount to suppress &#x27;</span> + <span class="hljs-string">&#x27;this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. &#x27;</span> + <span class="hljs-string">&#x27;To rename all deprecated lifecycles to their new names, you can run &#x27;</span> + <span class="hljs-string">&#x27;`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n&#x27;</span> + <span class="hljs-string">&#x27;\nPlease update the following components: %s&#x27;</span>, _sortedNames3);
      }

      <span class="hljs-keyword">if</span> (componentWillReceivePropsUniqueNames.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> _sortedNames4 = <span class="hljs-title function_">setToSortedString</span>(componentWillReceivePropsUniqueNames);

        <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;componentWillReceiveProps has been renamed, and is not recommended for use. &#x27;</span> + <span class="hljs-string">&#x27;See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n&#x27;</span> + <span class="hljs-string">&#x27;* Move data fetching code or side effects to componentDidUpdate.\n&#x27;</span> + <span class="hljs-string">&quot;* If you&#x27;re updating state whenever props change, refactor your &quot;</span> + <span class="hljs-string">&#x27;code to use memoization techniques or move it to &#x27;</span> + <span class="hljs-string">&#x27;static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n&#x27;</span> + <span class="hljs-string">&#x27;* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress &#x27;</span> + <span class="hljs-string">&#x27;this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. &#x27;</span> + <span class="hljs-string">&#x27;To rename all deprecated lifecycles to their new names, you can run &#x27;</span> + <span class="hljs-string">&#x27;`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n&#x27;</span> + <span class="hljs-string">&#x27;\nPlease update the following components: %s&#x27;</span>, _sortedNames4);
      }

      <span class="hljs-keyword">if</span> (componentWillUpdateUniqueNames.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">var</span> _sortedNames5 = <span class="hljs-title function_">setToSortedString</span>(componentWillUpdateUniqueNames);

        <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;componentWillUpdate has been renamed, and is not recommended for use. &#x27;</span> + <span class="hljs-string">&#x27;See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n&#x27;</span> + <span class="hljs-string">&#x27;* Move data fetching code or side effects to componentDidUpdate.\n&#x27;</span> + <span class="hljs-string">&#x27;* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress &#x27;</span> + <span class="hljs-string">&#x27;this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. &#x27;</span> + <span class="hljs-string">&#x27;To rename all deprecated lifecycles to their new names, you can run &#x27;</span> + <span class="hljs-string">&#x27;`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n&#x27;</span> + <span class="hljs-string">&#x27;\nPlease update the following components: %s&#x27;</span>, _sortedNames5);
      }
    };

    <span class="hljs-keyword">var</span> pendingLegacyContextWarning = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// Tracks components we have already warned about.</span>

    <span class="hljs-keyword">var</span> didWarnAboutLegacyContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

    <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-property">recordLegacyContextWarning</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, instance</span>) {
      <span class="hljs-keyword">var</span> strictRoot = <span class="hljs-title function_">findStrictRoot</span>(fiber);

      <span class="hljs-keyword">if</span> (strictRoot === <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected to find a StrictMode component in a strict mode tree. &#x27;</span> + <span class="hljs-string">&#x27;This error is likely caused by a bug in React. Please file an issue.&#x27;</span>);

        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// Dedup strategy: Warn once per component.</span>


      <span class="hljs-keyword">if</span> (didWarnAboutLegacyContext.<span class="hljs-title function_">has</span>(fiber.<span class="hljs-property">type</span>)) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> warningsForRoot = pendingLegacyContextWarning.<span class="hljs-title function_">get</span>(strictRoot);

      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">type</span>.<span class="hljs-property">contextTypes</span> != <span class="hljs-literal">null</span> || fiber.<span class="hljs-property">type</span>.<span class="hljs-property">childContextTypes</span> != <span class="hljs-literal">null</span> || instance !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getChildContext</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">if</span> (warningsForRoot === <span class="hljs-literal">undefined</span>) {
          warningsForRoot = [];
          pendingLegacyContextWarning.<span class="hljs-title function_">set</span>(strictRoot, warningsForRoot);
        }

        warningsForRoot.<span class="hljs-title function_">push</span>(fiber);
      }
    };

    <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-property">flushLegacyContextWarning</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      pendingLegacyContextWarning.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiberArray, strictRoot</span>) {
        <span class="hljs-keyword">if</span> (fiberArray.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">var</span> firstFiber = fiberArray[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">var</span> uniqueNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
        fiberArray.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
          uniqueNames.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
          didWarnAboutLegacyContext.<span class="hljs-title function_">add</span>(fiber.<span class="hljs-property">type</span>);
        });
        <span class="hljs-keyword">var</span> sortedNames = <span class="hljs-title function_">setToSortedString</span>(uniqueNames);

        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">setCurrentFiber</span>(firstFiber);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Legacy context API has been detected within a strict-mode tree.&#x27;</span> + <span class="hljs-string">&#x27;\n\nThe old API will be supported in all 16.x releases, but applications &#x27;</span> + <span class="hljs-string">&#x27;using it should migrate to the new version.&#x27;</span> + <span class="hljs-string">&#x27;\n\nPlease update the following components: %s&#x27;</span> + <span class="hljs-string">&#x27;\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context&#x27;</span>, sortedNames);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title function_">resetCurrentFiber</span>();
        }
      });
    };

    <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-property">discardPendingWarnings</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      pendingComponentWillMountWarnings = [];
      pendingUNSAFE_ComponentWillMountWarnings = [];
      pendingComponentWillReceivePropsWarnings = [];
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
      pendingComponentWillUpdateWarnings = [];
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
      pendingLegacyContextWarning = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-params">Component, baseProps</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Component</span> &amp;&amp; <span class="hljs-title class_">Component</span>.<span class="hljs-property">defaultProps</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-481">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-481">&#x00a7;</a>
              </div>
              <p>Resolve default props. Taken from ReactElement</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> props = <span class="hljs-title function_">_assign</span>({}, baseProps);

      <span class="hljs-keyword">var</span> defaultProps = <span class="hljs-title class_">Component</span>.<span class="hljs-property">defaultProps</span>;

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> propName <span class="hljs-keyword">in</span> defaultProps) {
        <span class="hljs-keyword">if</span> (props[propName] === <span class="hljs-literal">undefined</span>) {
          props[propName] = defaultProps[propName];
        }
      }

      <span class="hljs-keyword">return</span> props;
    }

    <span class="hljs-keyword">return</span> baseProps;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-482">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-482">&#x00a7;</a>
              </div>
              <p>Max 31 bit integer. The max integer size in V8 for 32-bit systems.
Math.pow(2, 30) - 1
0b111111111111111111111111111111</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">MAX_SIGNED_31_BIT_INT</span> = <span class="hljs-number">1073741823</span>;

  <span class="hljs-keyword">var</span> valueCursor = <span class="hljs-title function_">createCursor</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">var</span> rendererSigil;

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-483">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-483">&#x00a7;</a>
              </div>
              <p>Use this to detect multiple renderers using the same context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rendererSigil = {};
  }

  <span class="hljs-keyword">var</span> currentlyRenderingFiber = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> lastContextDependency = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> lastContextWithAllBitsObserved = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> isDisallowedContextReadInDEV = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetContextDependencies</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-484">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-484">&#x00a7;</a>
              </div>
              <p>This is called right before React yields execution, to ensure <code>readContext</code>
cannot be called outside the render phase.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    currentlyRenderingFiber = <span class="hljs-literal">null</span>;
    lastContextDependency = <span class="hljs-literal">null</span>;
    lastContextWithAllBitsObserved = <span class="hljs-literal">null</span>;

    {
      isDisallowedContextReadInDEV = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enterDisallowedContextReadInDEV</span>(<span class="hljs-params"></span>) {
    {
      isDisallowedContextReadInDEV = <span class="hljs-literal">true</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">exitDisallowedContextReadInDEV</span>(<span class="hljs-params"></span>) {
    {
      isDisallowedContextReadInDEV = <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushProvider</span>(<span class="hljs-params">providerFiber, nextValue</span>) {
    <span class="hljs-keyword">var</span> context = providerFiber.<span class="hljs-property">type</span>.<span class="hljs-property">_context</span>;

    {
      <span class="hljs-title function_">push</span>(valueCursor, context.<span class="hljs-property">_currentValue</span>, providerFiber);
      context.<span class="hljs-property">_currentValue</span> = nextValue;

      {
        <span class="hljs-keyword">if</span> (context.<span class="hljs-property">_currentRenderer</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; context.<span class="hljs-property">_currentRenderer</span> !== <span class="hljs-literal">null</span> &amp;&amp; context.<span class="hljs-property">_currentRenderer</span> !== rendererSigil) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Detected multiple renderers concurrently rendering the &#x27;</span> + <span class="hljs-string">&#x27;same context provider. This is currently unsupported.&#x27;</span>);
        }

        context.<span class="hljs-property">_currentRenderer</span> = rendererSigil;
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popProvider</span>(<span class="hljs-params">providerFiber</span>) {
    <span class="hljs-keyword">var</span> currentValue = valueCursor.<span class="hljs-property">current</span>;
    <span class="hljs-title function_">pop</span>(valueCursor, providerFiber);
    <span class="hljs-keyword">var</span> context = providerFiber.<span class="hljs-property">type</span>.<span class="hljs-property">_context</span>;

    {
      context.<span class="hljs-property">_currentValue</span> = currentValue;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">calculateChangedBits</span>(<span class="hljs-params">context, newValue, oldValue</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">objectIs</span>(oldValue, newValue)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-485">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-485">&#x00a7;</a>
              </div>
              <p>No change</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> changedBits = <span class="hljs-keyword">typeof</span> context.<span class="hljs-property">_calculateChangedBits</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? context.<span class="hljs-title function_">_calculateChangedBits</span>(oldValue, newValue) : <span class="hljs-variable constant_">MAX_SIGNED_31_BIT_INT</span>;

      {
        <span class="hljs-keyword">if</span> ((changedBits &amp; <span class="hljs-variable constant_">MAX_SIGNED_31_BIT_INT</span>) !== changedBits) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;calculateChangedBits: Expected the return value to be a &#x27;</span> + <span class="hljs-string">&#x27;31-bit integer. Instead received: %s&#x27;</span>, changedBits);
        }
      }

      <span class="hljs-keyword">return</span> changedBits | <span class="hljs-number">0</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleWorkOnParentPath</span>(<span class="hljs-params">parent, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-486">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-486">&#x00a7;</a>
              </div>
              <p>Update the child lanes of all the ancestors, including the alternates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> node = parent;

    <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> alternate = node.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSubsetOfLanes</span>(node.<span class="hljs-property">childLanes</span>, renderLanes)) {
        node.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">mergeLanes</span>(node.<span class="hljs-property">childLanes</span>, renderLanes);

        <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
          alternate.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">mergeLanes</span>(alternate.<span class="hljs-property">childLanes</span>, renderLanes);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">isSubsetOfLanes</span>(alternate.<span class="hljs-property">childLanes</span>, renderLanes)) {
        alternate.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">mergeLanes</span>(alternate.<span class="hljs-property">childLanes</span>, renderLanes);
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-487">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-487">&#x00a7;</a>
              </div>
              <p>Neither alternate was updated, which means the rest of the
ancestor path already has sufficient priority.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">break</span>;
      }

      node = node.<span class="hljs-property">return</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">propagateContextChange</span>(<span class="hljs-params">workInProgress, context, changedBits, renderLanes</span>) {
    <span class="hljs-keyword">var</span> fiber = workInProgress.<span class="hljs-property">child</span>;

    <span class="hljs-keyword">if</span> (fiber !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-488">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-488">&#x00a7;</a>
              </div>
              <p>Set the return pointer of the child to the work-in-progress fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      fiber.<span class="hljs-property">return</span> = workInProgress;
    }

    <span class="hljs-keyword">while</span> (fiber !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> nextFiber = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// Visit this fiber.</span>

      <span class="hljs-keyword">var</span> list = fiber.<span class="hljs-property">dependencies</span>;

      <span class="hljs-keyword">if</span> (list !== <span class="hljs-literal">null</span>) {
        nextFiber = fiber.<span class="hljs-property">child</span>;
        <span class="hljs-keyword">var</span> dependency = list.<span class="hljs-property">firstContext</span>;

        <span class="hljs-keyword">while</span> (dependency !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-489">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-489">&#x00a7;</a>
              </div>
              <p>Check if the context matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (dependency.<span class="hljs-property">context</span> === context &amp;&amp; (dependency.<span class="hljs-property">observedBits</span> &amp; changedBits) !== <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-490">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-490">&#x00a7;</a>
              </div>
              <p>Match! Schedule an update on this fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-491">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-491">&#x00a7;</a>
              </div>
              <p>Schedule a force update on the work-in-progress.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(<span class="hljs-title class_">NoTimestamp</span>, <span class="hljs-title function_">pickArbitraryLane</span>(renderLanes));
              update.<span class="hljs-property">tag</span> = <span class="hljs-title class_">ForceUpdate</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Because we don&#x27;t have a work-in-progress, this will add the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-492">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-492">&#x00a7;</a>
              </div>
              <p>update to the current fiber, too, which means it will persist even if
this render is thrown away. Since it’s a race condition, not sure it’s
worth fixing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);
            }

            fiber.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(fiber.<span class="hljs-property">lanes</span>, renderLanes);
            <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>;

            <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
              alternate.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(alternate.<span class="hljs-property">lanes</span>, renderLanes);
            }

            <span class="hljs-title function_">scheduleWorkOnParentPath</span>(fiber.<span class="hljs-property">return</span>, renderLanes); <span class="hljs-comment">// Mark the updated lanes on the list, too.</span>

            list.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(list.<span class="hljs-property">lanes</span>, renderLanes); <span class="hljs-comment">// Since we already found a match, we can stop traversing the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-493">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-493">&#x00a7;</a>
              </div>
              <p>dependency list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">break</span>;
          }

          dependency = dependency.<span class="hljs-property">next</span>;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ContextProvider</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-494">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-494">&#x00a7;</a>
              </div>
              <p>Don’t scan deeper if this is a matching provider</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        nextFiber = fiber.<span class="hljs-property">type</span> === workInProgress.<span class="hljs-property">type</span> ? <span class="hljs-literal">null</span> : fiber.<span class="hljs-property">child</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">DehydratedFragment</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-495">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-495">&#x00a7;</a>
              </div>
              <p>If a dehydrated suspense boundary is in this subtree, we don’t know
if it will have any context consumers in it. The best we can do is
mark it as having updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> parentSuspense = fiber.<span class="hljs-property">return</span>;

        <span class="hljs-keyword">if</span> (!(parentSuspense !== <span class="hljs-literal">null</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;We just came from a parent so we must have had a parent. This is a bug in React.&quot;</span>);
          }
        }

        parentSuspense.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(parentSuspense.<span class="hljs-property">lanes</span>, renderLanes);
        <span class="hljs-keyword">var</span> _alternate = parentSuspense.<span class="hljs-property">alternate</span>;

        <span class="hljs-keyword">if</span> (_alternate !== <span class="hljs-literal">null</span>) {
          _alternate.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(_alternate.<span class="hljs-property">lanes</span>, renderLanes);
        } <span class="hljs-comment">// This is intentionally passing this fiber as the parent</span></pre></div></div>
            
        </li>
        
        
        <li id="section-496">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-496">&#x00a7;</a>
              </div>
              <p>because we want to schedule this fiber as having work
on its children. We’ll use the childLanes on
this fiber to indicate that a context has changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-title function_">scheduleWorkOnParentPath</span>(parentSuspense, renderLanes);
        nextFiber = fiber.<span class="hljs-property">sibling</span>;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-497">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-497">&#x00a7;</a>
              </div>
              <p>Traverse down.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        nextFiber = fiber.<span class="hljs-property">child</span>;
      }

      <span class="hljs-keyword">if</span> (nextFiber !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-498">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-498">&#x00a7;</a>
              </div>
              <p>Set the return pointer of the child to the work-in-progress fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        nextFiber.<span class="hljs-property">return</span> = fiber;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-499">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-499">&#x00a7;</a>
              </div>
              <p>No child. Traverse to next sibling.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        nextFiber = fiber;

        <span class="hljs-keyword">while</span> (nextFiber !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (nextFiber === workInProgress) {</pre></div></div>
            
        </li>
        
        
        <li id="section-500">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-500">&#x00a7;</a>
              </div>
              <p>We’re back to the root of this subtree. Exit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            nextFiber = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">var</span> sibling = nextFiber.<span class="hljs-property">sibling</span>;

          <span class="hljs-keyword">if</span> (sibling !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-501">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-501">&#x00a7;</a>
              </div>
              <p>Set the return pointer of the sibling to the work-in-progress fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            sibling.<span class="hljs-property">return</span> = nextFiber.<span class="hljs-property">return</span>;
            nextFiber = sibling;
            <span class="hljs-keyword">break</span>;
          } <span class="hljs-comment">// No more siblings. Traverse up.</span>


          nextFiber = nextFiber.<span class="hljs-property">return</span>;
        }
      }

      fiber = nextFiber;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareToReadContext</span>(<span class="hljs-params">workInProgress, renderLanes</span>) {
    currentlyRenderingFiber = workInProgress;
    lastContextDependency = <span class="hljs-literal">null</span>;
    lastContextWithAllBitsObserved = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> dependencies = workInProgress.<span class="hljs-property">dependencies</span>;

    <span class="hljs-keyword">if</span> (dependencies !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> firstContext = dependencies.<span class="hljs-property">firstContext</span>;

      <span class="hljs-keyword">if</span> (firstContext !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesSomeLane</span>(dependencies.<span class="hljs-property">lanes</span>, renderLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-502">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-502">&#x00a7;</a>
              </div>
              <p>Context list has a pending update. Mark that this fiber performed work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">markWorkInProgressReceivedUpdate</span>();
        } <span class="hljs-comment">// Reset the work-in-progress list</span>


        dependencies.<span class="hljs-property">firstContext</span> = <span class="hljs-literal">null</span>;
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">readContext</span>(<span class="hljs-params">context, observedBits</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-503">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-503">&#x00a7;</a>
              </div>
              <p>This warning would fire if you read context inside a Hook like useMemo.
Unlike the class check below, it’s not enforced in production for perf.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (isDisallowedContextReadInDEV) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Context can only be read while React is rendering. &#x27;</span> + <span class="hljs-string">&#x27;In classes, you can read it in the render method or getDerivedStateFromProps. &#x27;</span> + <span class="hljs-string">&#x27;In function components, you can read it directly in the function body, but not &#x27;</span> + <span class="hljs-string">&#x27;inside Hooks like useReducer() or useMemo().&#x27;</span>);
      }
    }

    <span class="hljs-keyword">if</span> (lastContextWithAllBitsObserved === context); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (observedBits === <span class="hljs-literal">false</span> || observedBits === <span class="hljs-number">0</span>); <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> resolvedObservedBits; <span class="hljs-comment">// Avoid deopting on observable arguments or heterogeneous types.</span>

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> observedBits !== <span class="hljs-string">&#x27;number&#x27;</span> || observedBits === <span class="hljs-variable constant_">MAX_SIGNED_31_BIT_INT</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-504">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-504">&#x00a7;</a>
              </div>
              <p>Observe all updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        lastContextWithAllBitsObserved = context;
        resolvedObservedBits = <span class="hljs-variable constant_">MAX_SIGNED_31_BIT_INT</span>;
      } <span class="hljs-keyword">else</span> {
        resolvedObservedBits = observedBits;
      }

      <span class="hljs-keyword">var</span> contextItem = {
        <span class="hljs-attr">context</span>: context,
        <span class="hljs-attr">observedBits</span>: resolvedObservedBits,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      };

      <span class="hljs-keyword">if</span> (lastContextDependency === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (!(currentlyRenderingFiber !== <span class="hljs-literal">null</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().&quot;</span>);
          }
        } <span class="hljs-comment">// This is the first dependency for this component. Create a new list.</span>


        lastContextDependency = contextItem;
        currentlyRenderingFiber.<span class="hljs-property">dependencies</span> = {
          <span class="hljs-attr">lanes</span>: <span class="hljs-title class_">NoLanes</span>,
          <span class="hljs-attr">firstContext</span>: contextItem,
          <span class="hljs-attr">responders</span>: <span class="hljs-literal">null</span>
        };
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-505">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-505">&#x00a7;</a>
              </div>
              <p>Append a new context item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        lastContextDependency = lastContextDependency.<span class="hljs-property">next</span> = contextItem;
      }
    }

    <span class="hljs-keyword">return</span> context.<span class="hljs-property">_currentValue</span>;
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">UpdateState</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReplaceState</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ForceUpdate</span> = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">CaptureUpdate</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// Global state that is reset at the beginning of calling `processUpdateQueue`.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-506">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-506">&#x00a7;</a>
              </div>
              <p>It should only be read right after calling <code>processUpdateQueue</code>, via
<code>checkHasForceUpdateAfterProcessing</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> hasForceUpdate = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> didWarnUpdateInsideUpdate;
  <span class="hljs-keyword">var</span> currentlyProcessingQueue;

  {
    didWarnUpdateInsideUpdate = <span class="hljs-literal">false</span>;
    currentlyProcessingQueue = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">initializeUpdateQueue</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> queue = {
      <span class="hljs-attr">baseState</span>: fiber.<span class="hljs-property">memoizedState</span>,
      <span class="hljs-attr">firstBaseUpdate</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">lastBaseUpdate</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">shared</span>: {
        <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>
      },
      <span class="hljs-attr">effects</span>: <span class="hljs-literal">null</span>
    };
    fiber.<span class="hljs-property">updateQueue</span> = queue;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneUpdateQueue</span>(<span class="hljs-params">current, workInProgress</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-507">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-507">&#x00a7;</a>
              </div>
              <p>Clone the update queue from current. Unless it’s already a clone.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> queue = workInProgress.<span class="hljs-property">updateQueue</span>;
    <span class="hljs-keyword">var</span> currentQueue = current.<span class="hljs-property">updateQueue</span>;

    <span class="hljs-keyword">if</span> (queue === currentQueue) {
      <span class="hljs-keyword">var</span> clone = {
        <span class="hljs-attr">baseState</span>: currentQueue.<span class="hljs-property">baseState</span>,
        <span class="hljs-attr">firstBaseUpdate</span>: currentQueue.<span class="hljs-property">firstBaseUpdate</span>,
        <span class="hljs-attr">lastBaseUpdate</span>: currentQueue.<span class="hljs-property">lastBaseUpdate</span>,
        <span class="hljs-attr">shared</span>: currentQueue.<span class="hljs-property">shared</span>,
        <span class="hljs-attr">effects</span>: currentQueue.<span class="hljs-property">effects</span>
      };
      workInProgress.<span class="hljs-property">updateQueue</span> = clone;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createUpdate</span>(<span class="hljs-params">eventTime, lane</span>) {
    <span class="hljs-keyword">var</span> update = {
      <span class="hljs-attr">eventTime</span>: eventTime,
      <span class="hljs-attr">lane</span>: lane,
      <span class="hljs-attr">tag</span>: <span class="hljs-title class_">UpdateState</span>,
      <span class="hljs-attr">payload</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">callback</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
    };
    <span class="hljs-keyword">return</span> update;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueueUpdate</span>(<span class="hljs-params">fiber, update</span>) {
    <span class="hljs-keyword">var</span> updateQueue = fiber.<span class="hljs-property">updateQueue</span>;

    <span class="hljs-keyword">if</span> (updateQueue === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-508">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-508">&#x00a7;</a>
              </div>
              <p>Only occurs if the fiber has been unmounted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> sharedQueue = updateQueue.<span class="hljs-property">shared</span>;
    <span class="hljs-keyword">var</span> pending = sharedQueue.<span class="hljs-property">pending</span>;

    <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-509">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-509">&#x00a7;</a>
              </div>
              <p>This is the first update. Create a circular list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      update.<span class="hljs-property">next</span> = update;
    } <span class="hljs-keyword">else</span> {
      update.<span class="hljs-property">next</span> = pending.<span class="hljs-property">next</span>;
      pending.<span class="hljs-property">next</span> = update;
    }

    sharedQueue.<span class="hljs-property">pending</span> = update;

    {
      <span class="hljs-keyword">if</span> (currentlyProcessingQueue === sharedQueue &amp;&amp; !didWarnUpdateInsideUpdate) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;An update (setState, replaceState, or forceUpdate) was scheduled &#x27;</span> + <span class="hljs-string">&#x27;from inside an update function. Update functions should be pure, &#x27;</span> + <span class="hljs-string">&#x27;with zero side-effects. Consider using componentDidUpdate or a &#x27;</span> + <span class="hljs-string">&#x27;callback.&#x27;</span>);

        didWarnUpdateInsideUpdate = <span class="hljs-literal">true</span>;
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueueCapturedUpdate</span>(<span class="hljs-params">workInProgress, capturedUpdate</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-510">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-510">&#x00a7;</a>
              </div>
              <p>Captured updates are updates that are thrown by a child during the render
phase. They should be discarded if the render is aborted. Therefore,
we should only put them on the work-in-progress queue, not the current one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> queue = workInProgress.<span class="hljs-property">updateQueue</span>; <span class="hljs-comment">// Check if the work-in-progress queue is a clone.</span>

    <span class="hljs-keyword">var</span> current = workInProgress.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> currentQueue = current.<span class="hljs-property">updateQueue</span>;

      <span class="hljs-keyword">if</span> (queue === currentQueue) {</pre></div></div>
            
        </li>
        
        
        <li id="section-511">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-511">&#x00a7;</a>
              </div>
              <p>The work-in-progress queue is the same as current. This happens when
we bail out on a parent fiber that then captures an error thrown by
a child. Since we want to append the update only to the work-in
-progress queue, we need to clone the updates. We usually clone during
processUpdateQueue, but that didn’t happen in this case because we
skipped over the parent when we bailed out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> newFirst = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> newLast = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> firstBaseUpdate = queue.<span class="hljs-property">firstBaseUpdate</span>;

        <span class="hljs-keyword">if</span> (firstBaseUpdate !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-512">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-512">&#x00a7;</a>
              </div>
              <p>Loop through the updates and clone them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> update = firstBaseUpdate;

          <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">var</span> clone = {
              <span class="hljs-attr">eventTime</span>: update.<span class="hljs-property">eventTime</span>,
              <span class="hljs-attr">lane</span>: update.<span class="hljs-property">lane</span>,
              <span class="hljs-attr">tag</span>: update.<span class="hljs-property">tag</span>,
              <span class="hljs-attr">payload</span>: update.<span class="hljs-property">payload</span>,
              <span class="hljs-attr">callback</span>: update.<span class="hljs-property">callback</span>,
              <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
            };

            <span class="hljs-keyword">if</span> (newLast === <span class="hljs-literal">null</span>) {
              newFirst = newLast = clone;
            } <span class="hljs-keyword">else</span> {
              newLast.<span class="hljs-property">next</span> = clone;
              newLast = clone;
            }

            update = update.<span class="hljs-property">next</span>;
          } <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// Append the captured update the end of the cloned list.</span>


          <span class="hljs-keyword">if</span> (newLast === <span class="hljs-literal">null</span>) {
            newFirst = newLast = capturedUpdate;
          } <span class="hljs-keyword">else</span> {
            newLast.<span class="hljs-property">next</span> = capturedUpdate;
            newLast = capturedUpdate;
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-513">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-513">&#x00a7;</a>
              </div>
              <p>There are no base updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          newFirst = newLast = capturedUpdate;
        }

        queue = {
          <span class="hljs-attr">baseState</span>: currentQueue.<span class="hljs-property">baseState</span>,
          <span class="hljs-attr">firstBaseUpdate</span>: newFirst,
          <span class="hljs-attr">lastBaseUpdate</span>: newLast,
          <span class="hljs-attr">shared</span>: currentQueue.<span class="hljs-property">shared</span>,
          <span class="hljs-attr">effects</span>: currentQueue.<span class="hljs-property">effects</span>
        };
        workInProgress.<span class="hljs-property">updateQueue</span> = queue;
        <span class="hljs-keyword">return</span>;
      }
    } <span class="hljs-comment">// Append the update to the end of the list.</span>


    <span class="hljs-keyword">var</span> lastBaseUpdate = queue.<span class="hljs-property">lastBaseUpdate</span>;

    <span class="hljs-keyword">if</span> (lastBaseUpdate === <span class="hljs-literal">null</span>) {
      queue.<span class="hljs-property">firstBaseUpdate</span> = capturedUpdate;
    } <span class="hljs-keyword">else</span> {
      lastBaseUpdate.<span class="hljs-property">next</span> = capturedUpdate;
    }

    queue.<span class="hljs-property">lastBaseUpdate</span> = capturedUpdate;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getStateFromUpdate</span>(<span class="hljs-params">workInProgress, queue, update, prevState, nextProps, instance</span>) {
    <span class="hljs-keyword">switch</span> (update.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ReplaceState</span>:
        {
          <span class="hljs-keyword">var</span> payload = update.<span class="hljs-property">payload</span>;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> payload === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-514">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-514">&#x00a7;</a>
              </div>
              <p>Updater function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            {
              <span class="hljs-title function_">enterDisallowedContextReadInDEV</span>();
            }

            <span class="hljs-keyword">var</span> nextState = payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);

            {
              <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
                <span class="hljs-title function_">disableLogs</span>();

                <span class="hljs-keyword">try</span> {
                  payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);
                } <span class="hljs-keyword">finally</span> {
                  <span class="hljs-title function_">reenableLogs</span>();
                }
              }

              <span class="hljs-title function_">exitDisallowedContextReadInDEV</span>();
            }

            <span class="hljs-keyword">return</span> nextState;
          } <span class="hljs-comment">// State object</span>


          <span class="hljs-keyword">return</span> payload;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">CaptureUpdate</span>:
        {
          workInProgress.<span class="hljs-property">flags</span> = workInProgress.<span class="hljs-property">flags</span> &amp; ~<span class="hljs-title class_">ShouldCapture</span> | <span class="hljs-title class_">DidCapture</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-515">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-515">&#x00a7;</a>
              </div>
              <p>Intentional fallthrough</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">UpdateState</span>:
        {
          <span class="hljs-keyword">var</span> _payload = update.<span class="hljs-property">payload</span>;
          <span class="hljs-keyword">var</span> partialState;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> _payload === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-516">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-516">&#x00a7;</a>
              </div>
              <p>Updater function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            {
              <span class="hljs-title function_">enterDisallowedContextReadInDEV</span>();
            }

            partialState = _payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);

            {
              <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
                <span class="hljs-title function_">disableLogs</span>();

                <span class="hljs-keyword">try</span> {
                  _payload.<span class="hljs-title function_">call</span>(instance, prevState, nextProps);
                } <span class="hljs-keyword">finally</span> {
                  <span class="hljs-title function_">reenableLogs</span>();
                }
              }

              <span class="hljs-title function_">exitDisallowedContextReadInDEV</span>();
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-517">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-517">&#x00a7;</a>
              </div>
              <p>Partial state object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            partialState = _payload;
          }

          <span class="hljs-keyword">if</span> (partialState === <span class="hljs-literal">null</span> || partialState === <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-518">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-518">&#x00a7;</a>
              </div>
              <p>Null and undefined are treated as no-ops.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> prevState;
          } <span class="hljs-comment">// Merge the partial state and the previous state.</span>


          <span class="hljs-keyword">return</span> <span class="hljs-title function_">_assign</span>({}, prevState, partialState);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForceUpdate</span>:
        {
          hasForceUpdate = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">return</span> prevState;
        }
    }

    <span class="hljs-keyword">return</span> prevState;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">processUpdateQueue</span>(<span class="hljs-params">workInProgress, props, instance, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-519">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-519">&#x00a7;</a>
              </div>
              <p>This is always non-null on a ClassComponent or HostRoot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> queue = workInProgress.<span class="hljs-property">updateQueue</span>;
    hasForceUpdate = <span class="hljs-literal">false</span>;

    {
      currentlyProcessingQueue = queue.<span class="hljs-property">shared</span>;
    }

    <span class="hljs-keyword">var</span> firstBaseUpdate = queue.<span class="hljs-property">firstBaseUpdate</span>;
    <span class="hljs-keyword">var</span> lastBaseUpdate = queue.<span class="hljs-property">lastBaseUpdate</span>; <span class="hljs-comment">// Check if there are pending updates. If so, transfer them to the base queue.</span>

    <span class="hljs-keyword">var</span> pendingQueue = queue.<span class="hljs-property">shared</span>.<span class="hljs-property">pending</span>;

    <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {
      queue.<span class="hljs-property">shared</span>.<span class="hljs-property">pending</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The pending queue is circular. Disconnect the pointer between first</span></pre></div></div>
            
        </li>
        
        
        <li id="section-520">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-520">&#x00a7;</a>
              </div>
              <p>and last so that it’s non-circular.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> lastPendingUpdate = pendingQueue;
      <span class="hljs-keyword">var</span> firstPendingUpdate = lastPendingUpdate.<span class="hljs-property">next</span>;
      lastPendingUpdate.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Append pending updates to base queue</span>

      <span class="hljs-keyword">if</span> (lastBaseUpdate === <span class="hljs-literal">null</span>) {
        firstBaseUpdate = firstPendingUpdate;
      } <span class="hljs-keyword">else</span> {
        lastBaseUpdate.<span class="hljs-property">next</span> = firstPendingUpdate;
      }

      lastBaseUpdate = lastPendingUpdate; <span class="hljs-comment">// If there&#x27;s a current queue, and it&#x27;s different from the base queue, then</span></pre></div></div>
            
        </li>
        
        
        <li id="section-521">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-521">&#x00a7;</a>
              </div>
              <p>we need to transfer the updates to that queue, too. Because the base
queue is a singly-linked list with no cycles, we can append to both
lists and take advantage of structural sharing.
TODO: Pass <code>current</code> as argument</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> current = workInProgress.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-522">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-522">&#x00a7;</a>
              </div>
              <p>This is always non-null on a ClassComponent or HostRoot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> currentQueue = current.<span class="hljs-property">updateQueue</span>;
        <span class="hljs-keyword">var</span> currentLastBaseUpdate = currentQueue.<span class="hljs-property">lastBaseUpdate</span>;

        <span class="hljs-keyword">if</span> (currentLastBaseUpdate !== lastBaseUpdate) {
          <span class="hljs-keyword">if</span> (currentLastBaseUpdate === <span class="hljs-literal">null</span>) {
            currentQueue.<span class="hljs-property">firstBaseUpdate</span> = firstPendingUpdate;
          } <span class="hljs-keyword">else</span> {
            currentLastBaseUpdate.<span class="hljs-property">next</span> = firstPendingUpdate;
          }

          currentQueue.<span class="hljs-property">lastBaseUpdate</span> = lastPendingUpdate;
        }
      }
    } <span class="hljs-comment">// These values may change as we process the queue.</span>


    <span class="hljs-keyword">if</span> (firstBaseUpdate !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-523">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-523">&#x00a7;</a>
              </div>
              <p>Iterate through the list of updates to compute the result.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> newState = queue.<span class="hljs-property">baseState</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Don&#x27;t need to accumulate this. Instead, we can remove renderLanes</span></pre></div></div>
            
        </li>
        
        
        <li id="section-524">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-524">&#x00a7;</a>
              </div>
              <p>from the original lanes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> newLanes = <span class="hljs-title class_">NoLanes</span>;
      <span class="hljs-keyword">var</span> newBaseState = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> newFirstBaseUpdate = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> newLastBaseUpdate = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> update = firstBaseUpdate;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">var</span> updateLane = update.<span class="hljs-property">lane</span>;
        <span class="hljs-keyword">var</span> updateEventTime = update.<span class="hljs-property">eventTime</span>;

        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSubsetOfLanes</span>(renderLanes, updateLane)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-525">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-525">&#x00a7;</a>
              </div>
              <p>Priority is insufficient. Skip this update. If this is the first
skipped update, the previous update/state is the new base
update/state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> clone = {
            <span class="hljs-attr">eventTime</span>: updateEventTime,
            <span class="hljs-attr">lane</span>: updateLane,
            <span class="hljs-attr">tag</span>: update.<span class="hljs-property">tag</span>,
            <span class="hljs-attr">payload</span>: update.<span class="hljs-property">payload</span>,
            <span class="hljs-attr">callback</span>: update.<span class="hljs-property">callback</span>,
            <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
          };

          <span class="hljs-keyword">if</span> (newLastBaseUpdate === <span class="hljs-literal">null</span>) {
            newFirstBaseUpdate = newLastBaseUpdate = clone;
            newBaseState = newState;
          } <span class="hljs-keyword">else</span> {
            newLastBaseUpdate = newLastBaseUpdate.<span class="hljs-property">next</span> = clone;
          } <span class="hljs-comment">// Update the remaining priority in the queue.</span>


          newLanes = <span class="hljs-title function_">mergeLanes</span>(newLanes, updateLane);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-526">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-526">&#x00a7;</a>
              </div>
              <p>This update does have sufficient priority.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newLastBaseUpdate !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> _clone = {
              <span class="hljs-attr">eventTime</span>: updateEventTime,</pre></div></div>
            
        </li>
        
        
        <li id="section-527">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-527">&#x00a7;</a>
              </div>
              <p>This update is going to be committed so we never want uncommit
it. Using NoLane works because 0 is a subset of all bitmasks, so
this will never be skipped by the check above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-attr">lane</span>: <span class="hljs-title class_">NoLane</span>,
              <span class="hljs-attr">tag</span>: update.<span class="hljs-property">tag</span>,
              <span class="hljs-attr">payload</span>: update.<span class="hljs-property">payload</span>,
              <span class="hljs-attr">callback</span>: update.<span class="hljs-property">callback</span>,
              <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
            };
            newLastBaseUpdate = newLastBaseUpdate.<span class="hljs-property">next</span> = _clone;
          } <span class="hljs-comment">// Process this update.</span>


          newState = <span class="hljs-title function_">getStateFromUpdate</span>(workInProgress, queue, update, newState, props, instance);
          <span class="hljs-keyword">var</span> callback = update.<span class="hljs-property">callback</span>;

          <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
            workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Callback</span>;
            <span class="hljs-keyword">var</span> effects = queue.<span class="hljs-property">effects</span>;

            <span class="hljs-keyword">if</span> (effects === <span class="hljs-literal">null</span>) {
              queue.<span class="hljs-property">effects</span> = [update];
            } <span class="hljs-keyword">else</span> {
              effects.<span class="hljs-title function_">push</span>(update);
            }
          }
        }

        update = update.<span class="hljs-property">next</span>;

        <span class="hljs-keyword">if</span> (update === <span class="hljs-literal">null</span>) {
          pendingQueue = queue.<span class="hljs-property">shared</span>.<span class="hljs-property">pending</span>;

          <span class="hljs-keyword">if</span> (pendingQueue === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">break</span>;
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-528">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-528">&#x00a7;</a>
              </div>
              <p>An update was scheduled from inside a reducer. Add the new
pending updates to the end of the list and keep processing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> _lastPendingUpdate = pendingQueue; <span class="hljs-comment">// Intentionally unsound. Pending updates form a circular list, but we</span></pre></div></div>
            
        </li>
        
        
        <li id="section-529">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-529">&#x00a7;</a>
              </div>
              <p>unravel them when transferring them to the base queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> _firstPendingUpdate = _lastPendingUpdate.<span class="hljs-property">next</span>;
            _lastPendingUpdate.<span class="hljs-property">next</span> = <span class="hljs-literal">null</span>;
            update = _firstPendingUpdate;
            queue.<span class="hljs-property">lastBaseUpdate</span> = _lastPendingUpdate;
            queue.<span class="hljs-property">shared</span>.<span class="hljs-property">pending</span> = <span class="hljs-literal">null</span>;
          }
        }
      } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);

      <span class="hljs-keyword">if</span> (newLastBaseUpdate === <span class="hljs-literal">null</span>) {
        newBaseState = newState;
      }

      queue.<span class="hljs-property">baseState</span> = newBaseState;
      queue.<span class="hljs-property">firstBaseUpdate</span> = newFirstBaseUpdate;
      queue.<span class="hljs-property">lastBaseUpdate</span> = newLastBaseUpdate; <span class="hljs-comment">// Set the remaining expiration time to be whatever is remaining in the queue.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-530">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-530">&#x00a7;</a>
              </div>
              <p>This should be fine because the only two other things that contribute to
expiration time are props and context. We’re already in the middle of the
begin phase by the time we start processing the queue, so we’ve already
dealt with the props. Context in components that specify
shouldComponentUpdate is tricky; but we’ll have to account for
that regardless.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-title function_">markSkippedUpdateLanes</span>(newLanes);
      workInProgress.<span class="hljs-property">lanes</span> = newLanes;
      workInProgress.<span class="hljs-property">memoizedState</span> = newState;
    }

    {
      currentlyProcessingQueue = <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callCallback</span>(<span class="hljs-params">callback, context</span>) {
    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid argument passed as callback. Expected a function. Instead received: &quot;</span> + callback);
      }
    }

    callback.<span class="hljs-title function_">call</span>(context);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetHasForceUpdateBeforeProcessing</span>(<span class="hljs-params"></span>) {
    hasForceUpdate = <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkHasForceUpdateAfterProcessing</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> hasForceUpdate;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitUpdateQueue</span>(<span class="hljs-params">finishedWork, finishedQueue, instance</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-531">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-531">&#x00a7;</a>
              </div>
              <p>Commit the effects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> effects = finishedQueue.<span class="hljs-property">effects</span>;
    finishedQueue.<span class="hljs-property">effects</span> = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (effects !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; effects.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">var</span> effect = effects[i];
        <span class="hljs-keyword">var</span> callback = effect.<span class="hljs-property">callback</span>;

        <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
          effect.<span class="hljs-property">callback</span> = <span class="hljs-literal">null</span>;
          <span class="hljs-title function_">callCallback</span>(callback, instance);
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> fakeInternalInstance = {};
  <span class="hljs-keyword">var</span> isArray = <span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span>; <span class="hljs-comment">// React.Component uses a shared frozen object by default.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-532">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-532">&#x00a7;</a>
              </div>
              <p>We’ll use it to determine whether we need to initialize legacy refs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> emptyRefsObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">React</span>.<span class="hljs-title class_">Component</span>().<span class="hljs-property">refs</span>;
  <span class="hljs-keyword">var</span> didWarnAboutStateAssignmentForComponent;
  <span class="hljs-keyword">var</span> didWarnAboutUninitializedState;
  <span class="hljs-keyword">var</span> didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
  <span class="hljs-keyword">var</span> didWarnAboutLegacyLifecyclesAndDerivedState;
  <span class="hljs-keyword">var</span> didWarnAboutUndefinedDerivedState;
  <span class="hljs-keyword">var</span> warnOnUndefinedDerivedState;
  <span class="hljs-keyword">var</span> warnOnInvalidCallback;
  <span class="hljs-keyword">var</span> didWarnAboutDirectlyAssigningPropsToState;
  <span class="hljs-keyword">var</span> didWarnAboutContextTypeAndContextTypes;
  <span class="hljs-keyword">var</span> didWarnAboutInvalidateContextType;

  {
    didWarnAboutStateAssignmentForComponent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    didWarnAboutUninitializedState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    didWarnAboutLegacyLifecyclesAndDerivedState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    didWarnAboutDirectlyAssigningPropsToState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    didWarnAboutUndefinedDerivedState = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    didWarnAboutContextTypeAndContextTypes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    didWarnAboutInvalidateContextType = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    <span class="hljs-keyword">var</span> didWarnOnInvalidCallback = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();

    warnOnInvalidCallback = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, callerName</span>) {
      <span class="hljs-keyword">if</span> (callback === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> key = callerName + <span class="hljs-string">&#x27;_&#x27;</span> + callback;

      <span class="hljs-keyword">if</span> (!didWarnOnInvalidCallback.<span class="hljs-title function_">has</span>(key)) {
        didWarnOnInvalidCallback.<span class="hljs-title function_">add</span>(key);

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s(...): Expected the last optional `callback` argument to be a &#x27;</span> + <span class="hljs-string">&#x27;function. Instead received: %s.&#x27;</span>, callerName, callback);
      }
    };

    warnOnUndefinedDerivedState = <span class="hljs-keyword">function</span> (<span class="hljs-params">type, partialState</span>) {
      <span class="hljs-keyword">if</span> (partialState === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(type) || <span class="hljs-string">&#x27;Component&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutUndefinedDerivedState.<span class="hljs-title function_">has</span>(componentName)) {
          didWarnAboutUndefinedDerivedState.<span class="hljs-title function_">add</span>(componentName);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. &#x27;</span> + <span class="hljs-string">&#x27;You have returned undefined.&#x27;</span>, componentName);
        }
      }
    }; <span class="hljs-comment">// This is so gross but it&#x27;s at least non-critical and can be removed if</span></pre></div></div>
            
        </li>
        
        
        <li id="section-533">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-533">&#x00a7;</a>
              </div>
              <p>it causes problems. This is meant to give a nicer error message for
ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
…)) which otherwise throws a “_processChildContext is not a function”
exception.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(fakeInternalInstance, <span class="hljs-string">&#x27;_processChildContext&#x27;</span>, {
      <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
      <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn&#x27;t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).&quot;</span>);
          }
        }
      }
    });
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(fakeInternalInstance);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyDerivedStateFromProps</span>(<span class="hljs-params">workInProgress, ctor, getDerivedStateFromProps, nextProps</span>) {
    <span class="hljs-keyword">var</span> prevState = workInProgress.<span class="hljs-property">memoizedState</span>;

    {
      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-title function_">disableLogs</span>();

        <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-534">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-534">&#x00a7;</a>
              </div>
              <p>Invoke the function an extra time to help detect side-effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps, prevState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title function_">reenableLogs</span>();
        }
      }
    }

    <span class="hljs-keyword">var</span> partialState = <span class="hljs-title function_">getDerivedStateFromProps</span>(nextProps, prevState);

    {
      <span class="hljs-title function_">warnOnUndefinedDerivedState</span>(ctor, partialState);
    } <span class="hljs-comment">// Merge the partial state and the previous state.</span>


    <span class="hljs-keyword">var</span> memoizedState = partialState === <span class="hljs-literal">null</span> || partialState === <span class="hljs-literal">undefined</span> ? prevState : <span class="hljs-title function_">_assign</span>({}, prevState, partialState);
    workInProgress.<span class="hljs-property">memoizedState</span> = memoizedState; <span class="hljs-comment">// Once the update queue is empty, persist the derived state onto the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-535">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-535">&#x00a7;</a>
              </div>
              <p>base state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">lanes</span> === <span class="hljs-title class_">NoLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-536">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-536">&#x00a7;</a>
              </div>
              <p>Queue is always non-null for classes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> updateQueue = workInProgress.<span class="hljs-property">updateQueue</span>;
      updateQueue.<span class="hljs-property">baseState</span> = memoizedState;
    }
  }
  <span class="hljs-keyword">var</span> classComponentUpdater = {
    <span class="hljs-attr">isMounted</span>: isMounted,
    <span class="hljs-attr">enqueueSetState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">inst, payload, callback</span>) {
      <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">get</span>(inst);
      <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
      <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
      <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane);
      update.<span class="hljs-property">payload</span> = payload;

      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">undefined</span> &amp;&amp; callback !== <span class="hljs-literal">null</span>) {
        {
          <span class="hljs-title function_">warnOnInvalidCallback</span>(callback, <span class="hljs-string">&#x27;setState&#x27;</span>);
        }

        update.<span class="hljs-property">callback</span> = callback;
      }

      <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);
      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);

      {
        <span class="hljs-title function_">markStateUpdateScheduled</span>(fiber, lane);
      }
    },
    <span class="hljs-attr">enqueueReplaceState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">inst, payload, callback</span>) {
      <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">get</span>(inst);
      <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
      <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
      <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane);
      update.<span class="hljs-property">tag</span> = <span class="hljs-title class_">ReplaceState</span>;
      update.<span class="hljs-property">payload</span> = payload;

      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">undefined</span> &amp;&amp; callback !== <span class="hljs-literal">null</span>) {
        {
          <span class="hljs-title function_">warnOnInvalidCallback</span>(callback, <span class="hljs-string">&#x27;replaceState&#x27;</span>);
        }

        update.<span class="hljs-property">callback</span> = callback;
      }

      <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);
      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);

      {
        <span class="hljs-title function_">markStateUpdateScheduled</span>(fiber, lane);
      }
    },
    <span class="hljs-attr">enqueueForceUpdate</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">inst, callback</span>) {
      <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">get</span>(inst);
      <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
      <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
      <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane);
      update.<span class="hljs-property">tag</span> = <span class="hljs-title class_">ForceUpdate</span>;

      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">undefined</span> &amp;&amp; callback !== <span class="hljs-literal">null</span>) {
        {
          <span class="hljs-title function_">warnOnInvalidCallback</span>(callback, <span class="hljs-string">&#x27;forceUpdate&#x27;</span>);
        }

        update.<span class="hljs-property">callback</span> = callback;
      }

      <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);
      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);

      {
        <span class="hljs-title function_">markForceUpdateScheduled</span>(fiber, lane);
      }
    }
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkShouldComponentUpdate</span>(<span class="hljs-params">workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext</span>) {
    <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">shouldComponentUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      {
        <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
          <span class="hljs-title function_">disableLogs</span>();

          <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-537">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-537">&#x00a7;</a>
              </div>
              <p>Invoke the function an extra time to help detect side-effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            instance.<span class="hljs-title function_">shouldComponentUpdate</span>(newProps, newState, nextContext);
          } <span class="hljs-keyword">finally</span> {
            <span class="hljs-title function_">reenableLogs</span>();
          }
        }
      }

      <span class="hljs-keyword">var</span> shouldUpdate = instance.<span class="hljs-title function_">shouldComponentUpdate</span>(newProps, newState, nextContext);

      {
        <span class="hljs-keyword">if</span> (shouldUpdate === <span class="hljs-literal">undefined</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.shouldComponentUpdate(): Returned undefined instead of a &#x27;</span> + <span class="hljs-string">&#x27;boolean value. Make sure to return true or false.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(ctor) || <span class="hljs-string">&#x27;Component&#x27;</span>);
        }
      }

      <span class="hljs-keyword">return</span> shouldUpdate;
    }

    <span class="hljs-keyword">if</span> (ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &amp;&amp; ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isPureReactComponent</span>) {
      <span class="hljs-keyword">return</span> !<span class="hljs-title function_">shallowEqual</span>(oldProps, newProps) || !<span class="hljs-title function_">shallowEqual</span>(oldState, newState);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkClassInstance</span>(<span class="hljs-params">workInProgress, ctor, newProps</span>) {
    <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;

    {
      <span class="hljs-keyword">var</span> name = <span class="hljs-title function_">getComponentName</span>(ctor) || <span class="hljs-string">&#x27;Component&#x27;</span>;
      <span class="hljs-keyword">var</span> renderPresent = instance.<span class="hljs-property">render</span>;

      <span class="hljs-keyword">if</span> (!renderPresent) {
        <span class="hljs-keyword">if</span> (ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &amp;&amp; <span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s(...): No `render` method found on the returned component &#x27;</span> + <span class="hljs-string">&#x27;instance: did you accidentally return an object from the constructor?&#x27;</span>, name);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s(...): No `render` method found on the returned component &#x27;</span> + <span class="hljs-string">&#x27;instance: you may have forgotten to define `render`.&#x27;</span>, name);
        }
      }

      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">getInitialState</span> &amp;&amp; !instance.<span class="hljs-property">getInitialState</span>.<span class="hljs-property">isReactClassApproved</span> &amp;&amp; !instance.<span class="hljs-property">state</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;getInitialState was defined on %s, a plain JavaScript class. &#x27;</span> + <span class="hljs-string">&#x27;This is only supported for classes created using React.createClass. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean to define a state property instead?&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">getDefaultProps</span> &amp;&amp; !instance.<span class="hljs-property">getDefaultProps</span>.<span class="hljs-property">isReactClassApproved</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;getDefaultProps was defined on %s, a plain JavaScript class. &#x27;</span> + <span class="hljs-string">&#x27;This is only supported for classes created using React.createClass. &#x27;</span> + <span class="hljs-string">&#x27;Use a static property to define defaultProps instead.&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">propTypes</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;propTypes was defined as an instance property on %s. Use a static &#x27;</span> + <span class="hljs-string">&#x27;property to define propTypes instead.&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">contextType</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;contextType was defined as an instance property on %s. Use a static &#x27;</span> + <span class="hljs-string">&#x27;property to define contextType instead.&#x27;</span>, name);
      }

      {
        <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">contextTypes</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;contextTypes was defined as an instance property on %s. Use a static &#x27;</span> + <span class="hljs-string">&#x27;property to define contextTypes instead.&#x27;</span>, name);
        }

        <span class="hljs-keyword">if</span> (ctor.<span class="hljs-property">contextType</span> &amp;&amp; ctor.<span class="hljs-property">contextTypes</span> &amp;&amp; !didWarnAboutContextTypeAndContextTypes.<span class="hljs-title function_">has</span>(ctor)) {
          didWarnAboutContextTypeAndContextTypes.<span class="hljs-title function_">add</span>(ctor);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s declares both contextTypes and contextType static properties. &#x27;</span> + <span class="hljs-string">&#x27;The legacy contextTypes property will be ignored.&#x27;</span>, name);
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentShouldUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s has a method called &#x27;</span> + <span class="hljs-string">&#x27;componentShouldUpdate(). Did you mean shouldComponentUpdate()? &#x27;</span> + <span class="hljs-string">&#x27;The name is phrased as a question because the function is &#x27;</span> + <span class="hljs-string">&#x27;expected to return a value.&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &amp;&amp; ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">isPureReactComponent</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">shouldComponentUpdate</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s has a method called shouldComponentUpdate(). &#x27;</span> + <span class="hljs-string">&#x27;shouldComponentUpdate should not be used when extending React.PureComponent. &#x27;</span> + <span class="hljs-string">&#x27;Please extend React.Component if shouldComponentUpdate is used.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(ctor) || <span class="hljs-string">&#x27;A pure component&#x27;</span>);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidUnmount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s has a method called &#x27;</span> + <span class="hljs-string">&#x27;componentDidUnmount(). But there is no such lifecycle method. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean componentWillUnmount()?&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s has a method called &#x27;</span> + <span class="hljs-string">&#x27;componentDidReceiveProps(). But there is no such lifecycle method. &#x27;</span> + <span class="hljs-string">&#x27;If you meant to update the state in response to changing props, &#x27;</span> + <span class="hljs-string">&#x27;use componentWillReceiveProps(). If you meant to fetch data or &#x27;</span> + <span class="hljs-string">&#x27;run side-effects or mutations after React has updated the UI, use componentDidUpdate().&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillRecieveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s has a method called &#x27;</span> + <span class="hljs-string">&#x27;componentWillRecieveProps(). Did you mean componentWillReceiveProps()?&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillRecieveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s has a method called &#x27;</span> + <span class="hljs-string">&#x27;UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?&#x27;</span>, name);
      }

      <span class="hljs-keyword">var</span> hasMutatedProps = instance.<span class="hljs-property">props</span> !== newProps;

      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">props</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; hasMutatedProps) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s(...): When calling super() in `%s`, make sure to pass &#x27;</span> + <span class="hljs-string">&quot;up the same props that your component&#x27;s constructor was passed.&quot;</span>, name, name);
      }

      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">defaultProps</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Setting defaultProps as an instance property on %s is not supported and will be ignored.&#x27;</span> + <span class="hljs-string">&#x27; Instead, define defaultProps as a static property on %s.&#x27;</span>, name, name);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidUpdate</span> !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.<span class="hljs-title function_">has</span>(ctor)) {
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.<span class="hljs-title function_">add</span>(ctor);

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). &#x27;</span> + <span class="hljs-string">&#x27;This component defines getSnapshotBeforeUpdate() only.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(ctor));
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getDerivedStateFromProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: getDerivedStateFromProps() is defined as an instance method &#x27;</span> + <span class="hljs-string">&#x27;and will be ignored. Instead, declare it as a static method.&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getDerivedStateFromError</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: getDerivedStateFromError() is defined as an instance method &#x27;</span> + <span class="hljs-string">&#x27;and will be ignored. Instead, declare it as a static method.&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: getSnapshotBeforeUpdate() is defined as a static method &#x27;</span> + <span class="hljs-string">&#x27;and will be ignored. Instead, declare it as an instance method.&#x27;</span>, name);
      }

      <span class="hljs-keyword">var</span> _state = instance.<span class="hljs-property">state</span>;

      <span class="hljs-keyword">if</span> (_state &amp;&amp; (<span class="hljs-keyword">typeof</span> _state !== <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-title function_">isArray</span>(_state))) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.state: must be set to an object or null&#x27;</span>, name);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getChildContext</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">childContextTypes</span> !== <span class="hljs-string">&#x27;object&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.getChildContext(): childContextTypes must be defined in order to &#x27;</span> + <span class="hljs-string">&#x27;use getChildContext().&#x27;</span>, name);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">adoptClassInstance</span>(<span class="hljs-params">workInProgress, instance</span>) {
    instance.<span class="hljs-property">updater</span> = classComponentUpdater;
    workInProgress.<span class="hljs-property">stateNode</span> = instance; <span class="hljs-comment">// The instance needs access to the fiber so that it can schedule updates</span>

    <span class="hljs-title function_">set</span>(instance, workInProgress);

    {
      instance.<span class="hljs-property">_reactInternalInstance</span> = fakeInternalInstance;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">constructClassInstance</span>(<span class="hljs-params">workInProgress, ctor, props</span>) {
    <span class="hljs-keyword">var</span> isLegacyContextConsumer = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> unmaskedContext = emptyContextObject;
    <span class="hljs-keyword">var</span> context = emptyContextObject;
    <span class="hljs-keyword">var</span> contextType = ctor.<span class="hljs-property">contextType</span>;

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;contextType&#x27;</span> <span class="hljs-keyword">in</span> ctor) {
        <span class="hljs-keyword">var</span> isValid = <span class="hljs-comment">// Allow null for conditional declaration</span>
          contextType === <span class="hljs-literal">null</span> || contextType !== <span class="hljs-literal">undefined</span> &amp;&amp; contextType.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_CONTEXT_TYPE</span> &amp;&amp; contextType.<span class="hljs-property">_context</span> === <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// Not a &lt;Context.Consumer&gt;</span>

        <span class="hljs-keyword">if</span> (!isValid &amp;&amp; !didWarnAboutInvalidateContextType.<span class="hljs-title function_">has</span>(ctor)) {
          didWarnAboutInvalidateContextType.<span class="hljs-title function_">add</span>(ctor);
          <span class="hljs-keyword">var</span> addendum = <span class="hljs-string">&#x27;&#x27;</span>;

          <span class="hljs-keyword">if</span> (contextType === <span class="hljs-literal">undefined</span>) {
            addendum = <span class="hljs-string">&#x27; However, it is set to undefined. &#x27;</span> + <span class="hljs-string">&#x27;This can be caused by a typo or by mixing up named and default imports. &#x27;</span> + <span class="hljs-string">&#x27;This can also happen due to a circular dependency, so &#x27;</span> + <span class="hljs-string">&#x27;try moving the createContext() call to a separate file.&#x27;</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType !== <span class="hljs-string">&#x27;object&#x27;</span>) {
            addendum = <span class="hljs-string">&#x27; However, it is set to a &#x27;</span> + <span class="hljs-keyword">typeof</span> contextType + <span class="hljs-string">&#x27;.&#x27;</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_PROVIDER_TYPE</span>) {
            addendum = <span class="hljs-string">&#x27; Did you accidentally pass the Context.Provider instead?&#x27;</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (contextType.<span class="hljs-property">_context</span> !== <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-538">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-538">&#x00a7;</a>
              </div>
              <p>&lt;Context.Consumer&gt;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            addendum = <span class="hljs-string">&#x27; Did you accidentally pass the Context.Consumer instead?&#x27;</span>;
          } <span class="hljs-keyword">else</span> {
            addendum = <span class="hljs-string">&#x27; However, it is set to an object with keys {&#x27;</span> + <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(contextType).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>) + <span class="hljs-string">&#x27;}.&#x27;</span>;
          }

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s defines an invalid contextType. &#x27;</span> + <span class="hljs-string">&#x27;contextType should point to the Context object returned by React.createContext().%s&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(ctor) || <span class="hljs-string">&#x27;Component&#x27;</span>, addendum);
        }
      }
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
      context = <span class="hljs-title function_">readContext</span>(contextType);
    } <span class="hljs-keyword">else</span> {
      unmaskedContext = <span class="hljs-title function_">getUnmaskedContext</span>(workInProgress, ctor, <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">var</span> contextTypes = ctor.<span class="hljs-property">contextTypes</span>;
      isLegacyContextConsumer = contextTypes !== <span class="hljs-literal">null</span> &amp;&amp; contextTypes !== <span class="hljs-literal">undefined</span>;
      context = isLegacyContextConsumer ? <span class="hljs-title function_">getMaskedContext</span>(workInProgress, unmaskedContext) : emptyContextObject;
    } <span class="hljs-comment">// Instantiate twice to help detect side-effects.</span>


    {
      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-title function_">disableLogs</span>();

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>(props, context); <span class="hljs-comment">// eslint-disable-line no-new</span>
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title function_">reenableLogs</span>();
        }
      }
    }

    <span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">ctor</span>(props, context);
    <span class="hljs-keyword">var</span> state = workInProgress.<span class="hljs-property">memoizedState</span> = instance.<span class="hljs-property">state</span> !== <span class="hljs-literal">null</span> &amp;&amp; instance.<span class="hljs-property">state</span> !== <span class="hljs-literal">undefined</span> ? instance.<span class="hljs-property">state</span> : <span class="hljs-literal">null</span>;
    <span class="hljs-title function_">adoptClassInstance</span>(workInProgress, instance);

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; state === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(ctor) || <span class="hljs-string">&#x27;Component&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutUninitializedState.<span class="hljs-title function_">has</span>(componentName)) {
          didWarnAboutUninitializedState.<span class="hljs-title function_">add</span>(componentName);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;`%s` uses `getDerivedStateFromProps` but its initial state is &#x27;</span> + <span class="hljs-string">&#x27;%s. This is not recommended. Instead, define the initial state by &#x27;</span> + <span class="hljs-string">&#x27;assigning an object to `this.state` in the constructor of `%s`. &#x27;</span> + <span class="hljs-string">&#x27;This ensures that `getDerivedStateFromProps` arguments have a consistent shape.&#x27;</span>, componentName, instance.<span class="hljs-property">state</span> === <span class="hljs-literal">null</span> ? <span class="hljs-string">&#x27;null&#x27;</span> : <span class="hljs-string">&#x27;undefined&#x27;</span>, componentName);
        }
      } <span class="hljs-comment">// If new component APIs are defined, &quot;unsafe&quot; lifecycles won&#x27;t be called.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-539">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-539">&#x00a7;</a>
              </div>
              <p>Warn about these lifecycles if they are present.
Don’t warn about react-lifecycles-compat polyfilled methods though.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">var</span> foundWillMountName = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> foundWillReceivePropsName = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> foundWillUpdateName = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; instance.<span class="hljs-property">componentWillMount</span>.<span class="hljs-property">__suppressDeprecationWarning</span> !== <span class="hljs-literal">true</span>) {
          foundWillMountName = <span class="hljs-string">&#x27;componentWillMount&#x27;</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          foundWillMountName = <span class="hljs-string">&#x27;UNSAFE_componentWillMount&#x27;</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; instance.<span class="hljs-property">componentWillReceiveProps</span>.<span class="hljs-property">__suppressDeprecationWarning</span> !== <span class="hljs-literal">true</span>) {
          foundWillReceivePropsName = <span class="hljs-string">&#x27;componentWillReceiveProps&#x27;</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          foundWillReceivePropsName = <span class="hljs-string">&#x27;UNSAFE_componentWillReceiveProps&#x27;</span>;
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; instance.<span class="hljs-property">componentWillUpdate</span>.<span class="hljs-property">__suppressDeprecationWarning</span> !== <span class="hljs-literal">true</span>) {
          foundWillUpdateName = <span class="hljs-string">&#x27;componentWillUpdate&#x27;</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          foundWillUpdateName = <span class="hljs-string">&#x27;UNSAFE_componentWillUpdate&#x27;</span>;
        }

        <span class="hljs-keyword">if</span> (foundWillMountName !== <span class="hljs-literal">null</span> || foundWillReceivePropsName !== <span class="hljs-literal">null</span> || foundWillUpdateName !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> _componentName = <span class="hljs-title function_">getComponentName</span>(ctor) || <span class="hljs-string">&#x27;Component&#x27;</span>;

          <span class="hljs-keyword">var</span> newApiName = <span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-string">&#x27;getDerivedStateFromProps()&#x27;</span> : <span class="hljs-string">&#x27;getSnapshotBeforeUpdate()&#x27;</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutLegacyLifecyclesAndDerivedState.<span class="hljs-title function_">has</span>(_componentName)) {
            didWarnAboutLegacyLifecyclesAndDerivedState.<span class="hljs-title function_">add</span>(_componentName);

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n&#x27;</span> + <span class="hljs-string">&#x27;%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n&#x27;</span> + <span class="hljs-string">&#x27;The above lifecycles should be removed. Learn more about this warning here:\n&#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/unsafe-component-lifecycles&#x27;</span>, _componentName, newApiName, foundWillMountName !== <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;\n  &quot;</span> + foundWillMountName : <span class="hljs-string">&#x27;&#x27;</span>, foundWillReceivePropsName !== <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;\n  &quot;</span> + foundWillReceivePropsName : <span class="hljs-string">&#x27;&#x27;</span>, foundWillUpdateName !== <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;\n  &quot;</span> + foundWillUpdateName : <span class="hljs-string">&#x27;&#x27;</span>);
          }
        }
      }
    } <span class="hljs-comment">// Cache unmasked context so we can avoid recreating masked context unless necessary.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-540">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-540">&#x00a7;</a>
              </div>
              <p>ReactFiberContext usually updates this cache but can’t for newly-created instances.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (isLegacyContextConsumer) {
      <span class="hljs-title function_">cacheContext</span>(workInProgress, unmaskedContext, context);
    }

    <span class="hljs-keyword">return</span> instance;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callComponentWillMount</span>(<span class="hljs-params">workInProgress, instance</span>) {
    <span class="hljs-keyword">var</span> oldState = instance.<span class="hljs-property">state</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      instance.<span class="hljs-title function_">componentWillMount</span>();
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      instance.<span class="hljs-title function_">UNSAFE_componentWillMount</span>();
    }

    <span class="hljs-keyword">if</span> (oldState !== instance.<span class="hljs-property">state</span>) {
      {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.componentWillMount(): Assigning directly to this.state is &#x27;</span> + <span class="hljs-string">&quot;deprecated (except inside a component&#x27;s &quot;</span> + <span class="hljs-string">&#x27;constructor). Use setState instead.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(workInProgress.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>);
      }

      classComponentUpdater.<span class="hljs-title function_">enqueueReplaceState</span>(instance, instance.<span class="hljs-property">state</span>, <span class="hljs-literal">null</span>);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">callComponentWillReceiveProps</span>(<span class="hljs-params">workInProgress, instance, newProps, nextContext</span>) {
    <span class="hljs-keyword">var</span> oldState = instance.<span class="hljs-property">state</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      instance.<span class="hljs-title function_">componentWillReceiveProps</span>(newProps, nextContext);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      instance.<span class="hljs-title function_">UNSAFE_componentWillReceiveProps</span>(newProps, nextContext);
    }

    <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">state</span> !== oldState) {
      {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(workInProgress.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutStateAssignmentForComponent.<span class="hljs-title function_">has</span>(componentName)) {
          didWarnAboutStateAssignmentForComponent.<span class="hljs-title function_">add</span>(componentName);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.componentWillReceiveProps(): Assigning directly to &#x27;</span> + <span class="hljs-string">&quot;this.state is deprecated (except inside a component&#x27;s &quot;</span> + <span class="hljs-string">&#x27;constructor). Use setState instead.&#x27;</span>, componentName);
        }
      }

      classComponentUpdater.<span class="hljs-title function_">enqueueReplaceState</span>(instance, instance.<span class="hljs-property">state</span>, <span class="hljs-literal">null</span>);
    }
  } <span class="hljs-comment">// Invokes the mount life-cycles on a previously never rendered instance.</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountClassInstance</span>(<span class="hljs-params">workInProgress, ctor, newProps, renderLanes</span>) {
    {
      <span class="hljs-title function_">checkClassInstance</span>(workInProgress, ctor, newProps);
    }

    <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;
    instance.<span class="hljs-property">props</span> = newProps;
    instance.<span class="hljs-property">state</span> = workInProgress.<span class="hljs-property">memoizedState</span>;
    instance.<span class="hljs-property">refs</span> = emptyRefsObject;
    <span class="hljs-title function_">initializeUpdateQueue</span>(workInProgress);
    <span class="hljs-keyword">var</span> contextType = ctor.<span class="hljs-property">contextType</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
      instance.<span class="hljs-property">context</span> = <span class="hljs-title function_">readContext</span>(contextType);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> unmaskedContext = <span class="hljs-title function_">getUnmaskedContext</span>(workInProgress, ctor, <span class="hljs-literal">true</span>);
      instance.<span class="hljs-property">context</span> = <span class="hljs-title function_">getMaskedContext</span>(workInProgress, unmaskedContext);
    }

    {
      <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">state</span> === newProps) {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(ctor) || <span class="hljs-string">&#x27;Component&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutDirectlyAssigningPropsToState.<span class="hljs-title function_">has</span>(componentName)) {
          didWarnAboutDirectlyAssigningPropsToState.<span class="hljs-title function_">add</span>(componentName);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: It is not recommended to assign props directly to state &#x27;</span> + <span class="hljs-string">&quot;because updates to props won&#x27;t be reflected in state. &quot;</span> + <span class="hljs-string">&#x27;In most cases, it is better to use props directly.&#x27;</span>, componentName);
        }
      }

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-title function_">recordLegacyContextWarning</span>(workInProgress, instance);
      }

      {
        <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-title function_">recordUnsafeLifecycleWarnings</span>(workInProgress, instance);
      }
    }

    <span class="hljs-title function_">processUpdateQueue</span>(workInProgress, newProps, instance, renderLanes);
    instance.<span class="hljs-property">state</span> = workInProgress.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> getDerivedStateFromProps = ctor.<span class="hljs-property">getDerivedStateFromProps</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-title function_">applyDerivedStateFromProps</span>(workInProgress, ctor, getDerivedStateFromProps, newProps);
      instance.<span class="hljs-property">state</span> = workInProgress.<span class="hljs-property">memoizedState</span>;
    } <span class="hljs-comment">// In order to support react-lifecycles-compat polyfilled components,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-541">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-541">&#x00a7;</a>
              </div>
              <p>Unsafe lifecycles should not be invoked for components using the new APIs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromProps</span> !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>)) {
      <span class="hljs-title function_">callComponentWillMount</span>(workInProgress, instance); <span class="hljs-comment">// If we had additional state updates during this life-cycle, let&#x27;s</span></pre></div></div>
            
        </li>
        
        
        <li id="section-542">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-542">&#x00a7;</a>
              </div>
              <p>process them now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-title function_">processUpdateQueue</span>(workInProgress, newProps, instance, renderLanes);
      instance.<span class="hljs-property">state</span> = workInProgress.<span class="hljs-property">memoizedState</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resumeMountClassInstance</span>(<span class="hljs-params">workInProgress, ctor, newProps, renderLanes</span>) {
    <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;
    <span class="hljs-keyword">var</span> oldProps = workInProgress.<span class="hljs-property">memoizedProps</span>;
    instance.<span class="hljs-property">props</span> = oldProps;
    <span class="hljs-keyword">var</span> oldContext = instance.<span class="hljs-property">context</span>;
    <span class="hljs-keyword">var</span> contextType = ctor.<span class="hljs-property">contextType</span>;
    <span class="hljs-keyword">var</span> nextContext = emptyContextObject;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
      nextContext = <span class="hljs-title function_">readContext</span>(contextType);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> nextLegacyUnmaskedContext = <span class="hljs-title function_">getUnmaskedContext</span>(workInProgress, ctor, <span class="hljs-literal">true</span>);
      nextContext = <span class="hljs-title function_">getMaskedContext</span>(workInProgress, nextLegacyUnmaskedContext);
    }

    <span class="hljs-keyword">var</span> getDerivedStateFromProps = ctor.<span class="hljs-property">getDerivedStateFromProps</span>;
    <span class="hljs-keyword">var</span> hasNewLifecycles = <span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>; <span class="hljs-comment">// Note: During these life-cycles, instance.props/instance.state are what</span></pre></div></div>
            
        </li>
        
        
        <li id="section-543">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-543">&#x00a7;</a>
              </div>
              <p>ever the previously attempted to render - not the “current”. However,
during componentDidUpdate we pass the “current” props.
In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>)) {
      <span class="hljs-keyword">if</span> (oldProps !== newProps || oldContext !== nextContext) {
        <span class="hljs-title function_">callComponentWillReceiveProps</span>(workInProgress, instance, newProps, nextContext);
      }
    }

    <span class="hljs-title function_">resetHasForceUpdateBeforeProcessing</span>();
    <span class="hljs-keyword">var</span> oldState = workInProgress.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> newState = instance.<span class="hljs-property">state</span> = oldState;
    <span class="hljs-title function_">processUpdateQueue</span>(workInProgress, newProps, instance, renderLanes);
    newState = workInProgress.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (oldProps === newProps &amp;&amp; oldState === newState &amp;&amp; !<span class="hljs-title function_">hasContextChanged</span>() &amp;&amp; !<span class="hljs-title function_">checkHasForceUpdateAfterProcessing</span>()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-544">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-544">&#x00a7;</a>
              </div>
              <p>If an update was already in progress, we should schedule an Update
effect even though we’re bailing out, so that cWU/cDU are called.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-title function_">applyDerivedStateFromProps</span>(workInProgress, ctor, getDerivedStateFromProps, newProps);
      newState = workInProgress.<span class="hljs-property">memoizedState</span>;
    }

    <span class="hljs-keyword">var</span> shouldUpdate = <span class="hljs-title function_">checkHasForceUpdateAfterProcessing</span>() || <span class="hljs-title function_">checkShouldComponentUpdate</span>(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

    <span class="hljs-keyword">if</span> (shouldUpdate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-545">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-545">&#x00a7;</a>
              </div>
              <p>In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          instance.<span class="hljs-title function_">componentWillMount</span>();
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          instance.<span class="hljs-title function_">UNSAFE_componentWillMount</span>();
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-546">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-546">&#x00a7;</a>
              </div>
              <p>If an update was already in progress, we should schedule an Update
effect even though we’re bailing out, so that cWU/cDU are called.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidMount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
      } <span class="hljs-comment">// If shouldComponentUpdate returned false, we should still update the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-547">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-547">&#x00a7;</a>
              </div>
              <p>memoized state to indicate that this work can be reused.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      workInProgress.<span class="hljs-property">memoizedProps</span> = newProps;
      workInProgress.<span class="hljs-property">memoizedState</span> = newState;
    } <span class="hljs-comment">// Update the existing instance&#x27;s state, props, and context pointers even</span></pre></div></div>
            
        </li>
        
        
        <li id="section-548">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-548">&#x00a7;</a>
              </div>
              <p>if shouldComponentUpdate returns false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    instance.<span class="hljs-property">props</span> = newProps;
    instance.<span class="hljs-property">state</span> = newState;
    instance.<span class="hljs-property">context</span> = nextContext;
    <span class="hljs-keyword">return</span> shouldUpdate;
  } <span class="hljs-comment">// Invokes the update life-cycles and returns false if it shouldn&#x27;t rerender.</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassInstance</span>(<span class="hljs-params">current, workInProgress, ctor, newProps, renderLanes</span>) {
    <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;
    <span class="hljs-title function_">cloneUpdateQueue</span>(current, workInProgress);
    <span class="hljs-keyword">var</span> unresolvedOldProps = workInProgress.<span class="hljs-property">memoizedProps</span>;
    <span class="hljs-keyword">var</span> oldProps = workInProgress.<span class="hljs-property">type</span> === workInProgress.<span class="hljs-property">elementType</span> ? unresolvedOldProps : <span class="hljs-title function_">resolveDefaultProps</span>(workInProgress.<span class="hljs-property">type</span>, unresolvedOldProps);
    instance.<span class="hljs-property">props</span> = oldProps;
    <span class="hljs-keyword">var</span> unresolvedNewProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> oldContext = instance.<span class="hljs-property">context</span>;
    <span class="hljs-keyword">var</span> contextType = ctor.<span class="hljs-property">contextType</span>;
    <span class="hljs-keyword">var</span> nextContext = emptyContextObject;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> contextType === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; contextType !== <span class="hljs-literal">null</span>) {
      nextContext = <span class="hljs-title function_">readContext</span>(contextType);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> nextUnmaskedContext = <span class="hljs-title function_">getUnmaskedContext</span>(workInProgress, ctor, <span class="hljs-literal">true</span>);
      nextContext = <span class="hljs-title function_">getMaskedContext</span>(workInProgress, nextUnmaskedContext);
    }

    <span class="hljs-keyword">var</span> getDerivedStateFromProps = ctor.<span class="hljs-property">getDerivedStateFromProps</span>;
    <span class="hljs-keyword">var</span> hasNewLifecycles = <span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>; <span class="hljs-comment">// Note: During these life-cycles, instance.props/instance.state are what</span></pre></div></div>
            
        </li>
        
        
        <li id="section-549">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-549">&#x00a7;</a>
              </div>
              <p>ever the previously attempted to render - not the “current”. However,
during componentDidUpdate we pass the “current” props.
In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillReceiveProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>)) {
      <span class="hljs-keyword">if</span> (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
        <span class="hljs-title function_">callComponentWillReceiveProps</span>(workInProgress, instance, newProps, nextContext);
      }
    }

    <span class="hljs-title function_">resetHasForceUpdateBeforeProcessing</span>();
    <span class="hljs-keyword">var</span> oldState = workInProgress.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> newState = instance.<span class="hljs-property">state</span> = oldState;
    <span class="hljs-title function_">processUpdateQueue</span>(workInProgress, newProps, instance, renderLanes);
    newState = workInProgress.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (unresolvedOldProps === unresolvedNewProps &amp;&amp; oldState === newState &amp;&amp; !<span class="hljs-title function_">hasContextChanged</span>() &amp;&amp; !<span class="hljs-title function_">checkHasForceUpdateAfterProcessing</span>()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-550">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-550">&#x00a7;</a>
              </div>
              <p>If an update was already in progress, we should schedule an Update
effect even though we’re bailing out, so that cWU/cDU are called.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">if</span> (unresolvedOldProps !== current.<span class="hljs-property">memoizedProps</span> || oldState !== current.<span class="hljs-property">memoizedState</span>) {
          workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">if</span> (unresolvedOldProps !== current.<span class="hljs-property">memoizedProps</span> || oldState !== current.<span class="hljs-property">memoizedState</span>) {
          workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Snapshot</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-title function_">applyDerivedStateFromProps</span>(workInProgress, ctor, getDerivedStateFromProps, newProps);
      newState = workInProgress.<span class="hljs-property">memoizedState</span>;
    }

    <span class="hljs-keyword">var</span> shouldUpdate = <span class="hljs-title function_">checkHasForceUpdateAfterProcessing</span>() || <span class="hljs-title function_">checkShouldComponentUpdate</span>(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

    <span class="hljs-keyword">if</span> (shouldUpdate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-551">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-551">&#x00a7;</a>
              </div>
              <p>In order to support react-lifecycles-compat polyfilled components,
Unsafe lifecycles should not be invoked for components using the new APIs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!hasNewLifecycles &amp;&amp; (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>)) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          instance.<span class="hljs-title function_">componentWillUpdate</span>(newProps, newState, nextContext);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">UNSAFE_componentWillUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          instance.<span class="hljs-title function_">UNSAFE_componentWillUpdate</span>(newProps, newState, nextContext);
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Snapshot</span>;
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-552">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-552">&#x00a7;</a>
              </div>
              <p>If an update was already in progress, we should schedule an Update
effect even though we’re bailing out, so that cWU/cDU are called.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">if</span> (unresolvedOldProps !== current.<span class="hljs-property">memoizedProps</span> || oldState !== current.<span class="hljs-property">memoizedState</span>) {
          workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">getSnapshotBeforeUpdate</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">if</span> (unresolvedOldProps !== current.<span class="hljs-property">memoizedProps</span> || oldState !== current.<span class="hljs-property">memoizedState</span>) {
          workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Snapshot</span>;
        }
      } <span class="hljs-comment">// If shouldComponentUpdate returned false, we should still update the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-553">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-553">&#x00a7;</a>
              </div>
              <p>memoized props/state to indicate that this work can be reused.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      workInProgress.<span class="hljs-property">memoizedProps</span> = newProps;
      workInProgress.<span class="hljs-property">memoizedState</span> = newState;
    } <span class="hljs-comment">// Update the existing instance&#x27;s state, props, and context pointers even</span></pre></div></div>
            
        </li>
        
        
        <li id="section-554">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-554">&#x00a7;</a>
              </div>
              <p>if shouldComponentUpdate returns false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    instance.<span class="hljs-property">props</span> = newProps;
    instance.<span class="hljs-property">state</span> = newState;
    instance.<span class="hljs-property">context</span> = nextContext;
    <span class="hljs-keyword">return</span> shouldUpdate;
  }

  <span class="hljs-keyword">var</span> didWarnAboutMaps;
  <span class="hljs-keyword">var</span> didWarnAboutGenerators;
  <span class="hljs-keyword">var</span> didWarnAboutStringRefs;
  <span class="hljs-keyword">var</span> ownerHasKeyUseWarning;
  <span class="hljs-keyword">var</span> ownerHasFunctionTypeWarning;

  <span class="hljs-keyword">var</span> warnForMissingKey = <span class="hljs-keyword">function</span> (<span class="hljs-params">child, returnFiber</span>) { };

  {
    didWarnAboutMaps = <span class="hljs-literal">false</span>;
    didWarnAboutGenerators = <span class="hljs-literal">false</span>;
    didWarnAboutStringRefs = {};
    <span class="hljs-comment">/**
     * Warn if there&#x27;s no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */</span>

    ownerHasKeyUseWarning = {};
    ownerHasFunctionTypeWarning = {};

    warnForMissingKey = <span class="hljs-keyword">function</span> (<span class="hljs-params">child, returnFiber</span>) {
      <span class="hljs-keyword">if</span> (child === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> child !== <span class="hljs-string">&#x27;object&#x27;</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (!child.<span class="hljs-property">_store</span> || child.<span class="hljs-property">_store</span>.<span class="hljs-property">validated</span> || child.<span class="hljs-property">key</span> != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> child.<span class="hljs-property">_store</span> === <span class="hljs-string">&#x27;object&#x27;</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }

      child.<span class="hljs-property">_store</span>.<span class="hljs-property">validated</span> = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(returnFiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>;

      <span class="hljs-keyword">if</span> (ownerHasKeyUseWarning[componentName]) {
        <span class="hljs-keyword">return</span>;
      }

      ownerHasKeyUseWarning[componentName] = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Each child in a list should have a unique &#x27;</span> + <span class="hljs-string">&#x27;&quot;key&quot; prop. See https://reactjs.org/link/warning-keys for &#x27;</span> + <span class="hljs-string">&#x27;more information.&#x27;</span>);
    };
  }

  <span class="hljs-keyword">var</span> isArray$<span class="hljs-number">1</span> = <span class="hljs-title class_">Array</span>.<span class="hljs-property">isArray</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">coerceRef</span>(<span class="hljs-params">returnFiber, current, element</span>) {
    <span class="hljs-keyword">var</span> mixedRef = element.<span class="hljs-property">ref</span>;

    <span class="hljs-keyword">if</span> (mixedRef !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> mixedRef !== <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> mixedRef !== <span class="hljs-string">&#x27;object&#x27;</span>) {
      {</pre></div></div>
            
        </li>
        
        
        <li id="section-555">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-555">&#x00a7;</a>
              </div>
              <p>TODO: Clean this up once we turn on the string ref warning for
everyone, because the strict mode case will no longer be relevant</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> ((returnFiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span> || warnAboutStringRefs) &amp;&amp; <span class="hljs-comment">// We warn in ReactElement.js if owner and self are equal for string refs</span></pre></div></div>
            
        </li>
        
        
        <li id="section-556">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-556">&#x00a7;</a>
              </div>
              <p>because these cannot be automatically converted to an arrow function
using a codemod. Therefore, we don’t have to warn about string refs again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          !(element.<span class="hljs-property">_owner</span> &amp;&amp; element.<span class="hljs-property">_self</span> &amp;&amp; element.<span class="hljs-property">_owner</span>.<span class="hljs-property">stateNode</span> !== element.<span class="hljs-property">_self</span>)) {
          <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(returnFiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>;

          <span class="hljs-keyword">if</span> (!didWarnAboutStringRefs[componentName]) {
            {
              <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A string ref, &quot;%s&quot;, has been found within a strict mode tree. &#x27;</span> + <span class="hljs-string">&#x27;String refs are a source of potential bugs and should be avoided. &#x27;</span> + <span class="hljs-string">&#x27;We recommend using useRef() or createRef() instead. &#x27;</span> + <span class="hljs-string">&#x27;Learn more about using refs safely here: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/strict-mode-string-ref&#x27;</span>, mixedRef);
            }

            didWarnAboutStringRefs[componentName] = <span class="hljs-literal">true</span>;
          }
        }
      }

      <span class="hljs-keyword">if</span> (element.<span class="hljs-property">_owner</span>) {
        <span class="hljs-keyword">var</span> owner = element.<span class="hljs-property">_owner</span>;
        <span class="hljs-keyword">var</span> inst;

        <span class="hljs-keyword">if</span> (owner) {
          <span class="hljs-keyword">var</span> ownerFiber = owner;

          <span class="hljs-keyword">if</span> (!(ownerFiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref&quot;</span>);
            }
          }

          inst = ownerFiber.<span class="hljs-property">stateNode</span>;
        }

        <span class="hljs-keyword">if</span> (!inst) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Missing owner for string ref &quot;</span> + mixedRef + <span class="hljs-string">&quot;. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
          }
        }

        <span class="hljs-keyword">var</span> stringRef = <span class="hljs-string">&#x27;&#x27;</span> + mixedRef; <span class="hljs-comment">// Check if previous string ref matches new string ref</span>

        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> current.<span class="hljs-property">ref</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; current.<span class="hljs-property">ref</span>.<span class="hljs-property">_stringRef</span> === stringRef) {
          <span class="hljs-keyword">return</span> current.<span class="hljs-property">ref</span>;
        }

        <span class="hljs-keyword">var</span> ref = <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
          <span class="hljs-keyword">var</span> refs = inst.<span class="hljs-property">refs</span>;

          <span class="hljs-keyword">if</span> (refs === emptyRefsObject) {</pre></div></div>
            
        </li>
        
        
        <li id="section-557">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-557">&#x00a7;</a>
              </div>
              <p>This is a lazy pooled frozen object, so we need to initialize.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            refs = inst.<span class="hljs-property">refs</span> = {};
          }

          <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">delete</span> refs[stringRef];
          } <span class="hljs-keyword">else</span> {
            refs[stringRef] = value;
          }
        };

        ref.<span class="hljs-property">_stringRef</span> = stringRef;
        <span class="hljs-keyword">return</span> ref;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> mixedRef === <span class="hljs-string">&#x27;string&#x27;</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected ref to be a function, a string, an object returned by React.createRef(), or null.&quot;</span>);
          }
        }

        <span class="hljs-keyword">if</span> (!element.<span class="hljs-property">_owner</span>) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Element ref was specified as a string (&quot;</span> + mixedRef + <span class="hljs-string">&quot;) but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component&#x27;s render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.&quot;</span>);
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> mixedRef;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">throwOnInvalidObjectType</span>(<span class="hljs-params">returnFiber, newChild</span>) {
    <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;textarea&#x27;</span>) {
      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Objects are not valid as a React child (found: &quot;</span> + (<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(newChild) === <span class="hljs-string">&#x27;[object Object]&#x27;</span> ? <span class="hljs-string">&#x27;object with keys {&#x27;</span> + <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(newChild).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>) + <span class="hljs-string">&#x27;}&#x27;</span> : newChild) + <span class="hljs-string">&quot;). If you meant to render a collection of children, use an array instead.&quot;</span>);
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnOnFunctionType</span>(<span class="hljs-params">returnFiber</span>) {
    {
      <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(returnFiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>;

      <span class="hljs-keyword">if</span> (ownerHasFunctionTypeWarning[componentName]) {
        <span class="hljs-keyword">return</span>;
      }

      ownerHasFunctionTypeWarning[componentName] = <span class="hljs-literal">true</span>;

      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Functions are not valid as a React child. This may happen if &#x27;</span> + <span class="hljs-string">&#x27;you return a Component instead of &lt;Component /&gt; from render. &#x27;</span> + <span class="hljs-string">&#x27;Or maybe you meant to call this function rather than return it.&#x27;</span>);
    }
  } <span class="hljs-comment">// We avoid inlining this to avoid potential deopts from using try/catch.</span>

  <span class="hljs-comment">/** <span class="hljs-doctag">@noinline</span> */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveLazyType</span>(<span class="hljs-params">lazyComponent</span>) {
    <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-558">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-558">&#x00a7;</a>
              </div>
              <p>If we can, let’s peek at the resulting type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> payload = lazyComponent.<span class="hljs-property">_payload</span>;
      <span class="hljs-keyword">var</span> init = lazyComponent.<span class="hljs-property">_init</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">init</span>(payload);
    } <span class="hljs-keyword">catch</span> (x) {</pre></div></div>
            
        </li>
        
        
        <li id="section-559">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-559">&#x00a7;</a>
              </div>
              <p>Leave it in place and let it throw again in the begin phase.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> lazyComponent;
    }
  } <span class="hljs-comment">// This wrapper function exists because I expect to clone the code in each path</span></pre></div></div>
            
        </li>
        
        
        <li id="section-560">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-560">&#x00a7;</a>
              </div>
              <p>to be able to optimize each path individually by branching early. This needs
a compiler or we can do it manually. Helpers that don’t need this branching
live outside of this function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ChildReconciler</span>(<span class="hljs-params">shouldTrackSideEffects</span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteChild</span>(<span class="hljs-params">returnFiber, childToDelete</span>) {
      <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-561">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-561">&#x00a7;</a>
              </div>
              <p>Noop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// Deletions are added in reversed order so we add it to the front.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-562">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-562">&#x00a7;</a>
              </div>
              <p>At this point, the return fiber’s effect list is empty except for
deletions, so we can just append the deletion to the list. The remaining
effects aren’t added until the complete phase. Once we implement
resuming, this may not be true.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> last = returnFiber.<span class="hljs-property">lastEffect</span>;

      <span class="hljs-keyword">if</span> (last !== <span class="hljs-literal">null</span>) {
        last.<span class="hljs-property">nextEffect</span> = childToDelete;
        returnFiber.<span class="hljs-property">lastEffect</span> = childToDelete;
      } <span class="hljs-keyword">else</span> {
        returnFiber.<span class="hljs-property">firstEffect</span> = returnFiber.<span class="hljs-property">lastEffect</span> = childToDelete;
      }

      childToDelete.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
      childToDelete.<span class="hljs-property">flags</span> = <span class="hljs-title class_">Deletion</span>;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteRemainingChildren</span>(<span class="hljs-params">returnFiber, currentFirstChild</span>) {
      <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-563">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-563">&#x00a7;</a>
              </div>
              <p>Noop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> For the shouldClone case, this could be micro-optimized a bit by</span></pre></div></div>
            
        </li>
        
        
        <li id="section-564">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-564">&#x00a7;</a>
              </div>
              <p>assuming that after the first child we’ve already added everything.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> childToDelete = currentFirstChild;

      <span class="hljs-keyword">while</span> (childToDelete !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">deleteChild</span>(returnFiber, childToDelete);
        childToDelete = childToDelete.<span class="hljs-property">sibling</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mapRemainingChildren</span>(<span class="hljs-params">returnFiber, currentFirstChild</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-565">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-565">&#x00a7;</a>
              </div>
              <p>Add the remaining children to a temporary map so that we can find them by
keys quickly. Implicit (null) keys get added to this set with their index
instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> existingChildren = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
      <span class="hljs-keyword">var</span> existingChild = currentFirstChild;

      <span class="hljs-keyword">while</span> (existingChild !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (existingChild.<span class="hljs-property">key</span> !== <span class="hljs-literal">null</span>) {
          existingChildren.<span class="hljs-title function_">set</span>(existingChild.<span class="hljs-property">key</span>, existingChild);
        } <span class="hljs-keyword">else</span> {
          existingChildren.<span class="hljs-title function_">set</span>(existingChild.<span class="hljs-property">index</span>, existingChild);
        }

        existingChild = existingChild.<span class="hljs-property">sibling</span>;
      }

      <span class="hljs-keyword">return</span> existingChildren;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">useFiber</span>(<span class="hljs-params">fiber, pendingProps</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-566">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-566">&#x00a7;</a>
              </div>
              <p>We currently set sibling to null and index to 0 here because it is easy
to forget to do before returning it. E.g. for the single child case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> clone = <span class="hljs-title function_">createWorkInProgress</span>(fiber, pendingProps);
      clone.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;
      clone.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> clone;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">placeChild</span>(<span class="hljs-params">newFiber, lastPlacedIndex, newIndex</span>) {
      newFiber.<span class="hljs-property">index</span> = newIndex;

      <span class="hljs-keyword">if</span> (!shouldTrackSideEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-567">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-567">&#x00a7;</a>
              </div>
              <p>Noop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> lastPlacedIndex;
      }

      <span class="hljs-keyword">var</span> current = newFiber.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> oldIndex = current.<span class="hljs-property">index</span>;

        <span class="hljs-keyword">if</span> (oldIndex &lt; lastPlacedIndex) {</pre></div></div>
            
        </li>
        
        
        <li id="section-568">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-568">&#x00a7;</a>
              </div>
              <p>This is a move.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          newFiber.<span class="hljs-property">flags</span> = <span class="hljs-title class_">Placement</span>;
          <span class="hljs-keyword">return</span> lastPlacedIndex;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-569">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-569">&#x00a7;</a>
              </div>
              <p>This item can stay in place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> oldIndex;
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-570">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-570">&#x00a7;</a>
              </div>
              <p>This is an insertion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        newFiber.<span class="hljs-property">flags</span> = <span class="hljs-title class_">Placement</span>;
        <span class="hljs-keyword">return</span> lastPlacedIndex;
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">placeSingleChild</span>(<span class="hljs-params">newFiber</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-571">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-571">&#x00a7;</a>
              </div>
              <p>This is simpler for the single child case. We only need to do a
placement for inserting new children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (shouldTrackSideEffects &amp;&amp; newFiber.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span>) {
        newFiber.<span class="hljs-property">flags</span> = <span class="hljs-title class_">Placement</span>;
      }

      <span class="hljs-keyword">return</span> newFiber;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTextNode</span>(<span class="hljs-params">returnFiber, current, textContent, lanes</span>) {
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostText</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-572">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-572">&#x00a7;</a>
              </div>
              <p>Insert</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromText</span>(textContent, returnFiber.<span class="hljs-property">mode</span>, lanes);
        created.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> created;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-573">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-573">&#x00a7;</a>
              </div>
              <p>Update</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> existing = <span class="hljs-title function_">useFiber</span>(current, textContent);
        existing.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> existing;
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateElement</span>(<span class="hljs-params">returnFiber, current, element, lanes</span>) {
      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">elementType</span> === element.<span class="hljs-property">type</span> || ( <span class="hljs-comment">// Keep this check inline so it only runs on the false path:</span>
          <span class="hljs-title function_">isCompatibleFamilyForHotReloading</span>(current, element))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-574">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-574">&#x00a7;</a>
              </div>
              <p>Move based on index</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> existing = <span class="hljs-title function_">useFiber</span>(current, element.<span class="hljs-property">props</span>);
          existing.<span class="hljs-property">ref</span> = <span class="hljs-title function_">coerceRef</span>(returnFiber, current, element);
          existing.<span class="hljs-property">return</span> = returnFiber;

          {
            existing.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
            existing.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
          }

          <span class="hljs-keyword">return</span> existing;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current.<span class="hljs-property">tag</span> === <span class="hljs-title class_">Block</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-575">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-575">&#x00a7;</a>
              </div>
              <p>The new Block might not be initialized yet. We need to initialize
it in case initializing it turns out it would match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> type = element.<span class="hljs-property">type</span>;

          <span class="hljs-keyword">if</span> (type.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_LAZY_TYPE</span>) {
            type = <span class="hljs-title function_">resolveLazyType</span>(type);
          }

          <span class="hljs-keyword">if</span> (type.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_BLOCK_TYPE</span> &amp;&amp; type.<span class="hljs-property">_render</span> === current.<span class="hljs-property">type</span>.<span class="hljs-property">_render</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-576">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-576">&#x00a7;</a>
              </div>
              <p>Same as above but also update the .type field.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> _existing = <span class="hljs-title function_">useFiber</span>(current, element.<span class="hljs-property">props</span>);

            _existing.<span class="hljs-property">return</span> = returnFiber;
            _existing.<span class="hljs-property">type</span> = type;

            {
              _existing.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
              _existing.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
            }

            <span class="hljs-keyword">return</span> _existing;
          }
        }
      } <span class="hljs-comment">// Insert</span>


      <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromElement</span>(element, returnFiber.<span class="hljs-property">mode</span>, lanes);
      created.<span class="hljs-property">ref</span> = <span class="hljs-title function_">coerceRef</span>(returnFiber, current, element);
      created.<span class="hljs-property">return</span> = returnFiber;
      <span class="hljs-keyword">return</span> created;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updatePortal</span>(<span class="hljs-params">returnFiber, current, portal, lanes</span>) {
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostPortal</span> || current.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span> !== portal.<span class="hljs-property">containerInfo</span> || current.<span class="hljs-property">stateNode</span>.<span class="hljs-property">implementation</span> !== portal.<span class="hljs-property">implementation</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-577">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-577">&#x00a7;</a>
              </div>
              <p>Insert</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromPortal</span>(portal, returnFiber.<span class="hljs-property">mode</span>, lanes);
        created.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> created;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-578">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-578">&#x00a7;</a>
              </div>
              <p>Update</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> existing = <span class="hljs-title function_">useFiber</span>(current, portal.<span class="hljs-property">children</span> || []);
        existing.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> existing;
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFragment</span>(<span class="hljs-params">returnFiber, current, fragment, lanes, key</span>) {
      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">Fragment</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-579">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-579">&#x00a7;</a>
              </div>
              <p>Insert</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromFragment</span>(fragment, returnFiber.<span class="hljs-property">mode</span>, lanes, key);
        created.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> created;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-580">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-580">&#x00a7;</a>
              </div>
              <p>Update</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> existing = <span class="hljs-title function_">useFiber</span>(current, fragment);
        existing.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> existing;
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">createChild</span>(<span class="hljs-params">returnFiber, newChild, lanes</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;number&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-581">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-581">&#x00a7;</a>
              </div>
              <p>Text nodes don’t have keys. If the previous node is implicitly keyed
we can continue to replace it without aborting even if it is not a text
node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromText</span>(<span class="hljs-string">&#x27;&#x27;</span> + newChild, returnFiber.<span class="hljs-property">mode</span>, lanes);
        created.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> created;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">switch</span> (newChild.<span class="hljs-property">$$typeof</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>:
            {
              <span class="hljs-keyword">var</span> _created = <span class="hljs-title function_">createFiberFromElement</span>(newChild, returnFiber.<span class="hljs-property">mode</span>, lanes);

              _created.<span class="hljs-property">ref</span> = <span class="hljs-title function_">coerceRef</span>(returnFiber, <span class="hljs-literal">null</span>, newChild);
              _created.<span class="hljs-property">return</span> = returnFiber;
              <span class="hljs-keyword">return</span> _created;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
            {
              <span class="hljs-keyword">var</span> _created2 = <span class="hljs-title function_">createFiberFromPortal</span>(newChild, returnFiber.<span class="hljs-property">mode</span>, lanes);

              _created2.<span class="hljs-property">return</span> = returnFiber;
              <span class="hljs-keyword">return</span> _created2;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
            {
              {
                <span class="hljs-keyword">var</span> payload = newChild.<span class="hljs-property">_payload</span>;
                <span class="hljs-keyword">var</span> init = newChild.<span class="hljs-property">_init</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">createChild</span>(returnFiber, <span class="hljs-title function_">init</span>(payload), lanes);
              }
            }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray$1</span>(newChild) || <span class="hljs-title function_">getIteratorFn</span>(newChild)) {
          <span class="hljs-keyword">var</span> _created3 = <span class="hljs-title function_">createFiberFromFragment</span>(newChild, returnFiber.<span class="hljs-property">mode</span>, lanes, <span class="hljs-literal">null</span>);

          _created3.<span class="hljs-property">return</span> = returnFiber;
          <span class="hljs-keyword">return</span> _created3;
        }

        <span class="hljs-title function_">throwOnInvalidObjectType</span>(returnFiber, newChild);
      }

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">warnOnFunctionType</span>(returnFiber);
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSlot</span>(<span class="hljs-params">returnFiber, oldFiber, newChild, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-582">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-582">&#x00a7;</a>
              </div>
              <p>Update the fiber if the keys match, otherwise return null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> key = oldFiber !== <span class="hljs-literal">null</span> ? oldFiber.<span class="hljs-property">key</span> : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;number&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-583">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-583">&#x00a7;</a>
              </div>
              <p>Text nodes don’t have keys. If the previous node is implicitly keyed
we can continue to replace it without aborting even if it is not a text
node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateTextNode</span>(returnFiber, oldFiber, <span class="hljs-string">&#x27;&#x27;</span> + newChild, lanes);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">switch</span> (newChild.<span class="hljs-property">$$typeof</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>:
            {
              <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">key</span> === key) {
                <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span>) {
                  <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFragment</span>(returnFiber, oldFiber, newChild.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>, lanes, key);
                }

                <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateElement</span>(returnFiber, oldFiber, newChild, lanes);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
            }

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
            {
              <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">key</span> === key) {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">updatePortal</span>(returnFiber, oldFiber, newChild, lanes);
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
            }

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
            {
              {
                <span class="hljs-keyword">var</span> payload = newChild.<span class="hljs-property">_payload</span>;
                <span class="hljs-keyword">var</span> init = newChild.<span class="hljs-property">_init</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSlot</span>(returnFiber, oldFiber, <span class="hljs-title function_">init</span>(payload), lanes);
              }
            }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray$1</span>(newChild) || <span class="hljs-title function_">getIteratorFn</span>(newChild)) {
          <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFragment</span>(returnFiber, oldFiber, newChild, lanes, <span class="hljs-literal">null</span>);
        }

        <span class="hljs-title function_">throwOnInvalidObjectType</span>(returnFiber, newChild);
      }

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">warnOnFunctionType</span>(returnFiber);
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFromMap</span>(<span class="hljs-params">existingChildren, returnFiber, newIdx, newChild, lanes</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;number&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-584">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-584">&#x00a7;</a>
              </div>
              <p>Text nodes don’t have keys, so we neither have to check the old nor
new node for the key. If both are text nodes, they match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> matchedFiber = existingChildren.<span class="hljs-title function_">get</span>(newIdx) || <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateTextNode</span>(returnFiber, matchedFiber, <span class="hljs-string">&#x27;&#x27;</span> + newChild, lanes);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">switch</span> (newChild.<span class="hljs-property">$$typeof</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>:
            {
              <span class="hljs-keyword">var</span> _matchedFiber = existingChildren.<span class="hljs-title function_">get</span>(newChild.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span> ? newIdx : newChild.<span class="hljs-property">key</span>) || <span class="hljs-literal">null</span>;

              <span class="hljs-keyword">if</span> (newChild.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFragment</span>(returnFiber, _matchedFiber, newChild.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>, lanes, newChild.<span class="hljs-property">key</span>);
              }

              <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateElement</span>(returnFiber, _matchedFiber, newChild, lanes);
            }

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
            {
              <span class="hljs-keyword">var</span> _matchedFiber2 = existingChildren.<span class="hljs-title function_">get</span>(newChild.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span> ? newIdx : newChild.<span class="hljs-property">key</span>) || <span class="hljs-literal">null</span>;

              <span class="hljs-keyword">return</span> <span class="hljs-title function_">updatePortal</span>(returnFiber, _matchedFiber2, newChild, lanes);
            }

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
            {
              <span class="hljs-keyword">var</span> payload = newChild.<span class="hljs-property">_payload</span>;
              <span class="hljs-keyword">var</span> init = newChild.<span class="hljs-property">_init</span>;
              <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFromMap</span>(existingChildren, returnFiber, newIdx, <span class="hljs-title function_">init</span>(payload), lanes);
            }

        }

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray$1</span>(newChild) || <span class="hljs-title function_">getIteratorFn</span>(newChild)) {
          <span class="hljs-keyword">var</span> _matchedFiber3 = existingChildren.<span class="hljs-title function_">get</span>(newIdx) || <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFragment</span>(returnFiber, _matchedFiber3, newChild, lanes, <span class="hljs-literal">null</span>);
        }

        <span class="hljs-title function_">throwOnInvalidObjectType</span>(returnFiber, newChild);
      }

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">warnOnFunctionType</span>(returnFiber);
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-comment">/**
     * Warns if there is a duplicate or missing key
     */</span>


    <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnOnInvalidKey</span>(<span class="hljs-params">child, knownKeys, returnFiber</span>) {
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> child !== <span class="hljs-string">&#x27;object&#x27;</span> || child === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">return</span> knownKeys;
        }

        <span class="hljs-keyword">switch</span> (child.<span class="hljs-property">$$typeof</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
            <span class="hljs-title function_">warnForMissingKey</span>(child, returnFiber);
            <span class="hljs-keyword">var</span> key = child.<span class="hljs-property">key</span>;

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key !== <span class="hljs-string">&#x27;string&#x27;</span>) {
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">if</span> (knownKeys === <span class="hljs-literal">null</span>) {
              knownKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
              knownKeys.<span class="hljs-title function_">add</span>(key);
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">if</span> (!knownKeys.<span class="hljs-title function_">has</span>(key)) {
              knownKeys.<span class="hljs-title function_">add</span>(key);
              <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Encountered two children with the same key, `%s`. &#x27;</span> + <span class="hljs-string">&#x27;Keys should be unique so that components maintain their identity &#x27;</span> + <span class="hljs-string">&#x27;across updates. Non-unique keys may cause children to be &#x27;</span> + <span class="hljs-string">&#x27;duplicated and/or omitted — the behavior is unsupported and &#x27;</span> + <span class="hljs-string">&#x27;could change in a future version.&#x27;</span>, key);

            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
            {
              <span class="hljs-keyword">var</span> payload = child.<span class="hljs-property">_payload</span>;
              <span class="hljs-keyword">var</span> init = child.<span class="hljs-property">_init</span>;
              <span class="hljs-title function_">warnOnInvalidKey</span>(<span class="hljs-title function_">init</span>(payload), knownKeys, returnFiber);
              <span class="hljs-keyword">break</span>;
            }
        }
      }

      <span class="hljs-keyword">return</span> knownKeys;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildrenArray</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChildren, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-585">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-585">&#x00a7;</a>
              </div>
              <p>This algorithm can’t optimize by searching from both ends since we
don’t have backpointers on fibers. I’m trying to see how far we can get
with that model. If it ends up not being worth the tradeoffs, we can
add it later.
Even with a two ended optimization, we’d want to optimize for the case
where there are few changes and brute force the comparison instead of
going for the Map. It’d like to explore hitting that path first in
forward-only mode and only go for the Map once we notice that we need
lots of look ahead. This doesn’t handle reversal as well as two ended
search but that’s unusual. Besides, for the two ended optimization to
work on Iterables, we’d need to copy the whole set.
In this first iteration, we’ll just live with hitting the bad case
(adding everything to a Map) in for every insert/move.
If you change this code, also update reconcileChildrenIterator() which
uses the same algorithm.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {</pre></div></div>
            
        </li>
        
        
        <li id="section-586">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-586">&#x00a7;</a>
              </div>
              <p>First, validate keys.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> knownKeys = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; newChildren.<span class="hljs-property">length</span>; i++) {
          <span class="hljs-keyword">var</span> child = newChildren[i];
          knownKeys = <span class="hljs-title function_">warnOnInvalidKey</span>(child, knownKeys, returnFiber);
        }
      }

      <span class="hljs-keyword">var</span> resultingFirstChild = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> previousNewFiber = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> oldFiber = currentFirstChild;
      <span class="hljs-keyword">var</span> lastPlacedIndex = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> newIdx = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> nextOldFiber = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) {
        <span class="hljs-keyword">if</span> (oldFiber.<span class="hljs-property">index</span> &gt; newIdx) {
          nextOldFiber = oldFiber;
          oldFiber = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
          nextOldFiber = oldFiber.<span class="hljs-property">sibling</span>;
        }

        <span class="hljs-keyword">var</span> newFiber = <span class="hljs-title function_">updateSlot</span>(returnFiber, oldFiber, newChildren[newIdx], lanes);

        <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-587">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-587">&#x00a7;</a>
              </div>
              <p>TODO: This breaks on empty slots like null children. That’s
unfortunate because it triggers the slow path all the time. We need
a better way to communicate whether this was a miss or null,
boolean, undefined, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {
            oldFiber = nextOldFiber;
          }

          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
          <span class="hljs-keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-588">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-588">&#x00a7;</a>
              </div>
              <p>We matched the slot, but we didn’t reuse the existing fiber, so we
need to delete the existing child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title function_">deleteChild</span>(returnFiber, oldFiber);
          }
        }

        lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

        <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-589">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-589">&#x00a7;</a>
              </div>
              <p>TODO: Move out of the loop. This only happens for the first run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          resultingFirstChild = newFiber;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-590">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-590">&#x00a7;</a>
              </div>
              <p>TODO: Defer siblings if we’re not at the right index for this slot.
I.e. if we had null values before, then we want to defer this
for each null value. However, we also don’t want to call updateSlot
with the previous one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;
        }

        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      <span class="hljs-keyword">if</span> (newIdx === newChildren.<span class="hljs-property">length</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-591">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-591">&#x00a7;</a>
              </div>
              <p>We’ve reached the end of the new children. We can delete the rest.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);
        <span class="hljs-keyword">return</span> resultingFirstChild;
      }

      <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-592">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-592">&#x00a7;</a>
              </div>
              <p>If we don’t have any more existing children we can choose a fast path
since the rest will all be insertions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) {
          <span class="hljs-keyword">var</span> _newFiber = <span class="hljs-title function_">createChild</span>(returnFiber, newChildren[newIdx], lanes);

          <span class="hljs-keyword">if</span> (_newFiber === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">continue</span>;
          }

          lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(_newFiber, lastPlacedIndex, newIdx);

          <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-593">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-593">&#x00a7;</a>
              </div>
              <p>TODO: Move out of the loop. This only happens for the first run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            resultingFirstChild = _newFiber;
          } <span class="hljs-keyword">else</span> {
            previousNewFiber.<span class="hljs-property">sibling</span> = _newFiber;
          }

          previousNewFiber = _newFiber;
        }

        <span class="hljs-keyword">return</span> resultingFirstChild;
      } <span class="hljs-comment">// Add all children to a key map for quick lookups.</span>


      <span class="hljs-keyword">var</span> existingChildren = <span class="hljs-title function_">mapRemainingChildren</span>(returnFiber, oldFiber); <span class="hljs-comment">// Keep scanning and use the map to restore deleted items as moves.</span>

      <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.<span class="hljs-property">length</span>; newIdx++) {
        <span class="hljs-keyword">var</span> _newFiber2 = <span class="hljs-title function_">updateFromMap</span>(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);

        <span class="hljs-keyword">if</span> (_newFiber2 !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
            <span class="hljs-keyword">if</span> (_newFiber2.<span class="hljs-property">alternate</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-594">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-594">&#x00a7;</a>
              </div>
              <p>The new fiber is a work in progress, but if there exists a
current, that means that we reused the fiber. We need to delete
it from the child list so that we don’t add it to the deletion
list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              existingChildren.<span class="hljs-title function_">delete</span>(_newFiber2.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span> ? newIdx : _newFiber2.<span class="hljs-property">key</span>);
            }
          }

          lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(_newFiber2, lastPlacedIndex, newIdx);

          <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
            resultingFirstChild = _newFiber2;
          } <span class="hljs-keyword">else</span> {
            previousNewFiber.<span class="hljs-property">sibling</span> = _newFiber2;
          }

          previousNewFiber = _newFiber2;
        }
      }

      <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-595">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-595">&#x00a7;</a>
              </div>
              <p>Any existing children that weren’t consumed above were deleted. We need
to add them to the deletion list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        existingChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">deleteChild</span>(returnFiber, child);
        });
      }

      <span class="hljs-keyword">return</span> resultingFirstChild;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildrenIterator</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChildrenIterable, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-596">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-596">&#x00a7;</a>
              </div>
              <p>This is the same implementation as reconcileChildrenArray(),
but using the iterator instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> iteratorFn = <span class="hljs-title function_">getIteratorFn</span>(newChildrenIterable);

      <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> iteratorFn === <span class="hljs-string">&#x27;function&#x27;</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-597">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-597">&#x00a7;</a>
              </div>
              <p>We don’t support rendering Generators because it’s a mutation.
See <a href="https://github.com/facebook/react/issues/12995">https://github.com/facebook/react/issues/12995</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-comment">// $FlowFixMe Flow doesn&#x27;t know about toStringTag</span>
          newChildrenIterable[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toStringTag</span>] === <span class="hljs-string">&#x27;Generator&#x27;</span>) {
          <span class="hljs-keyword">if</span> (!didWarnAboutGenerators) {
            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Using Generators as children is unsupported and will likely yield &#x27;</span> + <span class="hljs-string">&#x27;unexpected results because enumerating a generator mutates it. &#x27;</span> + <span class="hljs-string">&#x27;You may convert it to an array with `Array.from()` or the &#x27;</span> + <span class="hljs-string">&#x27;`[...spread]` operator before rendering. Keep in mind &#x27;</span> + <span class="hljs-string">&#x27;you might need to polyfill these features for older browsers.&#x27;</span>);
          }

          didWarnAboutGenerators = <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// Warn about using Maps as children</span>


        <span class="hljs-keyword">if</span> (newChildrenIterable.<span class="hljs-property">entries</span> === iteratorFn) {
          <span class="hljs-keyword">if</span> (!didWarnAboutMaps) {
            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Using Maps as children is not supported. &#x27;</span> + <span class="hljs-string">&#x27;Use an array of keyed ReactElements instead.&#x27;</span>);
          }

          didWarnAboutMaps = <span class="hljs-literal">true</span>;
        } <span class="hljs-comment">// First, validate keys.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-598">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-598">&#x00a7;</a>
              </div>
              <p>We’ll get a different iterator later for the main pass.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-keyword">var</span> _newChildren = iteratorFn.<span class="hljs-title function_">call</span>(newChildrenIterable);

        <span class="hljs-keyword">if</span> (_newChildren) {
          <span class="hljs-keyword">var</span> knownKeys = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">var</span> _step = _newChildren.<span class="hljs-title function_">next</span>();

          <span class="hljs-keyword">for</span> (; !_step.<span class="hljs-property">done</span>; _step = _newChildren.<span class="hljs-title function_">next</span>()) {
            <span class="hljs-keyword">var</span> child = _step.<span class="hljs-property">value</span>;
            knownKeys = <span class="hljs-title function_">warnOnInvalidKey</span>(child, knownKeys, returnFiber);
          }
        }
      }

      <span class="hljs-keyword">var</span> newChildren = iteratorFn.<span class="hljs-title function_">call</span>(newChildrenIterable);

      <span class="hljs-keyword">if</span> (!(newChildren != <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;An iterable object provided no iterator.&quot;</span>);
        }
      }

      <span class="hljs-keyword">var</span> resultingFirstChild = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> previousNewFiber = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> oldFiber = currentFirstChild;
      <span class="hljs-keyword">var</span> lastPlacedIndex = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> newIdx = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> nextOldFiber = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> step = newChildren.<span class="hljs-title function_">next</span>();

      <span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; !step.<span class="hljs-property">done</span>; newIdx++, step = newChildren.<span class="hljs-title function_">next</span>()) {
        <span class="hljs-keyword">if</span> (oldFiber.<span class="hljs-property">index</span> &gt; newIdx) {
          nextOldFiber = oldFiber;
          oldFiber = <span class="hljs-literal">null</span>;
        } <span class="hljs-keyword">else</span> {
          nextOldFiber = oldFiber.<span class="hljs-property">sibling</span>;
        }

        <span class="hljs-keyword">var</span> newFiber = <span class="hljs-title function_">updateSlot</span>(returnFiber, oldFiber, step.<span class="hljs-property">value</span>, lanes);

        <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-599">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-599">&#x00a7;</a>
              </div>
              <p>TODO: This breaks on empty slots like null children. That’s
unfortunate because it triggers the slow path all the time. We need
a better way to communicate whether this was a miss or null,
boolean, undefined, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {
            oldFiber = nextOldFiber;
          }

          <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
          <span class="hljs-keyword">if</span> (oldFiber &amp;&amp; newFiber.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-600">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-600">&#x00a7;</a>
              </div>
              <p>We matched the slot, but we didn’t reuse the existing fiber, so we
need to delete the existing child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title function_">deleteChild</span>(returnFiber, oldFiber);
          }
        }

        lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(newFiber, lastPlacedIndex, newIdx);

        <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-601">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-601">&#x00a7;</a>
              </div>
              <p>TODO: Move out of the loop. This only happens for the first run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          resultingFirstChild = newFiber;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-602">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-602">&#x00a7;</a>
              </div>
              <p>TODO: Defer siblings if we’re not at the right index for this slot.
I.e. if we had null values before, then we want to defer this
for each null value. However, we also don’t want to call updateSlot
with the previous one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          previousNewFiber.<span class="hljs-property">sibling</span> = newFiber;
        }

        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }

      <span class="hljs-keyword">if</span> (step.<span class="hljs-property">done</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-603">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-603">&#x00a7;</a>
              </div>
              <p>We’ve reached the end of the new children. We can delete the rest.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, oldFiber);
        <span class="hljs-keyword">return</span> resultingFirstChild;
      }

      <span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-604">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-604">&#x00a7;</a>
              </div>
              <p>If we don’t have any more existing children we can choose a fast path
since the rest will all be insertions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">for</span> (; !step.<span class="hljs-property">done</span>; newIdx++, step = newChildren.<span class="hljs-title function_">next</span>()) {
          <span class="hljs-keyword">var</span> _newFiber3 = <span class="hljs-title function_">createChild</span>(returnFiber, step.<span class="hljs-property">value</span>, lanes);

          <span class="hljs-keyword">if</span> (_newFiber3 === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">continue</span>;
          }

          lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(_newFiber3, lastPlacedIndex, newIdx);

          <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-605">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-605">&#x00a7;</a>
              </div>
              <p>TODO: Move out of the loop. This only happens for the first run.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            resultingFirstChild = _newFiber3;
          } <span class="hljs-keyword">else</span> {
            previousNewFiber.<span class="hljs-property">sibling</span> = _newFiber3;
          }

          previousNewFiber = _newFiber3;
        }

        <span class="hljs-keyword">return</span> resultingFirstChild;
      } <span class="hljs-comment">// Add all children to a key map for quick lookups.</span>


      <span class="hljs-keyword">var</span> existingChildren = <span class="hljs-title function_">mapRemainingChildren</span>(returnFiber, oldFiber); <span class="hljs-comment">// Keep scanning and use the map to restore deleted items as moves.</span>

      <span class="hljs-keyword">for</span> (; !step.<span class="hljs-property">done</span>; newIdx++, step = newChildren.<span class="hljs-title function_">next</span>()) {
        <span class="hljs-keyword">var</span> _newFiber4 = <span class="hljs-title function_">updateFromMap</span>(existingChildren, returnFiber, newIdx, step.<span class="hljs-property">value</span>, lanes);

        <span class="hljs-keyword">if</span> (_newFiber4 !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {
            <span class="hljs-keyword">if</span> (_newFiber4.<span class="hljs-property">alternate</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-606">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-606">&#x00a7;</a>
              </div>
              <p>The new fiber is a work in progress, but if there exists a
current, that means that we reused the fiber. We need to delete
it from the child list so that we don’t add it to the deletion
list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              existingChildren.<span class="hljs-title function_">delete</span>(_newFiber4.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span> ? newIdx : _newFiber4.<span class="hljs-property">key</span>);
            }
          }

          lastPlacedIndex = <span class="hljs-title function_">placeChild</span>(_newFiber4, lastPlacedIndex, newIdx);

          <span class="hljs-keyword">if</span> (previousNewFiber === <span class="hljs-literal">null</span>) {
            resultingFirstChild = _newFiber4;
          } <span class="hljs-keyword">else</span> {
            previousNewFiber.<span class="hljs-property">sibling</span> = _newFiber4;
          }

          previousNewFiber = _newFiber4;
        }
      }

      <span class="hljs-keyword">if</span> (shouldTrackSideEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-607">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-607">&#x00a7;</a>
              </div>
              <p>Any existing children that weren’t consumed above were deleted. We need
to add them to the deletion list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        existingChildren.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">deleteChild</span>(returnFiber, child);
        });
      }

      <span class="hljs-keyword">return</span> resultingFirstChild;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileSingleTextNode</span>(<span class="hljs-params">returnFiber, currentFirstChild, textContent, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-608">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-608">&#x00a7;</a>
              </div>
              <p>There’s no need to check for keys on text nodes since we don’t have a
way to define them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (currentFirstChild !== <span class="hljs-literal">null</span> &amp;&amp; currentFirstChild.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-609">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-609">&#x00a7;</a>
              </div>
              <p>We already have an existing node so let’s just update it and delete
the rest.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild.<span class="hljs-property">sibling</span>);
        <span class="hljs-keyword">var</span> existing = <span class="hljs-title function_">useFiber</span>(currentFirstChild, textContent);
        existing.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> existing;
      } <span class="hljs-comment">// The existing first child is not a text node so we need to create one</span></pre></div></div>
            
        </li>
        
        
        <li id="section-610">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-610">&#x00a7;</a>
              </div>
              <p>and delete the existing ones.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);
      <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromText</span>(textContent, returnFiber.<span class="hljs-property">mode</span>, lanes);
      created.<span class="hljs-property">return</span> = returnFiber;
      <span class="hljs-keyword">return</span> created;
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileSingleElement</span>(<span class="hljs-params">returnFiber, currentFirstChild, element, lanes</span>) {
      <span class="hljs-keyword">var</span> key = element.<span class="hljs-property">key</span>;
      <span class="hljs-keyword">var</span> child = currentFirstChild;

      <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-611">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-611">&#x00a7;</a>
              </div>
              <p>TODO: If key === null and child.key === null, then this only applies to
the first item in the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">key</span> === key) {
          <span class="hljs-keyword">switch</span> (child.<span class="hljs-property">tag</span>) {
            <span class="hljs-keyword">case</span> <span class="hljs-title class_">Fragment</span>:
              {
                <span class="hljs-keyword">if</span> (element.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span>) {
                  <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="hljs-property">sibling</span>);
                  <span class="hljs-keyword">var</span> existing = <span class="hljs-title function_">useFiber</span>(child, element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>);
                  existing.<span class="hljs-property">return</span> = returnFiber;

                  {
                    existing.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
                    existing.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
                  }

                  <span class="hljs-keyword">return</span> existing;
                }

                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
              {
                <span class="hljs-keyword">var</span> type = element.<span class="hljs-property">type</span>;

                <span class="hljs-keyword">if</span> (type.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_LAZY_TYPE</span>) {
                  type = <span class="hljs-title function_">resolveLazyType</span>(type);
                }

                <span class="hljs-keyword">if</span> (type.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_BLOCK_TYPE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-612">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-612">&#x00a7;</a>
              </div>
              <p>The new Block might not be initialized yet. We need to initialize
it in case initializing it turns out it would match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">if</span> (type.<span class="hljs-property">_render</span> === child.<span class="hljs-property">type</span>.<span class="hljs-property">_render</span>) {
                    <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="hljs-property">sibling</span>);

                    <span class="hljs-keyword">var</span> _existing2 = <span class="hljs-title function_">useFiber</span>(child, element.<span class="hljs-property">props</span>);

                    _existing2.<span class="hljs-property">type</span> = type;
                    _existing2.<span class="hljs-property">return</span> = returnFiber;

                    {
                      _existing2.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
                      _existing2.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
                    }

                    <span class="hljs-keyword">return</span> _existing2;
                  }
                }
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-613">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-613">&#x00a7;</a>
              </div>
              <p>We intentionally fallthrough here if enableBlocksAPI is not on.
eslint-disable-next-lined no-fallthrough</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-attr">default</span>:
              {
                <span class="hljs-keyword">if</span> (child.<span class="hljs-property">elementType</span> === element.<span class="hljs-property">type</span> || ( <span class="hljs-comment">// Keep this check inline so it only runs on the false path:</span>
                  <span class="hljs-title function_">isCompatibleFamilyForHotReloading</span>(child, element))) {
                  <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="hljs-property">sibling</span>);

                  <span class="hljs-keyword">var</span> _existing3 = <span class="hljs-title function_">useFiber</span>(child, element.<span class="hljs-property">props</span>);

                  _existing3.<span class="hljs-property">ref</span> = <span class="hljs-title function_">coerceRef</span>(returnFiber, child, element);
                  _existing3.<span class="hljs-property">return</span> = returnFiber;

                  {
                    _existing3.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
                    _existing3.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
                  }

                  <span class="hljs-keyword">return</span> _existing3;
                }

                <span class="hljs-keyword">break</span>;
              }
          } <span class="hljs-comment">// Didn&#x27;t match.</span>


          <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child);
          <span class="hljs-keyword">break</span>;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">deleteChild</span>(returnFiber, child);
        }

        child = child.<span class="hljs-property">sibling</span>;
      }

      <span class="hljs-keyword">if</span> (element.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span>) {
        <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromFragment</span>(element.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>, returnFiber.<span class="hljs-property">mode</span>, lanes, element.<span class="hljs-property">key</span>);
        created.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> created;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> _created4 = <span class="hljs-title function_">createFiberFromElement</span>(element, returnFiber.<span class="hljs-property">mode</span>, lanes);

        _created4.<span class="hljs-property">ref</span> = <span class="hljs-title function_">coerceRef</span>(returnFiber, currentFirstChild, element);
        _created4.<span class="hljs-property">return</span> = returnFiber;
        <span class="hljs-keyword">return</span> _created4;
      }
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileSinglePortal</span>(<span class="hljs-params">returnFiber, currentFirstChild, portal, lanes</span>) {
      <span class="hljs-keyword">var</span> key = portal.<span class="hljs-property">key</span>;
      <span class="hljs-keyword">var</span> child = currentFirstChild;

      <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-614">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-614">&#x00a7;</a>
              </div>
              <p>TODO: If key === null and child.key === null, then this only applies to
the first item in the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (child.<span class="hljs-property">key</span> === key) {
          <span class="hljs-keyword">if</span> (child.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostPortal</span> &amp;&amp; child.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span> === portal.<span class="hljs-property">containerInfo</span> &amp;&amp; child.<span class="hljs-property">stateNode</span>.<span class="hljs-property">implementation</span> === portal.<span class="hljs-property">implementation</span>) {
            <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child.<span class="hljs-property">sibling</span>);
            <span class="hljs-keyword">var</span> existing = <span class="hljs-title function_">useFiber</span>(child, portal.<span class="hljs-property">children</span> || []);
            existing.<span class="hljs-property">return</span> = returnFiber;
            <span class="hljs-keyword">return</span> existing;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, child);
            <span class="hljs-keyword">break</span>;
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">deleteChild</span>(returnFiber, child);
        }

        child = child.<span class="hljs-property">sibling</span>;
      }

      <span class="hljs-keyword">var</span> created = <span class="hljs-title function_">createFiberFromPortal</span>(portal, returnFiber.<span class="hljs-property">mode</span>, lanes);
      created.<span class="hljs-property">return</span> = returnFiber;
      <span class="hljs-keyword">return</span> created;
    } <span class="hljs-comment">// This API will tag the children with the side-effect of the reconciliation</span></pre></div></div>
            
        </li>
        
        
        <li id="section-615">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-615">&#x00a7;</a>
              </div>
              <p>itself. They will be added to the side-effect list as we pass through the
children and the parent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildFibers</span>(<span class="hljs-params">returnFiber, currentFirstChild, newChild, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-616">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-616">&#x00a7;</a>
              </div>
              <p>This function is not recursive.
If the top level item is an array, we treat it as a set of children,
not as a fragment. Nested arrays on the other hand will be treated as
fragment nodes. Recursion happens at the normal flow.
Handle top level unkeyed fragments as if they were arrays.
This leads to an ambiguity between &lt;&gt;{[…]}&lt;/&gt; and &lt;&gt;…&lt;/&gt;.
We treat the ambiguous cases above the same.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> isUnkeyedTopLevelFragment = <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span> &amp;&amp; newChild.<span class="hljs-property">type</span> === <span class="hljs-variable constant_">REACT_FRAGMENT_TYPE</span> &amp;&amp; newChild.<span class="hljs-property">key</span> === <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (isUnkeyedTopLevelFragment) {
        newChild = newChild.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>;
      } <span class="hljs-comment">// Handle object types</span>


      <span class="hljs-keyword">var</span> isObject = <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (isObject) {
        <span class="hljs-keyword">switch</span> (newChild.<span class="hljs-property">$$typeof</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_ELEMENT_TYPE</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">placeSingleChild</span>(<span class="hljs-title function_">reconcileSingleElement</span>(returnFiber, currentFirstChild, newChild, lanes));

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PORTAL_TYPE</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">placeSingleChild</span>(<span class="hljs-title function_">reconcileSinglePortal</span>(returnFiber, currentFirstChild, newChild, lanes));

          <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
            {
              <span class="hljs-keyword">var</span> payload = newChild.<span class="hljs-property">_payload</span>;
              <span class="hljs-keyword">var</span> init = newChild.<span class="hljs-property">_init</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This function is supposed to be non-recursive.</span>

              <span class="hljs-keyword">return</span> <span class="hljs-title function_">reconcileChildFibers</span>(returnFiber, currentFirstChild, <span class="hljs-title function_">init</span>(payload), lanes);
            }

        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;number&#x27;</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">placeSingleChild</span>(<span class="hljs-title function_">reconcileSingleTextNode</span>(returnFiber, currentFirstChild, <span class="hljs-string">&#x27;&#x27;</span> + newChild, lanes));
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isArray$1</span>(newChild)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reconcileChildrenArray</span>(returnFiber, currentFirstChild, newChild, lanes);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIteratorFn</span>(newChild)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reconcileChildrenIterator</span>(returnFiber, currentFirstChild, newChild, lanes);
      }

      <span class="hljs-keyword">if</span> (isObject) {
        <span class="hljs-title function_">throwOnInvalidObjectType</span>(returnFiber, newChild);
      }

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">warnOnFunctionType</span>(returnFiber);
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; !isUnkeyedTopLevelFragment) {</pre></div></div>
            
        </li>
        
        
        <li id="section-617">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-617">&#x00a7;</a>
              </div>
              <p>If the new child is undefined, and the return fiber is a composite
component, throw an error. If Fiber return types are disabled,
we already threw above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">switch</span> (returnFiber.<span class="hljs-property">tag</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
            {
              {
                <span class="hljs-keyword">var</span> instance = returnFiber.<span class="hljs-property">stateNode</span>;

                <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">render</span>.<span class="hljs-property">_isMockFunction</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-618">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-618">&#x00a7;</a>
              </div>
              <p>We allow auto-mocks to proceed as if they’re returning null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">break</span>;
                }
              }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-619">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-619">&#x00a7;</a>
              </div>
              <p>Intentionally fall through to the next case, which handles both
functions and classes
eslint-disable-next-lined no-fallthrough</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
            {
              {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>((<span class="hljs-title function_">getComponentName</span>(returnFiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>) + <span class="hljs-string">&quot;(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.&quot;</span>);
                }
              }
            }
        }
      } <span class="hljs-comment">// Remaining cases are all treated as empty.</span>


      <span class="hljs-keyword">return</span> <span class="hljs-title function_">deleteRemainingChildren</span>(returnFiber, currentFirstChild);
    }

    <span class="hljs-keyword">return</span> reconcileChildFibers;
  }

  <span class="hljs-keyword">var</span> reconcileChildFibers = <span class="hljs-title class_">ChildReconciler</span>(<span class="hljs-literal">true</span>);
  <span class="hljs-keyword">var</span> mountChildFibers = <span class="hljs-title class_">ChildReconciler</span>(<span class="hljs-literal">false</span>);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cloneChildFibers</span>(<span class="hljs-params">current, workInProgress</span>) {
    <span class="hljs-keyword">if</span> (!(current === <span class="hljs-literal">null</span> || workInProgress.<span class="hljs-property">child</span> === current.<span class="hljs-property">child</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Resuming work not yet implemented.&quot;</span>);
      }
    }

    <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">child</span> === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> currentChild = workInProgress.<span class="hljs-property">child</span>;
    <span class="hljs-keyword">var</span> newChild = <span class="hljs-title function_">createWorkInProgress</span>(currentChild, currentChild.<span class="hljs-property">pendingProps</span>);
    workInProgress.<span class="hljs-property">child</span> = newChild;
    newChild.<span class="hljs-property">return</span> = workInProgress;

    <span class="hljs-keyword">while</span> (currentChild.<span class="hljs-property">sibling</span> !== <span class="hljs-literal">null</span>) {
      currentChild = currentChild.<span class="hljs-property">sibling</span>;
      newChild = newChild.<span class="hljs-property">sibling</span> = <span class="hljs-title function_">createWorkInProgress</span>(currentChild, currentChild.<span class="hljs-property">pendingProps</span>);
      newChild.<span class="hljs-property">return</span> = workInProgress;
    }

    newChild.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
  } <span class="hljs-comment">// Reset a workInProgress child set to prepare it for a second pass.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetChildFibers</span>(<span class="hljs-params">workInProgress, lanes</span>) {
    <span class="hljs-keyword">var</span> child = workInProgress.<span class="hljs-property">child</span>;

    <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">resetWorkInProgress</span>(child, lanes);
      child = child.<span class="hljs-property">sibling</span>;
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NO_CONTEXT</span> = {};
  <span class="hljs-keyword">var</span> contextStackCursor$<span class="hljs-number">1</span> = <span class="hljs-title function_">createCursor</span>(<span class="hljs-variable constant_">NO_CONTEXT</span>);
  <span class="hljs-keyword">var</span> contextFiberStackCursor = <span class="hljs-title function_">createCursor</span>(<span class="hljs-variable constant_">NO_CONTEXT</span>);
  <span class="hljs-keyword">var</span> rootInstanceStackCursor = <span class="hljs-title function_">createCursor</span>(<span class="hljs-variable constant_">NO_CONTEXT</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">requiredContext</span>(<span class="hljs-params">c</span>) {
    <span class="hljs-keyword">if</span> (!(c !== <span class="hljs-variable constant_">NO_CONTEXT</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }

    <span class="hljs-keyword">return</span> c;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRootHostContainer</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> rootInstance = requiredContext(rootInstanceStackCursor.<span class="hljs-property">current</span>);
    <span class="hljs-keyword">return</span> rootInstance;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushHostContainer</span>(<span class="hljs-params">fiber, nextRootInstance</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-620">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-620">&#x00a7;</a>
              </div>
              <p>Push current root instance onto the stack;
This allows us to reset root when portals are popped.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">push</span>(rootInstanceStackCursor, nextRootInstance, fiber); <span class="hljs-comment">// Track the context and the Fiber that provided it.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-621">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-621">&#x00a7;</a>
              </div>
              <p>This enables us to pop only Fibers that provide unique contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title function_">push</span>(contextFiberStackCursor, fiber, fiber); <span class="hljs-comment">// Finally, we need to push the host context to the stack.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-622">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-622">&#x00a7;</a>
              </div>
              <p>However, we can’t just call getRootHostContext() and push it because
we’d have a different number of entries on the stack depending on
whether getRootHostContext() throws somewhere in renderer code or not.
So we push an empty value first. This lets us safely unwind on errors.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title function_">push</span>(contextStackCursor$<span class="hljs-number">1</span>, <span class="hljs-variable constant_">NO_CONTEXT</span>, fiber);
    <span class="hljs-keyword">var</span> nextRootContext = <span class="hljs-title function_">getRootHostContext</span>(nextRootInstance); <span class="hljs-comment">// Now that we know this function doesn&#x27;t throw, replace it.</span>

    <span class="hljs-title function_">pop</span>(contextStackCursor$<span class="hljs-number">1</span>, fiber);
    <span class="hljs-title function_">push</span>(contextStackCursor$<span class="hljs-number">1</span>, nextRootContext, fiber);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popHostContainer</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-title function_">pop</span>(contextStackCursor$<span class="hljs-number">1</span>, fiber);
    <span class="hljs-title function_">pop</span>(contextFiberStackCursor, fiber);
    <span class="hljs-title function_">pop</span>(rootInstanceStackCursor, fiber);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHostContext</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> context = requiredContext(contextStackCursor$<span class="hljs-number">1.</span>current);
    <span class="hljs-keyword">return</span> context;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushHostContext</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> rootInstance = requiredContext(rootInstanceStackCursor.<span class="hljs-property">current</span>);
    <span class="hljs-keyword">var</span> context = requiredContext(contextStackCursor$<span class="hljs-number">1.</span>current);
    <span class="hljs-keyword">var</span> nextContext = <span class="hljs-title function_">getChildHostContext</span>(context, fiber.<span class="hljs-property">type</span>); <span class="hljs-comment">// Don&#x27;t push this Fiber&#x27;s context unless it&#x27;s unique.</span>

    <span class="hljs-keyword">if</span> (context === nextContext) {
      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// Track the context and the Fiber that provided it.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-623">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-623">&#x00a7;</a>
              </div>
              <p>This enables us to pop only Fibers that provide unique contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-title function_">push</span>(contextFiberStackCursor, fiber, fiber);
    <span class="hljs-title function_">push</span>(contextStackCursor$<span class="hljs-number">1</span>, nextContext, fiber);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popHostContext</span>(<span class="hljs-params">fiber</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-624">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-624">&#x00a7;</a>
              </div>
              <p>Do not pop unless this Fiber provided the current context.
pushHostContext() only pushes Fibers that provide unique contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (contextFiberStackCursor.<span class="hljs-property">current</span> !== fiber) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-title function_">pop</span>(contextStackCursor$<span class="hljs-number">1</span>, fiber);
    <span class="hljs-title function_">pop</span>(contextFiberStackCursor, fiber);
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DefaultSuspenseContext</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">// The Suspense Context is split into two parts. The lower bits is</span></pre></div></div>
            
        </li>
        
        
        <li id="section-625">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-625">&#x00a7;</a>
              </div>
              <p>inherited deeply down the subtree. The upper bits only affect
this immediate suspense boundary and gets reset each new
boundary or suspense list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">SubtreeSuspenseContextMask</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// Subtree Flags:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-626">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-626">&#x00a7;</a>
              </div>
              <p>InvisibleParentSuspenseContext indicates that one of our parent Suspense
boundaries is not currently showing visible main content.
Either because it is already showing a fallback or is not mounted at all.
We can use this to determine if it is desirable to trigger a fallback at
the parent. If not, then we might need to trigger undesirable boundaries
and/or suspend the commit to avoid hiding the parent content.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InvisibleParentSuspenseContext</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// Shallow Flags:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-627">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-627">&#x00a7;</a>
              </div>
              <p>ForceSuspenseFallback can be used by SuspenseList to force newly added
items into their fallback state during one of the render passes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ForceSuspenseFallback</span> = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> suspenseStackCursor = <span class="hljs-title function_">createCursor</span>(<span class="hljs-title class_">DefaultSuspenseContext</span>);
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hasSuspenseContext</span>(<span class="hljs-params">parentContext, flag</span>) {
    <span class="hljs-keyword">return</span> (parentContext &amp; flag) !== <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(<span class="hljs-params">parentContext</span>) {
    <span class="hljs-keyword">return</span> parentContext &amp; <span class="hljs-title class_">SubtreeSuspenseContextMask</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setShallowSuspenseContext</span>(<span class="hljs-params">parentContext, shallowContext</span>) {
    <span class="hljs-keyword">return</span> parentContext &amp; <span class="hljs-title class_">SubtreeSuspenseContextMask</span> | shallowContext;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">addSubtreeSuspenseContext</span>(<span class="hljs-params">parentContext, subtreeContext</span>) {
    <span class="hljs-keyword">return</span> parentContext | subtreeContext;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushSuspenseContext</span>(<span class="hljs-params">fiber, newContext</span>) {
    <span class="hljs-title function_">push</span>(suspenseStackCursor, newContext, fiber);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popSuspenseContext</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-title function_">pop</span>(suspenseStackCursor, fiber);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldCaptureSuspense</span>(<span class="hljs-params">workInProgress, hasInvisibleParent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-628">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-628">&#x00a7;</a>
              </div>
              <p>If it was the primary children that just suspended, capture and render the
fallback. Otherwise, don’t capture and bubble to the next boundary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> nextState = workInProgress.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (nextState !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (nextState.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-629">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-629">&#x00a7;</a>
              </div>
              <p>A dehydrated boundary always captures.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> props = workInProgress.<span class="hljs-property">memoizedProps</span>; <span class="hljs-comment">// In order to capture, the Suspense component must have a fallback prop.</span>

    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">fallback</span> === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// Regular boundaries always capture.</span>


    <span class="hljs-keyword">if</span> (props.<span class="hljs-property">unstable_avoidThisFallback</span> !== <span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-comment">// If it&#x27;s a boundary we should avoid, then we prefer to bubble up to the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-630">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-630">&#x00a7;</a>
              </div>
              <p>parent boundary if it is currently invisible.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (hasInvisibleParent) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// If the parent is not able to handle it, we must handle it.</span>


    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findFirstSuspended</span>(<span class="hljs-params">row</span>) {
    <span class="hljs-keyword">var</span> node = row;

    <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span>) {
        <span class="hljs-keyword">var</span> state = node.<span class="hljs-property">memoizedState</span>;

        <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> dehydrated = state.<span class="hljs-property">dehydrated</span>;

          <span class="hljs-keyword">if</span> (dehydrated === <span class="hljs-literal">null</span> || <span class="hljs-title function_">isSuspenseInstancePending</span>(dehydrated) || <span class="hljs-title function_">isSuspenseInstanceFallback</span>(dehydrated)) {
            <span class="hljs-keyword">return</span> node;
          }
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseListComponent</span> &amp;&amp; <span class="hljs-comment">// revealOrder undefined can&#x27;t be trusted because it don&#x27;t</span></pre></div></div>
            
        </li>
        
        
        <li id="section-631">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-631">&#x00a7;</a>
              </div>
              <p>keep track of whether it suspended or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        node.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">revealOrder</span> !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> didSuspend = (node.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoFlags</span>;

        <span class="hljs-keyword">if</span> (didSuspend) {
          <span class="hljs-keyword">return</span> node;
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {
        node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
        node = node.<span class="hljs-property">child</span>;
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (node === row) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">return</span> === row) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        node = node.<span class="hljs-property">return</span>;
      }

      node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
      node = node.<span class="hljs-property">sibling</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoFlags</span>$<span class="hljs-number">1</span> =
    <span class="hljs-comment">/*  */</span>
    <span class="hljs-number">0</span>; <span class="hljs-comment">// Represents whether effect should fire.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HasEffect</span> =
    <span class="hljs-comment">/* */</span>
    <span class="hljs-number">1</span>; <span class="hljs-comment">// Represents the phase in which the effect (not the clean-up) fires.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Layout</span> =
    <span class="hljs-comment">/*    */</span>
    <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Passive</span>$<span class="hljs-number">1</span> =
    <span class="hljs-comment">/*   */</span>
    <span class="hljs-number">4</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-632">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-632">&#x00a7;</a>
              </div>
              <p>This may have been an insertion or a hydration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> hydrationParentFiber = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> nextHydratableInstance = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> isHydrating = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnIfHydrating</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (isHydrating) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;We should not be hydrating here. This is a bug in React. Please file a bug.&#x27;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enterHydrationState</span>(<span class="hljs-params">fiber</span>) {

    <span class="hljs-keyword">var</span> parentInstance = fiber.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>;
    nextHydratableInstance = <span class="hljs-title function_">getFirstHydratableChild</span>(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reenterHydrationStateFromDehydratedSuspenseInstance</span>(<span class="hljs-params">fiber, suspenseInstance</span>) {

    nextHydratableInstance = <span class="hljs-title function_">getNextHydratableSibling</span>(suspenseInstance);
    <span class="hljs-title function_">popToNextHostParent</span>(fiber);
    isHydrating = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">deleteHydratableInstance</span>(<span class="hljs-params">returnFiber, instance</span>) {
    {
      <span class="hljs-keyword">switch</span> (returnFiber.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
          <span class="hljs-title function_">didNotHydrateContainerInstance</span>(returnFiber.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>, instance);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
          <span class="hljs-title function_">didNotHydrateInstance</span>(returnFiber.<span class="hljs-property">type</span>, returnFiber.<span class="hljs-property">memoizedProps</span>, returnFiber.<span class="hljs-property">stateNode</span>, instance);
          <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">var</span> childToDelete = <span class="hljs-title function_">createFiberFromHostInstanceForDeletion</span>();
    childToDelete.<span class="hljs-property">stateNode</span> = instance;
    childToDelete.<span class="hljs-property">return</span> = returnFiber;
    childToDelete.<span class="hljs-property">flags</span> = <span class="hljs-title class_">Deletion</span>; <span class="hljs-comment">// This might seem like it belongs on progressedFirstDeletion. However,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-633">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-633">&#x00a7;</a>
              </div>
              <p>these children are not part of the reconciliation list of children.
Even if we abort and rereconcile the children, that will try to hydrate
again and the nodes are still in the host tree so these will be
recreated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
      returnFiber.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = childToDelete;
      returnFiber.<span class="hljs-property">lastEffect</span> = childToDelete;
    } <span class="hljs-keyword">else</span> {
      returnFiber.<span class="hljs-property">firstEffect</span> = returnFiber.<span class="hljs-property">lastEffect</span> = childToDelete;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">insertNonHydratedInstance</span>(<span class="hljs-params">returnFiber, fiber</span>) {
    fiber.<span class="hljs-property">flags</span> = fiber.<span class="hljs-property">flags</span> &amp; ~<span class="hljs-title class_">Hydrating</span> | <span class="hljs-title class_">Placement</span>;

    {
      <span class="hljs-keyword">switch</span> (returnFiber.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
          {
            <span class="hljs-keyword">var</span> parentContainer = returnFiber.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>;

            <span class="hljs-keyword">switch</span> (fiber.<span class="hljs-property">tag</span>) {
              <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
                <span class="hljs-keyword">var</span> type = fiber.<span class="hljs-property">type</span>;
                <span class="hljs-keyword">var</span> props = fiber.<span class="hljs-property">pendingProps</span>;
                <span class="hljs-title function_">didNotFindHydratableContainerInstance</span>(parentContainer, type);
                <span class="hljs-keyword">break</span>;

              <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
                <span class="hljs-keyword">var</span> text = fiber.<span class="hljs-property">pendingProps</span>;
                <span class="hljs-title function_">didNotFindHydratableContainerTextInstance</span>(parentContainer, text);
                <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
          {
            <span class="hljs-keyword">var</span> parentType = returnFiber.<span class="hljs-property">type</span>;
            <span class="hljs-keyword">var</span> parentProps = returnFiber.<span class="hljs-property">memoizedProps</span>;
            <span class="hljs-keyword">var</span> parentInstance = returnFiber.<span class="hljs-property">stateNode</span>;

            <span class="hljs-keyword">switch</span> (fiber.<span class="hljs-property">tag</span>) {
              <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
                <span class="hljs-keyword">var</span> _type = fiber.<span class="hljs-property">type</span>;
                <span class="hljs-keyword">var</span> _props = fiber.<span class="hljs-property">pendingProps</span>;
                <span class="hljs-title function_">didNotFindHydratableInstance</span>(parentType, parentProps, parentInstance, _type);
                <span class="hljs-keyword">break</span>;

              <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
                <span class="hljs-keyword">var</span> _text = fiber.<span class="hljs-property">pendingProps</span>;
                <span class="hljs-title function_">didNotFindHydratableTextInstance</span>(parentType, parentProps, parentInstance, _text);
                <span class="hljs-keyword">break</span>;

              <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
                <span class="hljs-title function_">didNotFindHydratableSuspenseInstance</span>(parentType, parentProps);
                <span class="hljs-keyword">break</span>;
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span>;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">tryHydrate</span>(<span class="hljs-params">fiber, nextInstance</span>) {
    <span class="hljs-keyword">switch</span> (fiber.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        {
          <span class="hljs-keyword">var</span> type = fiber.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">var</span> props = fiber.<span class="hljs-property">pendingProps</span>;
          <span class="hljs-keyword">var</span> instance = <span class="hljs-title function_">canHydrateInstance</span>(nextInstance, type);

          <span class="hljs-keyword">if</span> (instance !== <span class="hljs-literal">null</span>) {
            fiber.<span class="hljs-property">stateNode</span> = instance;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
        {
          <span class="hljs-keyword">var</span> text = fiber.<span class="hljs-property">pendingProps</span>;
          <span class="hljs-keyword">var</span> textInstance = <span class="hljs-title function_">canHydrateTextInstance</span>(nextInstance, text);

          <span class="hljs-keyword">if</span> (textInstance !== <span class="hljs-literal">null</span>) {
            fiber.<span class="hljs-property">stateNode</span> = textInstance;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        {
          {
            <span class="hljs-keyword">var</span> suspenseInstance = <span class="hljs-title function_">canHydrateSuspenseInstance</span>(nextInstance);

            <span class="hljs-keyword">if</span> (suspenseInstance !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> suspenseState = {
                <span class="hljs-attr">dehydrated</span>: suspenseInstance,
                <span class="hljs-attr">retryLane</span>: <span class="hljs-title class_">OffscreenLane</span>
              };
              fiber.<span class="hljs-property">memoizedState</span> = suspenseState; <span class="hljs-comment">// Store the dehydrated fragment as a child fiber.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-634">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-634">&#x00a7;</a>
              </div>
              <p>This simplifies the code for getHostSibling and deleting nodes,
since it doesn’t have to consider all Suspense boundaries and
check if they’re dehydrated ones or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              <span class="hljs-keyword">var</span> dehydratedFragment = <span class="hljs-title function_">createFiberFromDehydratedFragment</span>(suspenseInstance);
              dehydratedFragment.<span class="hljs-property">return</span> = fiber;
              fiber.<span class="hljs-property">child</span> = dehydratedFragment;
              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">tryToClaimNextHydratableInstance</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">if</span> (!isHydrating) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> nextInstance = nextHydratableInstance;

    <span class="hljs-keyword">if</span> (!nextInstance) {</pre></div></div>
            
        </li>
        
        
        <li id="section-635">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-635">&#x00a7;</a>
              </div>
              <p>Nothing to hydrate. Make it an insertion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">insertNonHydratedInstance</span>(hydrationParentFiber, fiber);
      isHydrating = <span class="hljs-literal">false</span>;
      hydrationParentFiber = fiber;
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> firstAttemptedInstance = nextInstance;

    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">tryHydrate</span>(fiber, nextInstance)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-636">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-636">&#x00a7;</a>
              </div>
              <p>If we can’t hydrate this instance let’s try the next one.
We use this as a heuristic. It’s based on intuition and not data so it
might be flawed or unnecessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      nextInstance = <span class="hljs-title function_">getNextHydratableSibling</span>(firstAttemptedInstance);

      <span class="hljs-keyword">if</span> (!nextInstance || !<span class="hljs-title function_">tryHydrate</span>(fiber, nextInstance)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-637">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-637">&#x00a7;</a>
              </div>
              <p>Nothing to hydrate. Make it an insertion.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">insertNonHydratedInstance</span>(hydrationParentFiber, fiber);
        isHydrating = <span class="hljs-literal">false</span>;
        hydrationParentFiber = fiber;
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// We matched the next one, we&#x27;ll now assume that the first one was</span></pre></div></div>
            
        </li>
        
        
        <li id="section-638">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-638">&#x00a7;</a>
              </div>
              <p>superfluous and we’ll delete it. Since we can’t eagerly delete it
we’ll have to schedule a deletion. To do that, this node needs a dummy
fiber associated with it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-title function_">deleteHydratableInstance</span>(hydrationParentFiber, firstAttemptedInstance);
    }

    hydrationParentFiber = fiber;
    nextHydratableInstance = <span class="hljs-title function_">getFirstHydratableChild</span>(nextInstance);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareToHydrateHostInstance</span>(<span class="hljs-params">fiber, rootContainerInstance, hostContext</span>) {

    <span class="hljs-keyword">var</span> instance = fiber.<span class="hljs-property">stateNode</span>;
    <span class="hljs-keyword">var</span> updatePayload = <span class="hljs-title function_">hydrateInstance</span>(instance, fiber.<span class="hljs-property">type</span>, fiber.<span class="hljs-property">memoizedProps</span>, rootContainerInstance, hostContext, fiber); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Type this specific to this type of component.</span>

    fiber.<span class="hljs-property">updateQueue</span> = updatePayload; <span class="hljs-comment">// If the update payload indicates that there is a change or if there</span></pre></div></div>
            
        </li>
        
        
        <li id="section-639">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-639">&#x00a7;</a>
              </div>
              <p>is a new ref we mark this as an update.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (updatePayload !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareToHydrateHostTextInstance</span>(<span class="hljs-params">fiber</span>) {

    <span class="hljs-keyword">var</span> textInstance = fiber.<span class="hljs-property">stateNode</span>;
    <span class="hljs-keyword">var</span> textContent = fiber.<span class="hljs-property">memoizedProps</span>;
    <span class="hljs-keyword">var</span> shouldUpdate = <span class="hljs-title function_">hydrateTextInstance</span>(textInstance, textContent, fiber);

    {
      <span class="hljs-keyword">if</span> (shouldUpdate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-640">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-640">&#x00a7;</a>
              </div>
              <p>We assume that prepareToHydrateHostTextInstance is called in a context where the
hydration parent is the parent host component of this host text.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> returnFiber = hydrationParentFiber;

        <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">switch</span> (returnFiber.<span class="hljs-property">tag</span>) {
            <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
              {
                <span class="hljs-keyword">var</span> parentContainer = returnFiber.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>;
                <span class="hljs-title function_">didNotMatchHydratedContainerTextInstance</span>(parentContainer, textInstance, textContent);
                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
              {
                <span class="hljs-keyword">var</span> parentType = returnFiber.<span class="hljs-property">type</span>;
                <span class="hljs-keyword">var</span> parentProps = returnFiber.<span class="hljs-property">memoizedProps</span>;
                <span class="hljs-keyword">var</span> parentInstance = returnFiber.<span class="hljs-property">stateNode</span>;
                <span class="hljs-title function_">didNotMatchHydratedTextInstance</span>(parentType, parentProps, parentInstance, textInstance, textContent);
                <span class="hljs-keyword">break</span>;
              }
          }
        }
      }
    }

    <span class="hljs-keyword">return</span> shouldUpdate;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareToHydrateHostSuspenseInstance</span>(<span class="hljs-params">fiber</span>) {

    <span class="hljs-keyword">var</span> suspenseState = fiber.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> suspenseInstance = suspenseState !== <span class="hljs-literal">null</span> ? suspenseState.<span class="hljs-property">dehydrated</span> : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (!suspenseInstance) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }

    <span class="hljs-title function_">hydrateSuspenseInstance</span>(suspenseInstance, fiber);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">skipPastDehydratedSuspenseInstance</span>(<span class="hljs-params">fiber</span>) {

    <span class="hljs-keyword">var</span> suspenseState = fiber.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> suspenseInstance = suspenseState !== <span class="hljs-literal">null</span> ? suspenseState.<span class="hljs-property">dehydrated</span> : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (!suspenseInstance) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getNextHydratableInstanceAfterSuspenseInstance</span>(suspenseInstance);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popToNextHostParent</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> parent = fiber.<span class="hljs-property">return</span>;

    <span class="hljs-keyword">while</span> (parent !== <span class="hljs-literal">null</span> &amp;&amp; parent.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostComponent</span> &amp;&amp; parent.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostRoot</span> &amp;&amp; parent.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">SuspenseComponent</span>) {
      parent = parent.<span class="hljs-property">return</span>;
    }

    hydrationParentFiber = parent;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popHydrationState</span>(<span class="hljs-params">fiber</span>) {

    <span class="hljs-keyword">if</span> (fiber !== hydrationParentFiber) {</pre></div></div>
            
        </li>
        
        
        <li id="section-641">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-641">&#x00a7;</a>
              </div>
              <p>We’re deeper than the current hydration context, inside an inserted
tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">if</span> (!isHydrating) {</pre></div></div>
            
        </li>
        
        
        <li id="section-642">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-642">&#x00a7;</a>
              </div>
              <p>If we’re not currently hydrating but we’re in a hydration context, then
we were an insertion and now need to pop up reenter hydration of our
siblings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">popToNextHostParent</span>(fiber);
      isHydrating = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> type = fiber.<span class="hljs-property">type</span>; <span class="hljs-comment">// If we have any remaining hydratable nodes, we need to delete them now.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-643">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-643">&#x00a7;</a>
              </div>
              <p>We only do this deeper than head and body since they tend to have random
other nodes in them. We also ignore components with pure text content in
side of them.
TODO: Better heuristic.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostComponent</span> || type !== <span class="hljs-string">&#x27;head&#x27;</span> &amp;&amp; type !== <span class="hljs-string">&#x27;body&#x27;</span> &amp;&amp; !<span class="hljs-title function_">shouldSetTextContent</span>(type, fiber.<span class="hljs-property">memoizedProps</span>)) {
      <span class="hljs-keyword">var</span> nextInstance = nextHydratableInstance;

      <span class="hljs-keyword">while</span> (nextInstance) {
        <span class="hljs-title function_">deleteHydratableInstance</span>(fiber, nextInstance);
        nextInstance = <span class="hljs-title function_">getNextHydratableSibling</span>(nextInstance);
      }
    }

    <span class="hljs-title function_">popToNextHostParent</span>(fiber);

    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span>) {
      nextHydratableInstance = <span class="hljs-title function_">skipPastDehydratedSuspenseInstance</span>(fiber);
    } <span class="hljs-keyword">else</span> {
      nextHydratableInstance = hydrationParentFiber ? <span class="hljs-title function_">getNextHydratableSibling</span>(fiber.<span class="hljs-property">stateNode</span>) : <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetHydrationState</span>(<span class="hljs-params"></span>) {

    hydrationParentFiber = <span class="hljs-literal">null</span>;
    nextHydratableInstance = <span class="hljs-literal">null</span>;
    isHydrating = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getIsHydrating</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> isHydrating;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-644">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-644">&#x00a7;</a>
              </div>
              <p>and should be reset before starting a new render.
This tracks which mutable sources need to be reset after a render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> workInProgressSources = [];
  <span class="hljs-keyword">var</span> rendererSigil$<span class="hljs-number">1</span>;

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-645">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-645">&#x00a7;</a>
              </div>
              <p>Used to detect multiple renderers using the same mutable source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rendererSigil$<span class="hljs-number">1</span> = {};
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markSourceAsDirty</span>(<span class="hljs-params">mutableSource</span>) {
    workInProgressSources.<span class="hljs-title function_">push</span>(mutableSource);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetWorkInProgressVersions</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; workInProgressSources.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">var</span> mutableSource = workInProgressSources[i];

      {
        mutableSource.<span class="hljs-property">_workInProgressVersionPrimary</span> = <span class="hljs-literal">null</span>;
      }
    }

    workInProgressSources.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getWorkInProgressVersion</span>(<span class="hljs-params">mutableSource</span>) {
    {
      <span class="hljs-keyword">return</span> mutableSource.<span class="hljs-property">_workInProgressVersionPrimary</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setWorkInProgressVersion</span>(<span class="hljs-params">mutableSource, version</span>) {
    {
      mutableSource.<span class="hljs-property">_workInProgressVersionPrimary</span> = version;
    }

    workInProgressSources.<span class="hljs-title function_">push</span>(mutableSource);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnAboutMultipleRenderersDEV</span>(<span class="hljs-params">mutableSource</span>) {
    {
      {
        <span class="hljs-keyword">if</span> (mutableSource.<span class="hljs-property">_currentPrimaryRenderer</span> == <span class="hljs-literal">null</span>) {
          mutableSource.<span class="hljs-property">_currentPrimaryRenderer</span> = rendererSigil$<span class="hljs-number">1</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mutableSource.<span class="hljs-property">_currentPrimaryRenderer</span> !== rendererSigil$<span class="hljs-number">1</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Detected multiple renderers concurrently rendering the &#x27;</span> + <span class="hljs-string">&#x27;same mutable source. This is currently unsupported.&#x27;</span>);
        }
      }
    }
  } <span class="hljs-comment">// Eager reads the version of a mutable source and stores it on the root.</span>

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentDispatcher</span>,
    <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentBatchConfig</span>;
  <span class="hljs-keyword">var</span> didWarnAboutMismatchedHooksForComponent;
  <span class="hljs-keyword">var</span> didWarnAboutUseOpaqueIdentifier;

  {
    didWarnAboutUseOpaqueIdentifier = {};
    didWarnAboutMismatchedHooksForComponent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-646">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-646">&#x00a7;</a>
              </div>
              <p>These are set right before calling the component.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> renderLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// The work-in-progress fiber. I&#x27;ve named it differently to distinguish it from</span></pre></div></div>
            
        </li>
        
        
        <li id="section-647">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-647">&#x00a7;</a>
              </div>
              <p>the work-in-progress hook.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> currentlyRenderingFiber$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Hooks are stored as a linked list on the fiber&#x27;s memoizedState field. The</span></pre></div></div>
            
        </li>
        
        
        <li id="section-648">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-648">&#x00a7;</a>
              </div>
              <p>current hook list is the list that belongs to the current fiber. The
work-in-progress hook list is a new list that will be added to the
work-in-progress fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> currentHook = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> workInProgressHook = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Whether an update was scheduled at any point during the render phase. This</span></pre></div></div>
            
        </li>
        
        
        <li id="section-649">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-649">&#x00a7;</a>
              </div>
              <p>does not get reset if we do another render pass; only when we’re completely
finished evaluating this component. This is an optimization so we know
whether we need to clear render phase updates after a throw.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> didScheduleRenderPhaseUpdate = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Where an update was scheduled only during the current render pass. This</span></pre></div></div>
            
        </li>
        
        
        <li id="section-650">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-650">&#x00a7;</a>
              </div>
              <p>gets reset after each attempt.
TODO: Maybe there’s some way to consolidate this with
<code>didScheduleRenderPhaseUpdate</code>. Or with <code>numberOfReRenders</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> didScheduleRenderPhaseUpdateDuringThisPass = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">RE_RENDER_LIMIT</span> = <span class="hljs-number">25</span>; <span class="hljs-comment">// In DEV, this is the name of the currently executing primitive hook</span>

  <span class="hljs-keyword">var</span> currentHookNameInDev = <span class="hljs-literal">null</span>; <span class="hljs-comment">// In DEV, this list ensures that hooks are called in the same order between renders.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-651">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-651">&#x00a7;</a>
              </div>
              <p>The list stores the order of hooks used during the initial render (mount).
Subsequent renders (updates) reference this list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> hookTypesDev = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> hookTypesUpdateIndexDev = -<span class="hljs-number">1</span>; <span class="hljs-comment">// In DEV, this tracks whether currently rendering component needs to ignore</span></pre></div></div>
            
        </li>
        
        
        <li id="section-652">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-652">&#x00a7;</a>
              </div>
              <p>the dependencies for Hooks that need them (e.g. useEffect or useMemo).
When true, such Hooks will always be “remounted”. Only used during hot reload.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> ignorePreviousDependencies = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountHookTypesDev</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">var</span> hookName = currentHookNameInDev;

      <span class="hljs-keyword">if</span> (hookTypesDev === <span class="hljs-literal">null</span>) {
        hookTypesDev = [hookName];
      } <span class="hljs-keyword">else</span> {
        hookTypesDev.<span class="hljs-title function_">push</span>(hookName);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateHookTypesDev</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">var</span> hookName = currentHookNameInDev;

      <span class="hljs-keyword">if</span> (hookTypesDev !== <span class="hljs-literal">null</span>) {
        hookTypesUpdateIndexDev++;

        <span class="hljs-keyword">if</span> (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
          <span class="hljs-title function_">warnOnHookMismatchInDev</span>(hookName);
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkDepsAreArrayDev</span>(<span class="hljs-params">deps</span>) {
    {
      <span class="hljs-keyword">if</span> (deps !== <span class="hljs-literal">undefined</span> &amp;&amp; deps !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(deps)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-653">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-653">&#x00a7;</a>
              </div>
              <p>Verify deps, but only on mount to avoid extra checks.
It’s unlikely their type would change as usually you define them inline.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s received a final argument that is not an array (instead, received `%s`). When &#x27;</span> + <span class="hljs-string">&#x27;specified, the final argument must be an array.&#x27;</span>, currentHookNameInDev, <span class="hljs-keyword">typeof</span> deps);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnOnHookMismatchInDev</span>(<span class="hljs-params">currentHookName</span>) {
    {
      <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(currentlyRenderingFiber$<span class="hljs-number">1.</span>type);

      <span class="hljs-keyword">if</span> (!didWarnAboutMismatchedHooksForComponent.<span class="hljs-title function_">has</span>(componentName)) {
        didWarnAboutMismatchedHooksForComponent.<span class="hljs-title function_">add</span>(componentName);

        <span class="hljs-keyword">if</span> (hookTypesDev !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> table = <span class="hljs-string">&#x27;&#x27;</span>;
          <span class="hljs-keyword">var</span> secondColumnStart = <span class="hljs-number">30</span>;

          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= hookTypesUpdateIndexDev; i++) {
            <span class="hljs-keyword">var</span> oldHookName = hookTypesDev[i];
            <span class="hljs-keyword">var</span> newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
            <span class="hljs-keyword">var</span> row = i + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;. &quot;</span> + oldHookName; <span class="hljs-comment">// Extra space so second column lines up</span></pre></div></div>
            
        </li>
        
        
        <li id="section-654">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-654">&#x00a7;</a>
              </div>
              <p>lol @ IE not supporting String#repeat</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">while</span> (row.<span class="hljs-property">length</span> &lt; secondColumnStart) {
              row += <span class="hljs-string">&#x27; &#x27;</span>;
            }

            row += newHookName + <span class="hljs-string">&#x27;\n&#x27;</span>;
            table += row;
          }

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React has detected a change in the order of Hooks called by %s. &#x27;</span> + <span class="hljs-string">&#x27;This will lead to bugs and errors if not fixed. &#x27;</span> + <span class="hljs-string">&#x27;For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n&#x27;</span> + <span class="hljs-string">&#x27;   Previous render            Next render\n&#x27;</span> + <span class="hljs-string">&#x27;   ------------------------------------------------------\n&#x27;</span> + <span class="hljs-string">&#x27;%s&#x27;</span> + <span class="hljs-string">&#x27;   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n&#x27;</span>, componentName, table);
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">throwInvalidHookError</span>(<span class="hljs-params"></span>) {
    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">areHookInputsEqual</span>(<span class="hljs-params">nextDeps, prevDeps</span>) {
    {
      <span class="hljs-keyword">if</span> (ignorePreviousDependencies) {</pre></div></div>
            
        </li>
        
        
        <li id="section-655">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-655">&#x00a7;</a>
              </div>
              <p>Only true when this component is being hot reloaded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-keyword">if</span> (prevDeps === <span class="hljs-literal">null</span>) {
      {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s received a final argument during this render, but not during &#x27;</span> + <span class="hljs-string">&#x27;the previous render. Even though the final argument is optional, &#x27;</span> + <span class="hljs-string">&#x27;its type cannot change between renders.&#x27;</span>, currentHookNameInDev);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-656">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-656">&#x00a7;</a>
              </div>
              <p>Don’t bother comparing lengths in prod because these arrays should be
passed inline.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (nextDeps.<span class="hljs-property">length</span> !== prevDeps.<span class="hljs-property">length</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The final argument passed to %s changed size between renders. The &#x27;</span> + <span class="hljs-string">&#x27;order and size of this array must remain constant.\n\n&#x27;</span> + <span class="hljs-string">&#x27;Previous: %s\n&#x27;</span> + <span class="hljs-string">&#x27;Incoming: %s&#x27;</span>, currentHookNameInDev, <span class="hljs-string">&quot;[&quot;</span> + prevDeps.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>) + <span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;[&quot;</span> + nextDeps.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>) + <span class="hljs-string">&quot;]&quot;</span>);
      }
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; prevDeps.<span class="hljs-property">length</span> &amp;&amp; i &lt; nextDeps.<span class="hljs-property">length</span>; i++) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">objectIs</span>(nextDeps[i], prevDeps[i])) {
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderWithHooks</span>(<span class="hljs-params">current, workInProgress, Component, props, secondArg, nextRenderLanes</span>) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber$<span class="hljs-number">1</span> = workInProgress;

    {
      hookTypesDev = current !== <span class="hljs-literal">null</span> ? current.<span class="hljs-property">_debugHookTypes</span> : <span class="hljs-literal">null</span>;
      hookTypesUpdateIndexDev = -<span class="hljs-number">1</span>; <span class="hljs-comment">// Used for hot reloading:</span>

      ignorePreviousDependencies = current !== <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">type</span>;
    }

    workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
    workInProgress.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;
    workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// The following should have already been reset</span></pre></div></div>
            
        </li>
        
        
        <li id="section-657">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-657">&#x00a7;</a>
              </div>
              <p>currentHook = null;
workInProgressHook = null;
didScheduleRenderPhaseUpdate = false;
TODO Warn if no hooks are used at all during mount, then some are used during update.
Currently we will identify the update render as a mount because memoizedState === null.
This is tricky because it’s valid for certain types of components (e.g. React.lazy)
Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
Non-stateful hooks (e.g. context) don’t get added to memoizedState,
so memoizedState would be null during updates and mounts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    {
      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">memoizedState</span> !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">HooksDispatcherOnUpdateIn</span>DEV;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hookTypesDev !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-658">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-658">&#x00a7;</a>
              </div>
              <p>This dispatcher handles an edge case where a component is updating,
but no stateful hooks have been used.
We want to match the production code behavior (which will use HooksDispatcherOnMount),
but with the extra DEV validation to ensure hooks ordering hasn’t changed.
This dispatcher does that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">HooksDispatcherOnMountWithHookTypesIn</span>DEV;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">HooksDispatcherOnMountIn</span>DEV;
      }
    }

    <span class="hljs-keyword">var</span> children = <span class="hljs-title class_">Component</span>(props, secondArg); <span class="hljs-comment">// Check if there was a render phase update</span>

    <span class="hljs-keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) {</pre></div></div>
            
        </li>
        
        
        <li id="section-659">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-659">&#x00a7;</a>
              </div>
              <p>Keep rendering in a loop for as long as render phase updates continue to
be scheduled. Use a counter to prevent infinite loops.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> numberOfReRenders = <span class="hljs-number">0</span>;

      <span class="hljs-keyword">do</span> {
        didScheduleRenderPhaseUpdateDuringThisPass = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (!(numberOfReRenders &lt; <span class="hljs-variable constant_">RE_RENDER_LIMIT</span>)) {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Too many re-renders. React limits the number of renders to prevent an infinite loop.&quot;</span>);
          }
        }

        numberOfReRenders += <span class="hljs-number">1</span>;

        {</pre></div></div>
            
        </li>
        
        
        <li id="section-660">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-660">&#x00a7;</a>
              </div>
              <p>Even when hot reloading, allow dependencies to stabilize
after first render to prevent infinite render phase updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          ignorePreviousDependencies = <span class="hljs-literal">false</span>;
        } <span class="hljs-comment">// Start over from the beginning of the list</span>


        currentHook = <span class="hljs-literal">null</span>;
        workInProgressHook = <span class="hljs-literal">null</span>;
        workInProgress.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;

        {</pre></div></div>
            
        </li>
        
        
        <li id="section-661">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-661">&#x00a7;</a>
              </div>
              <p>Also validate hook order for cascading updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          hookTypesUpdateIndexDev = -<span class="hljs-number">1</span>;
        }

        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">HooksDispatcherOnRerenderIn</span>DEV;
        children = <span class="hljs-title class_">Component</span>(props, secondArg);
      } <span class="hljs-keyword">while</span> (didScheduleRenderPhaseUpdateDuringThisPass);
    } <span class="hljs-comment">// We can assume the previous dispatcher is always this one, since we set it</span></pre></div></div>
            
        </li>
        
        
        <li id="section-662">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-662">&#x00a7;</a>
              </div>
              <p>at the beginning of the render phase and there’s no re-entrancy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">ContextOnlyDispatcher</span>;

    {
      workInProgress.<span class="hljs-property">_debugHookTypes</span> = hookTypesDev;
    } <span class="hljs-comment">// This check uses currentHook so that it works the same in DEV and prod bundles.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-663">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-663">&#x00a7;</a>
              </div>
              <p>hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> didRenderTooFewHooks = currentHook !== <span class="hljs-literal">null</span> &amp;&amp; currentHook.<span class="hljs-property">next</span> !== <span class="hljs-literal">null</span>;
    renderLanes = <span class="hljs-title class_">NoLanes</span>;
    currentlyRenderingFiber$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
    currentHook = <span class="hljs-literal">null</span>;
    workInProgressHook = <span class="hljs-literal">null</span>;

    {
      currentHookNameInDev = <span class="hljs-literal">null</span>;
      hookTypesDev = <span class="hljs-literal">null</span>;
      hookTypesUpdateIndexDev = -<span class="hljs-number">1</span>;
    }

    didScheduleRenderPhaseUpdate = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (!!didRenderTooFewHooks) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Rendered fewer hooks than expected. This may be caused by an accidental early return statement.&quot;</span>);
      }
    }

    <span class="hljs-keyword">return</span> children;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bailoutHooks</span>(<span class="hljs-params">current, workInProgress, lanes</span>) {
    workInProgress.<span class="hljs-property">updateQueue</span> = current.<span class="hljs-property">updateQueue</span>;
    workInProgress.<span class="hljs-property">flags</span> &amp;= ~(<span class="hljs-title class_">Passive</span> | <span class="hljs-title class_">Update</span>);
    current.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">removeLanes</span>(current.<span class="hljs-property">lanes</span>, lanes);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetHooksAfterThrow</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-664">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-664">&#x00a7;</a>
              </div>
              <p>We can assume the previous dispatcher is always this one, since we set it
at the beginning of the render phase and there’s no re-entrancy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">ContextOnlyDispatcher</span>;

    <span class="hljs-keyword">if</span> (didScheduleRenderPhaseUpdate) {</pre></div></div>
            
        </li>
        
        
        <li id="section-665">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-665">&#x00a7;</a>
              </div>
              <p>There were render phase updates. These are only valid for this render
phase, which we are now aborting. Remove the updates from the queues so
they do not persist to the next render. Do not remove updates from hooks
that weren’t processed.</p>
<p>Only reset the updates from the queue if it has a clone. If it does
not have a clone, that means it wasn’t processed, and the updates were
scheduled before we entered the render phase.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> hook = currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState;

      <span class="hljs-keyword">while</span> (hook !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> queue = hook.<span class="hljs-property">queue</span>;

        <span class="hljs-keyword">if</span> (queue !== <span class="hljs-literal">null</span>) {
          queue.<span class="hljs-property">pending</span> = <span class="hljs-literal">null</span>;
        }

        hook = hook.<span class="hljs-property">next</span>;
      }

      didScheduleRenderPhaseUpdate = <span class="hljs-literal">false</span>;
    }

    renderLanes = <span class="hljs-title class_">NoLanes</span>;
    currentlyRenderingFiber$<span class="hljs-number">1</span> = <span class="hljs-literal">null</span>;
    currentHook = <span class="hljs-literal">null</span>;
    workInProgressHook = <span class="hljs-literal">null</span>;

    {
      hookTypesDev = <span class="hljs-literal">null</span>;
      hookTypesUpdateIndexDev = -<span class="hljs-number">1</span>;
      currentHookNameInDev = <span class="hljs-literal">null</span>;
      isUpdatingOpaqueValueInRenderPhase = <span class="hljs-literal">false</span>;
    }

    didScheduleRenderPhaseUpdateDuringThisPass = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountWorkInProgressHook</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> hook = {
      <span class="hljs-attr">memoizedState</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">baseState</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">baseQueue</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">queue</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
    };

    <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-666">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-666">&#x00a7;</a>
              </div>
              <p>This is the first hook in the list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState = workInProgressHook = hook;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-667">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-667">&#x00a7;</a>
              </div>
              <p>Append to the end of the list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgressHook = workInProgressHook.<span class="hljs-property">next</span> = hook;
    }

    <span class="hljs-keyword">return</span> workInProgressHook;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateWorkInProgressHook</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-668">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-668">&#x00a7;</a>
              </div>
              <p>This function is used both for updates and for re-renders triggered by a
render phase update. It assumes there is either a current hook we can
clone, or a work-in-progress hook from a previous render pass that we can
use as a base. When we reach the end of the base list, we must switch to
the dispatcher used for mounts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> nextCurrentHook;

    <span class="hljs-keyword">if</span> (currentHook === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> current = currentlyRenderingFiber$<span class="hljs-number">1.</span>alternate;

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
        nextCurrentHook = current.<span class="hljs-property">memoizedState</span>;
      } <span class="hljs-keyword">else</span> {
        nextCurrentHook = <span class="hljs-literal">null</span>;
      }
    } <span class="hljs-keyword">else</span> {
      nextCurrentHook = currentHook.<span class="hljs-property">next</span>;
    }

    <span class="hljs-keyword">var</span> nextWorkInProgressHook;

    <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) {
      nextWorkInProgressHook = currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState;
    } <span class="hljs-keyword">else</span> {
      nextWorkInProgressHook = workInProgressHook.<span class="hljs-property">next</span>;
    }

    <span class="hljs-keyword">if</span> (nextWorkInProgressHook !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-669">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-669">&#x00a7;</a>
              </div>
              <p>There’s already a work-in-progress. Reuse it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgressHook = nextWorkInProgressHook;
      nextWorkInProgressHook = workInProgressHook.<span class="hljs-property">next</span>;
      currentHook = nextCurrentHook;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-670">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-670">&#x00a7;</a>
              </div>
              <p>Clone from the current hook.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!(nextCurrentHook !== <span class="hljs-literal">null</span>)) {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Rendered more hooks than during the previous render.&quot;</span>);
        }
      }

      currentHook = nextCurrentHook;
      <span class="hljs-keyword">var</span> newHook = {
        <span class="hljs-attr">memoizedState</span>: currentHook.<span class="hljs-property">memoizedState</span>,
        <span class="hljs-attr">baseState</span>: currentHook.<span class="hljs-property">baseState</span>,
        <span class="hljs-attr">baseQueue</span>: currentHook.<span class="hljs-property">baseQueue</span>,
        <span class="hljs-attr">queue</span>: currentHook.<span class="hljs-property">queue</span>,
        <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
      };

      <span class="hljs-keyword">if</span> (workInProgressHook === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-671">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-671">&#x00a7;</a>
              </div>
              <p>This is the first hook in the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        currentlyRenderingFiber$<span class="hljs-number">1.</span>memoizedState = workInProgressHook = newHook;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-672">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-672">&#x00a7;</a>
              </div>
              <p>Append to the end of the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgressHook = workInProgressHook.<span class="hljs-property">next</span> = newHook;
      }
    }

    <span class="hljs-keyword">return</span> workInProgressHook;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFunctionComponentUpdateQueue</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">lastEffect</span>: <span class="hljs-literal">null</span>
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">basicStateReducer</span>(<span class="hljs-params">state, action</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-673">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-673">&#x00a7;</a>
              </div>
              <p>$FlowFixMe: Flow doesn’t like mixed types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> action === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title function_">action</span>(state) : action;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> initialState;

    <span class="hljs-keyword">if</span> (init !== <span class="hljs-literal">undefined</span>) {
      initialState = <span class="hljs-title function_">init</span>(initialArg);
    } <span class="hljs-keyword">else</span> {
      initialState = initialArg;
    }

    hook.<span class="hljs-property">memoizedState</span> = hook.<span class="hljs-property">baseState</span> = initialState;
    <span class="hljs-keyword">var</span> queue = hook.<span class="hljs-property">queue</span> = {
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">lastRenderedReducer</span>: reducer,
      <span class="hljs-attr">lastRenderedState</span>: initialState
    };
    <span class="hljs-keyword">var</span> dispatch = queue.<span class="hljs-property">dispatch</span> = dispatchAction.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, queue);
    <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> queue = hook.<span class="hljs-property">queue</span>;

    <span class="hljs-keyword">if</span> (!(queue !== <span class="hljs-literal">null</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span>);
      }
    }

    queue.<span class="hljs-property">lastRenderedReducer</span> = reducer;
    <span class="hljs-keyword">var</span> current = currentHook; <span class="hljs-comment">// The last rebase update that is NOT part of the base state.</span>

    <span class="hljs-keyword">var</span> baseQueue = current.<span class="hljs-property">baseQueue</span>; <span class="hljs-comment">// The last pending update that hasn&#x27;t been processed yet.</span>

    <span class="hljs-keyword">var</span> pendingQueue = queue.<span class="hljs-property">pending</span>;

    <span class="hljs-keyword">if</span> (pendingQueue !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-674">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-674">&#x00a7;</a>
              </div>
              <p>We have new updates that haven’t been processed yet.
We’ll add them to the base queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-675">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-675">&#x00a7;</a>
              </div>
              <p>Merge the pending queue and the base queue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> baseFirst = baseQueue.<span class="hljs-property">next</span>;
        <span class="hljs-keyword">var</span> pendingFirst = pendingQueue.<span class="hljs-property">next</span>;
        baseQueue.<span class="hljs-property">next</span> = pendingFirst;
        pendingQueue.<span class="hljs-property">next</span> = baseFirst;
      }

      {
        <span class="hljs-keyword">if</span> (current.<span class="hljs-property">baseQueue</span> !== baseQueue) {</pre></div></div>
            
        </li>
        
        
        <li id="section-676">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-676">&#x00a7;</a>
              </div>
              <p>Internal invariant that should never happen, but feasibly could in
the future if we implement resuming, or some form of that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Internal error: Expected work-in-progress queue to be a clone. &#x27;</span> + <span class="hljs-string">&#x27;This is a bug in React.&#x27;</span>);
        }
      }

      current.<span class="hljs-property">baseQueue</span> = baseQueue = pendingQueue;
      queue.<span class="hljs-property">pending</span> = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (baseQueue !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-677">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-677">&#x00a7;</a>
              </div>
              <p>We have a queue to process.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> first = baseQueue.<span class="hljs-property">next</span>;
      <span class="hljs-keyword">var</span> newState = current.<span class="hljs-property">baseState</span>;
      <span class="hljs-keyword">var</span> newBaseState = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> newBaseQueueFirst = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> newBaseQueueLast = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> update = first;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">var</span> updateLane = update.<span class="hljs-property">lane</span>;

        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSubsetOfLanes</span>(renderLanes, updateLane)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-678">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-678">&#x00a7;</a>
              </div>
              <p>Priority is insufficient. Skip this update. If this is the first
skipped update, the previous update/state is the new base
update/state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> clone = {
            <span class="hljs-attr">lane</span>: updateLane,
            <span class="hljs-attr">action</span>: update.<span class="hljs-property">action</span>,
            <span class="hljs-attr">eagerReducer</span>: update.<span class="hljs-property">eagerReducer</span>,
            <span class="hljs-attr">eagerState</span>: update.<span class="hljs-property">eagerState</span>,
            <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
          };

          <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) {
            newBaseQueueFirst = newBaseQueueLast = clone;
            newBaseState = newState;
          } <span class="hljs-keyword">else</span> {
            newBaseQueueLast = newBaseQueueLast.<span class="hljs-property">next</span> = clone;
          } <span class="hljs-comment">// Update the remaining priority in the queue.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-679">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-679">&#x00a7;</a>
              </div>
              <p>TODO: Don’t need to accumulate this. Instead, we can remove
renderLanes from the original lanes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          currentlyRenderingFiber$<span class="hljs-number">1.</span>lanes = <span class="hljs-title function_">mergeLanes</span>(currentlyRenderingFiber$<span class="hljs-number">1.</span>lanes, updateLane);
          <span class="hljs-title function_">markSkippedUpdateLanes</span>(updateLane);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-680">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-680">&#x00a7;</a>
              </div>
              <p>This update does have sufficient priority.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (newBaseQueueLast !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> _clone = {</pre></div></div>
            
        </li>
        
        
        <li id="section-681">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-681">&#x00a7;</a>
              </div>
              <p>This update is going to be committed so we never want uncommit
it. Using NoLane works because 0 is a subset of all bitmasks, so
this will never be skipped by the check above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-attr">lane</span>: <span class="hljs-title class_">NoLane</span>,
              <span class="hljs-attr">action</span>: update.<span class="hljs-property">action</span>,
              <span class="hljs-attr">eagerReducer</span>: update.<span class="hljs-property">eagerReducer</span>,
              <span class="hljs-attr">eagerState</span>: update.<span class="hljs-property">eagerState</span>,
              <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
            };
            newBaseQueueLast = newBaseQueueLast.<span class="hljs-property">next</span> = _clone;
          } <span class="hljs-comment">// Process this update.</span>


          <span class="hljs-keyword">if</span> (update.<span class="hljs-property">eagerReducer</span> === reducer) {</pre></div></div>
            
        </li>
        
        
        <li id="section-682">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-682">&#x00a7;</a>
              </div>
              <p>If this update was processed eagerly, and its reducer matches the
current reducer, we can use the eagerly computed state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            newState = update.<span class="hljs-property">eagerState</span>;
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> action = update.<span class="hljs-property">action</span>;
            newState = <span class="hljs-title function_">reducer</span>(newState, action);
          }
        }

        update = update.<span class="hljs-property">next</span>;
      } <span class="hljs-keyword">while</span> (update !== <span class="hljs-literal">null</span> &amp;&amp; update !== first);

      <span class="hljs-keyword">if</span> (newBaseQueueLast === <span class="hljs-literal">null</span>) {
        newBaseState = newState;
      } <span class="hljs-keyword">else</span> {
        newBaseQueueLast.<span class="hljs-property">next</span> = newBaseQueueFirst;
      } <span class="hljs-comment">// Mark that the fiber performed work, but only if the new state is</span></pre></div></div>
            
        </li>
        
        
        <li id="section-683">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-683">&#x00a7;</a>
              </div>
              <p>different from the current state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">objectIs</span>(newState, hook.<span class="hljs-property">memoizedState</span>)) {
        <span class="hljs-title function_">markWorkInProgressReceivedUpdate</span>();
      }

      hook.<span class="hljs-property">memoizedState</span> = newState;
      hook.<span class="hljs-property">baseState</span> = newBaseState;
      hook.<span class="hljs-property">baseQueue</span> = newBaseQueueLast;
      queue.<span class="hljs-property">lastRenderedState</span> = newState;
    }

    <span class="hljs-keyword">var</span> dispatch = queue.<span class="hljs-property">dispatch</span>;
    <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rerenderReducer</span>(<span class="hljs-params">reducer, initialArg, init</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> queue = hook.<span class="hljs-property">queue</span>;

    <span class="hljs-keyword">if</span> (!(queue !== <span class="hljs-literal">null</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span>);
      }
    }

    queue.<span class="hljs-property">lastRenderedReducer</span> = reducer; <span class="hljs-comment">// This is a re-render. Apply the new render phase updates to the previous</span></pre></div></div>
            
        </li>
        
        
        <li id="section-684">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-684">&#x00a7;</a>
              </div>
              <p>work-in-progress hook.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> dispatch = queue.<span class="hljs-property">dispatch</span>;
    <span class="hljs-keyword">var</span> lastRenderPhaseUpdate = queue.<span class="hljs-property">pending</span>;
    <span class="hljs-keyword">var</span> newState = hook.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (lastRenderPhaseUpdate !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-685">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-685">&#x00a7;</a>
              </div>
              <p>The queue doesn’t persist past this render pass.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      queue.<span class="hljs-property">pending</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> firstRenderPhaseUpdate = lastRenderPhaseUpdate.<span class="hljs-property">next</span>;
      <span class="hljs-keyword">var</span> update = firstRenderPhaseUpdate;

      <span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-686">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-686">&#x00a7;</a>
              </div>
              <p>Process this render phase update. We don’t have to check the
priority because it will always be the same as the current
render’s.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> action = update.<span class="hljs-property">action</span>;
        newState = <span class="hljs-title function_">reducer</span>(newState, action);
        update = update.<span class="hljs-property">next</span>;
      } <span class="hljs-keyword">while</span> (update !== firstRenderPhaseUpdate); <span class="hljs-comment">// Mark that the fiber performed work, but only if the new state is</span></pre></div></div>
            
        </li>
        
        
        <li id="section-687">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-687">&#x00a7;</a>
              </div>
              <p>different from the current state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">objectIs</span>(newState, hook.<span class="hljs-property">memoizedState</span>)) {
        <span class="hljs-title function_">markWorkInProgressReceivedUpdate</span>();
      }

      hook.<span class="hljs-property">memoizedState</span> = newState; <span class="hljs-comment">// Don&#x27;t persist the state accumulated from the render phase updates to</span></pre></div></div>
            
        </li>
        
        
        <li id="section-688">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-688">&#x00a7;</a>
              </div>
              <p>the base state unless the queue is empty.
TODO: Not sure if this is the desired semantics, but it’s what we
do for gDSFP. I can’t remember why.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (hook.<span class="hljs-property">baseQueue</span> === <span class="hljs-literal">null</span>) {
        hook.<span class="hljs-property">baseState</span> = newState;
      }

      queue.<span class="hljs-property">lastRenderedState</span> = newState;
    }

    <span class="hljs-keyword">return</span> [newState, dispatch];
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">readFromUnsubcribedMutableSource</span>(<span class="hljs-params">root, source, getSnapshot</span>) {
    {
      <span class="hljs-title function_">warnAboutMultipleRenderersDEV</span>(source);
    }

    <span class="hljs-keyword">var</span> getVersion = source.<span class="hljs-property">_getVersion</span>;
    <span class="hljs-keyword">var</span> version = <span class="hljs-title function_">getVersion</span>(source.<span class="hljs-property">_source</span>); <span class="hljs-comment">// Is it safe for this component to read from this source during the current render?</span>

    <span class="hljs-keyword">var</span> isSafeToReadFromSource = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Check the version first.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-689">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-689">&#x00a7;</a>
              </div>
              <p>If this render has already been started with a specific version,
we can use it alone to determine if we can safely read from the source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> currentRenderVersion = <span class="hljs-title function_">getWorkInProgressVersion</span>(source);

    <span class="hljs-keyword">if</span> (currentRenderVersion !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-690">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-690">&#x00a7;</a>
              </div>
              <p>It’s safe to read if the store hasn’t been mutated since the last time
we read something.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      isSafeToReadFromSource = currentRenderVersion === version;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-691">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-691">&#x00a7;</a>
              </div>
              <p>If there’s no version, then this is the first time we’ve read from the
source during the current render pass, so we need to do a bit more work.
What we need to determine is if there are any hooks that already
subscribed to the source, and if so, whether there are any pending
mutations that haven’t been synchronized yet.</p>
<p>If there are no pending mutations, then <code>root.mutableReadLanes</code> will be
empty, and we know we can safely read.</p>
<p>If there <em>are</em> pending mutations, we may still be able to safely read
if the currently rendering lanes are inclusive of the pending mutation
lanes, since that guarantees that the value we’re about to read from
the source is consistent with the values that we read during the most
recent mutation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      isSafeToReadFromSource = <span class="hljs-title function_">isSubsetOfLanes</span>(renderLanes, root.<span class="hljs-property">mutableReadLanes</span>);

      <span class="hljs-keyword">if</span> (isSafeToReadFromSource) {</pre></div></div>
            
        </li>
        
        
        <li id="section-692">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-692">&#x00a7;</a>
              </div>
              <p>If it’s safe to read from this source during the current render,
store the version in case other components read from it.
A changed version number will let those components know to throw and restart the render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">setWorkInProgressVersion</span>(source, version);
      }
    }

    <span class="hljs-keyword">if</span> (isSafeToReadFromSource) {
      <span class="hljs-keyword">var</span> snapshot = <span class="hljs-title function_">getSnapshot</span>(source.<span class="hljs-property">_source</span>);

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> snapshot === <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Mutable source should not return a function as the snapshot value. &#x27;</span> + <span class="hljs-string">&#x27;Functions may close over mutable values and cause tearing.&#x27;</span>);
        }
      }

      <span class="hljs-keyword">return</span> snapshot;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-693">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-693">&#x00a7;</a>
              </div>
              <p>This handles the special case of a mutable source being shared between renderers.
In that case, if the source is mutated between the first and second renderer,
The second renderer don’t know that it needs to reset the WIP version during unwind,
(because the hook only marks sources as dirty if it’s written to their WIP version).
That would cause this tear check to throw again and eventually be visible to the user.
We can avoid this infinite loop by explicitly marking the source as dirty.</p>
<p>This can lead to tearing in the first renderer when it resumes,
but there’s nothing we can do about that (short of throwing here and refusing to continue the render).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">markSourceAsDirty</span>(source);

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue.&quot;</span>);
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMutableSource</span>(<span class="hljs-params">hook, source, getSnapshot, subscribe</span>) {
    <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">getWorkInProgressRoot</span>();

    <span class="hljs-keyword">if</span> (!(root !== <span class="hljs-literal">null</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected a work-in-progress root. This is a bug in React. Please file an issue.&quot;</span>);
      }
    }

    <span class="hljs-keyword">var</span> getVersion = source.<span class="hljs-property">_getVersion</span>;
    <span class="hljs-keyword">var</span> version = <span class="hljs-title function_">getVersion</span>(source.<span class="hljs-property">_source</span>);
    <span class="hljs-keyword">var</span> dispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current; <span class="hljs-comment">// eslint-disable-next-line prefer-const</span>

    <span class="hljs-keyword">var</span> _dispatcher$useState = dispatcher.<span class="hljs-title function_">useState</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">readFromUnsubcribedMutableSource</span>(root, source, getSnapshot);
    }),
      currentSnapshot = _dispatcher$useState[<span class="hljs-number">0</span>],
      setSnapshot = _dispatcher$useState[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">var</span> snapshot = currentSnapshot; <span class="hljs-comment">// Grab a handle to the state hook as well.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-694">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-694">&#x00a7;</a>
              </div>
              <p>We use it to clear the pending update queue if we have a new source.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> stateHook = workInProgressHook;
    <span class="hljs-keyword">var</span> memoizedState = hook.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> refs = memoizedState.<span class="hljs-property">refs</span>;
    <span class="hljs-keyword">var</span> prevGetSnapshot = refs.<span class="hljs-property">getSnapshot</span>;
    <span class="hljs-keyword">var</span> prevSource = memoizedState.<span class="hljs-property">source</span>;
    <span class="hljs-keyword">var</span> prevSubscribe = memoizedState.<span class="hljs-property">subscribe</span>;
    <span class="hljs-keyword">var</span> fiber = currentlyRenderingFiber$<span class="hljs-number">1</span>;
    hook.<span class="hljs-property">memoizedState</span> = {
      <span class="hljs-attr">refs</span>: refs,
      <span class="hljs-attr">source</span>: source,
      <span class="hljs-attr">subscribe</span>: subscribe
    }; <span class="hljs-comment">// Sync the values needed by our subscription handler after each commit.</span>

    dispatcher.<span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      refs.<span class="hljs-property">getSnapshot</span> = getSnapshot; <span class="hljs-comment">// Normally the dispatch function for a state hook never changes,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-695">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-695">&#x00a7;</a>
              </div>
              <p>but this hook recreates the queue in certain cases  to avoid updates from stale sources.
handleChange() below needs to reference the dispatch function without re-subscribing,
so we use a ref to ensure that it always has the latest version.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      refs.<span class="hljs-property">setSnapshot</span> = setSnapshot; <span class="hljs-comment">// Check for a possible change between when we last rendered now.</span>

      <span class="hljs-keyword">var</span> maybeNewVersion = <span class="hljs-title function_">getVersion</span>(source.<span class="hljs-property">_source</span>);

      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">objectIs</span>(version, maybeNewVersion)) {
        <span class="hljs-keyword">var</span> maybeNewSnapshot = <span class="hljs-title function_">getSnapshot</span>(source.<span class="hljs-property">_source</span>);

        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> maybeNewSnapshot === <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Mutable source should not return a function as the snapshot value. &#x27;</span> + <span class="hljs-string">&#x27;Functions may close over mutable values and cause tearing.&#x27;</span>);
          }
        }

        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">objectIs</span>(snapshot, maybeNewSnapshot)) {
          <span class="hljs-title function_">setSnapshot</span>(maybeNewSnapshot);
          <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
          <span class="hljs-title function_">markRootMutableRead</span>(root, lane);
        } <span class="hljs-comment">// If the source mutated between render and now,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-696">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-696">&#x00a7;</a>
              </div>
              <p>there may be state updates already scheduled from the old source.
Entangle the updates so that they render in the same batch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-title function_">markRootEntangled</span>(root, root.<span class="hljs-property">mutableReadLanes</span>);
      }
    }, [getSnapshot, source, subscribe]); <span class="hljs-comment">// If we got a new source or subscribe function, re-subscribe in a passive effect.</span>

    dispatcher.<span class="hljs-title function_">useEffect</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">var</span> handleChange = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> latestGetSnapshot = refs.<span class="hljs-property">getSnapshot</span>;
        <span class="hljs-keyword">var</span> latestSetSnapshot = refs.<span class="hljs-property">setSnapshot</span>;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">latestSetSnapshot</span>(<span class="hljs-title function_">latestGetSnapshot</span>(source.<span class="hljs-property">_source</span>)); <span class="hljs-comment">// Record a pending mutable source update with the same expiration time.</span>

          <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
          <span class="hljs-title function_">markRootMutableRead</span>(root, lane);
        } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>
            
        </li>
        
        
        <li id="section-697">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-697">&#x00a7;</a>
              </div>
              <p>A selector might throw after a source mutation.
e.g. it might try to read from a part of the store that no longer exists.
In this case we should still schedule an update with React.
Worst case the selector will throw again and then an error boundary will handle it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">latestSetSnapshot</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">throw</span> error;
          });
        }
      };

      <span class="hljs-keyword">var</span> unsubscribe = <span class="hljs-title function_">subscribe</span>(source.<span class="hljs-property">_source</span>, handleChange);

      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> unsubscribe !== <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Mutable source subscribe function must return an unsubscribe function.&#x27;</span>);
        }
      }

      <span class="hljs-keyword">return</span> unsubscribe;
    }, [source, subscribe]); <span class="hljs-comment">// If any of the inputs to useMutableSource change, reading is potentially unsafe.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-698">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-698">&#x00a7;</a>
              </div>
              <p>If either the source or the subscription have changed we can’t can’t trust the update queue.
Maybe the source changed in a way that the old subscription ignored but the new one depends on.</p>
<p>If the getSnapshot function changed, we also shouldn’t rely on the update queue.
It’s possible that the underlying source was mutated between the when the last “change” event fired,
and when the current render (with the new getSnapshot function) is processed.</p>
<p>In both cases, we need to throw away pending updates (since they are no longer relevant)
and treat reading from the source as we do in the mount case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">objectIs</span>(prevGetSnapshot, getSnapshot) || !<span class="hljs-title function_">objectIs</span>(prevSource, source) || !<span class="hljs-title function_">objectIs</span>(prevSubscribe, subscribe)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-699">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-699">&#x00a7;</a>
              </div>
              <p>Create a new queue and setState method,
So if there are interleaved updates, they get pushed to the older queue.
When this becomes current, the previous queue and dispatch method will be discarded,
including any interleaving updates that occur.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> newQueue = {
        <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">lastRenderedReducer</span>: basicStateReducer,
        <span class="hljs-attr">lastRenderedState</span>: snapshot
      };
      newQueue.<span class="hljs-property">dispatch</span> = setSnapshot = dispatchAction.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, newQueue);
      stateHook.<span class="hljs-property">queue</span> = newQueue;
      stateHook.<span class="hljs-property">baseQueue</span> = <span class="hljs-literal">null</span>;
      snapshot = <span class="hljs-title function_">readFromUnsubcribedMutableSource</span>(root, source, getSnapshot);
      stateHook.<span class="hljs-property">memoizedState</span> = stateHook.<span class="hljs-property">baseState</span> = snapshot;
    }

    <span class="hljs-keyword">return</span> snapshot;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountMutableSource</span>(<span class="hljs-params">source, getSnapshot, subscribe</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();
    hook.<span class="hljs-property">memoizedState</span> = {
      <span class="hljs-attr">refs</span>: {
        <span class="hljs-attr">getSnapshot</span>: getSnapshot,
        <span class="hljs-attr">setSnapshot</span>: <span class="hljs-literal">null</span>
      },
      <span class="hljs-attr">source</span>: source,
      <span class="hljs-attr">subscribe</span>: subscribe
    };
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMutableSource</span>(hook, source, getSnapshot, subscribe);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateMutableSource</span>(<span class="hljs-params">source, getSnapshot, subscribe</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">useMutableSource</span>(hook, source, getSnapshot, subscribe);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountState</span>(<span class="hljs-params">initialState</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> initialState === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-700">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-700">&#x00a7;</a>
              </div>
              <p>$FlowFixMe: Flow doesn’t like mixed types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      initialState = <span class="hljs-title function_">initialState</span>();
    }

    hook.<span class="hljs-property">memoizedState</span> = hook.<span class="hljs-property">baseState</span> = initialState;
    <span class="hljs-keyword">var</span> queue = hook.<span class="hljs-property">queue</span> = {
      <span class="hljs-attr">pending</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">dispatch</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">lastRenderedReducer</span>: basicStateReducer,
      <span class="hljs-attr">lastRenderedState</span>: initialState
    };
    <span class="hljs-keyword">var</span> dispatch = queue.<span class="hljs-property">dispatch</span> = dispatchAction.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>, queue);
    <span class="hljs-keyword">return</span> [hook.<span class="hljs-property">memoizedState</span>, dispatch];
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateState</span>(<span class="hljs-params">initialState</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateReducer</span>(basicStateReducer);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rerenderState</span>(<span class="hljs-params">initialState</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderReducer</span>(basicStateReducer);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushEffect</span>(<span class="hljs-params">tag, create, destroy, deps</span>) {
    <span class="hljs-keyword">var</span> effect = {
      <span class="hljs-attr">tag</span>: tag,
      <span class="hljs-attr">create</span>: create,
      <span class="hljs-attr">destroy</span>: destroy,
      <span class="hljs-attr">deps</span>: deps,</pre></div></div>
            
        </li>
        
        
        <li id="section-701">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-701">&#x00a7;</a>
              </div>
              <p>Circular</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
    };
    <span class="hljs-keyword">var</span> componentUpdateQueue = currentlyRenderingFiber$<span class="hljs-number">1.</span>updateQueue;

    <span class="hljs-keyword">if</span> (componentUpdateQueue === <span class="hljs-literal">null</span>) {
      componentUpdateQueue = <span class="hljs-title function_">createFunctionComponentUpdateQueue</span>();
      currentlyRenderingFiber$<span class="hljs-number">1.</span>updateQueue = componentUpdateQueue;
      componentUpdateQueue.<span class="hljs-property">lastEffect</span> = effect.<span class="hljs-property">next</span> = effect;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> lastEffect = componentUpdateQueue.<span class="hljs-property">lastEffect</span>;

      <span class="hljs-keyword">if</span> (lastEffect === <span class="hljs-literal">null</span>) {
        componentUpdateQueue.<span class="hljs-property">lastEffect</span> = effect.<span class="hljs-property">next</span> = effect;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> firstEffect = lastEffect.<span class="hljs-property">next</span>;
        lastEffect.<span class="hljs-property">next</span> = effect;
        effect.<span class="hljs-property">next</span> = firstEffect;
        componentUpdateQueue.<span class="hljs-property">lastEffect</span> = effect;
      }
    }

    <span class="hljs-keyword">return</span> effect;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountRef</span>(<span class="hljs-params">initialValue</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> ref = {
      <span class="hljs-attr">current</span>: initialValue
    };

    {
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(ref);
    }

    hook.<span class="hljs-property">memoizedState</span> = ref;
    <span class="hljs-keyword">return</span> ref;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateRef</span>(<span class="hljs-params">initialValue</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();
    <span class="hljs-keyword">return</span> hook.<span class="hljs-property">memoizedState</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountEffectImpl</span>(<span class="hljs-params">fiberFlags, hookFlags, create, deps</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
    currentlyRenderingFiber$<span class="hljs-number">1.</span>flags |= fiberFlags;
    hook.<span class="hljs-property">memoizedState</span> = <span class="hljs-title function_">pushEffect</span>(<span class="hljs-title class_">HasEffect</span> | hookFlags, create, <span class="hljs-literal">undefined</span>, nextDeps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateEffectImpl</span>(<span class="hljs-params">fiberFlags, hookFlags, create, deps</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
    <span class="hljs-keyword">var</span> destroy = <span class="hljs-literal">undefined</span>;

    <span class="hljs-keyword">if</span> (currentHook !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> prevEffect = currentHook.<span class="hljs-property">memoizedState</span>;
      destroy = prevEffect.<span class="hljs-property">destroy</span>;

      <span class="hljs-keyword">if</span> (nextDeps !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevDeps = prevEffect.<span class="hljs-property">deps</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) {
          <span class="hljs-title function_">pushEffect</span>(hookFlags, create, destroy, nextDeps);
          <span class="hljs-keyword">return</span>;
        }
      }
    }

    currentlyRenderingFiber$<span class="hljs-number">1.</span>flags |= fiberFlags;
    hook.<span class="hljs-property">memoizedState</span> = <span class="hljs-title function_">pushEffect</span>(<span class="hljs-title class_">HasEffect</span> | hookFlags, create, destroy, nextDeps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountEffect</span>(<span class="hljs-params">create, deps</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-702">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-702">&#x00a7;</a>
              </div>
              <p>$FlowExpectedError - jest isn’t a global, and isn’t recognized outside of tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;undefined&#x27;</span> !== <span class="hljs-keyword">typeof</span> jest) {
        <span class="hljs-title function_">warnIfNotCurrentlyActingEffectsInDEV</span>(currentlyRenderingFiber$<span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountEffectImpl</span>(<span class="hljs-title class_">Update</span> | <span class="hljs-title class_">Passive</span>, <span class="hljs-title class_">Passive</span>$<span class="hljs-number">1</span>, create, deps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateEffect</span>(<span class="hljs-params">create, deps</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-703">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-703">&#x00a7;</a>
              </div>
              <p>$FlowExpectedError - jest isn’t a global, and isn’t recognized outside of tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;undefined&#x27;</span> !== <span class="hljs-keyword">typeof</span> jest) {
        <span class="hljs-title function_">warnIfNotCurrentlyActingEffectsInDEV</span>(currentlyRenderingFiber$<span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateEffectImpl</span>(<span class="hljs-title class_">Update</span> | <span class="hljs-title class_">Passive</span>, <span class="hljs-title class_">Passive</span>$<span class="hljs-number">1</span>, create, deps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountLayoutEffect</span>(<span class="hljs-params">create, deps</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountEffectImpl</span>(<span class="hljs-title class_">Update</span>, <span class="hljs-title class_">Layout</span>, create, deps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateLayoutEffect</span>(<span class="hljs-params">create, deps</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateEffectImpl</span>(<span class="hljs-title class_">Update</span>, <span class="hljs-title class_">Layout</span>, create, deps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">imperativeHandleEffect</span>(<span class="hljs-params">create, ref</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">var</span> refCallback = ref;

      <span class="hljs-keyword">var</span> _inst = <span class="hljs-title function_">create</span>();

      <span class="hljs-title function_">refCallback</span>(_inst);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">refCallback</span>(<span class="hljs-literal">null</span>);
      };
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span> &amp;&amp; ref !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">var</span> refObject = ref;

      {
        <span class="hljs-keyword">if</span> (!refObject.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;current&#x27;</span>)) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected useImperativeHandle() first argument to either be a &#x27;</span> + <span class="hljs-string">&#x27;ref callback or React.createRef() object. Instead received: %s.&#x27;</span>, <span class="hljs-string">&#x27;an object with keys {&#x27;</span> + <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(refObject).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;, &#x27;</span>) + <span class="hljs-string">&#x27;}&#x27;</span>);
        }
      }

      <span class="hljs-keyword">var</span> _inst2 = <span class="hljs-title function_">create</span>();

      refObject.<span class="hljs-property">current</span> = _inst2;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        refObject.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      };
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountImperativeHandle</span>(<span class="hljs-params">ref, create, deps</span>) {
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> create !== <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected useImperativeHandle() second argument to be a function &#x27;</span> + <span class="hljs-string">&#x27;that creates a handle. Instead received: %s.&#x27;</span>, create !== <span class="hljs-literal">null</span> ? <span class="hljs-keyword">typeof</span> create : <span class="hljs-string">&#x27;null&#x27;</span>);
      }
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If deps are provided, should we skip comparing the ref itself?</span>


    <span class="hljs-keyword">var</span> effectDeps = deps !== <span class="hljs-literal">null</span> &amp;&amp; deps !== <span class="hljs-literal">undefined</span> ? deps.<span class="hljs-title function_">concat</span>([ref]) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountEffectImpl</span>(<span class="hljs-title class_">Update</span>, <span class="hljs-title class_">Layout</span>, imperativeHandleEffect.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, create, ref), effectDeps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateImperativeHandle</span>(<span class="hljs-params">ref, create, deps</span>) {
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> create !== <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected useImperativeHandle() second argument to be a function &#x27;</span> + <span class="hljs-string">&#x27;that creates a handle. Instead received: %s.&#x27;</span>, create !== <span class="hljs-literal">null</span> ? <span class="hljs-keyword">typeof</span> create : <span class="hljs-string">&#x27;null&#x27;</span>);
      }
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If deps are provided, should we skip comparing the ref itself?</span>


    <span class="hljs-keyword">var</span> effectDeps = deps !== <span class="hljs-literal">null</span> &amp;&amp; deps !== <span class="hljs-literal">undefined</span> ? deps.<span class="hljs-title function_">concat</span>([ref]) : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateEffectImpl</span>(<span class="hljs-title class_">Update</span>, <span class="hljs-title class_">Layout</span>, imperativeHandleEffect.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, create, ref), effectDeps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountDebugValue</span>(<span class="hljs-params">value, formatterFn</span>) {<span class="hljs-comment">// This hook is normally a no-op.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-704">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-704">&#x00a7;</a>
              </div>
              <p>The react-debug-hooks package injects its own implementation
so that e.g. DevTools can display custom hook values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  }

  <span class="hljs-keyword">var</span> updateDebugValue = mountDebugValue;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountCallback</span>(<span class="hljs-params">callback, deps</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
    hook.<span class="hljs-property">memoizedState</span> = [callback, nextDeps];
    <span class="hljs-keyword">return</span> callback;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateCallback</span>(<span class="hljs-params">callback, deps</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
    <span class="hljs-keyword">var</span> prevState = hook.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (nextDeps !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevDeps = prevState[<span class="hljs-number">1</span>];

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) {
          <span class="hljs-keyword">return</span> prevState[<span class="hljs-number">0</span>];
        }
      }
    }

    hook.<span class="hljs-property">memoizedState</span> = [callback, nextDeps];
    <span class="hljs-keyword">return</span> callback;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountMemo</span>(<span class="hljs-params">nextCreate, deps</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">mountWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
    <span class="hljs-keyword">var</span> nextValue = <span class="hljs-title function_">nextCreate</span>();
    hook.<span class="hljs-property">memoizedState</span> = [nextValue, nextDeps];
    <span class="hljs-keyword">return</span> nextValue;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateMemo</span>(<span class="hljs-params">nextCreate, deps</span>) {
    <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">updateWorkInProgressHook</span>();
    <span class="hljs-keyword">var</span> nextDeps = deps === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : deps;
    <span class="hljs-keyword">var</span> prevState = hook.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-705">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-705">&#x00a7;</a>
              </div>
              <p>Assume these are defined. If they’re not, areHookInputsEqual will warn.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (nextDeps !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevDeps = prevState[<span class="hljs-number">1</span>];

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) {
          <span class="hljs-keyword">return</span> prevState[<span class="hljs-number">0</span>];
        }
      }
    }

    <span class="hljs-keyword">var</span> nextValue = <span class="hljs-title function_">nextCreate</span>();
    hook.<span class="hljs-property">memoizedState</span> = [nextValue, nextDeps];
    <span class="hljs-keyword">return</span> nextValue;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountDeferredValue</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">var</span> _mountState = <span class="hljs-title function_">mountState</span>(value),
      prevValue = _mountState[<span class="hljs-number">0</span>],
      setValue = _mountState[<span class="hljs-number">1</span>];

    <span class="hljs-title function_">mountEffect</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">var</span> prevTransition = <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition;
      <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = <span class="hljs-number">1</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">setValue</span>(value);
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = prevTransition;
      }
    }, [value]);
    <span class="hljs-keyword">return</span> prevValue;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDeferredValue</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">var</span> _updateState = <span class="hljs-title function_">updateState</span>(),
      prevValue = _updateState[<span class="hljs-number">0</span>],
      setValue = _updateState[<span class="hljs-number">1</span>];

    <span class="hljs-title function_">updateEffect</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">var</span> prevTransition = <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition;
      <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = <span class="hljs-number">1</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">setValue</span>(value);
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = prevTransition;
      }
    }, [value]);
    <span class="hljs-keyword">return</span> prevValue;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rerenderDeferredValue</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">var</span> _rerenderState = <span class="hljs-title function_">rerenderState</span>(),
      prevValue = _rerenderState[<span class="hljs-number">0</span>],
      setValue = _rerenderState[<span class="hljs-number">1</span>];

    <span class="hljs-title function_">updateEffect</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">var</span> prevTransition = <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition;
      <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = <span class="hljs-number">1</span>;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">setValue</span>(value);
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = prevTransition;
      }
    }, [value]);
    <span class="hljs-keyword">return</span> prevValue;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">startTransition</span>(<span class="hljs-params">setPending, callback</span>) {
    <span class="hljs-keyword">var</span> priorityLevel = <span class="hljs-title function_">getCurrentPriorityLevel</span>();

    {
      <span class="hljs-title function_">runWithPriority$1</span>(priorityLevel &lt; <span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">2</span> ? <span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">2</span> : priorityLevel, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">setPending</span>(<span class="hljs-literal">true</span>);
      });
      <span class="hljs-title function_">runWithPriority$1</span>(priorityLevel &gt; <span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span> ? <span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span> : priorityLevel, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">var</span> prevTransition = <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition;
        <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = <span class="hljs-number">1</span>;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">setPending</span>(<span class="hljs-literal">false</span>);
          <span class="hljs-title function_">callback</span>();
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentBatchConfig</span>$<span class="hljs-number">1.</span>transition = prevTransition;
        }
      });
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountTransition</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> _mountState2 = <span class="hljs-title function_">mountState</span>(<span class="hljs-literal">false</span>),
      isPending = _mountState2[<span class="hljs-number">0</span>],
      setPending = _mountState2[<span class="hljs-number">1</span>]; <span class="hljs-comment">// The `start` method can be stored on a ref, since `setPending`</span></pre></div></div>
            
        </li>
        
        
        <li id="section-706">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-706">&#x00a7;</a>
              </div>
              <p>never changes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> start = startTransition.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, setPending);
    <span class="hljs-title function_">mountRef</span>(start);
    <span class="hljs-keyword">return</span> [start, isPending];
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateTransition</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> _updateState2 = <span class="hljs-title function_">updateState</span>(),
      isPending = _updateState2[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">var</span> startRef = <span class="hljs-title function_">updateRef</span>();
    <span class="hljs-keyword">var</span> start = startRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">return</span> [start, isPending];
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rerenderTransition</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> _rerenderState2 = <span class="hljs-title function_">rerenderState</span>(),
      isPending = _rerenderState2[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">var</span> startRef = <span class="hljs-title function_">updateRef</span>();
    <span class="hljs-keyword">var</span> start = startRef.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">return</span> [start, isPending];
  }

  <span class="hljs-keyword">var</span> isUpdatingOpaqueValueInRenderPhase = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getIsUpdatingOpaqueValueInRenderPhaseInDEV</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">return</span> isUpdatingOpaqueValueInRenderPhase;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnOnOpaqueIdentifierAccessInDEV</span>(<span class="hljs-params">fiber</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-707">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-707">&#x00a7;</a>
              </div>
              <p>TODO: Should warn in effects and callbacks, too</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> name = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsRendering</span>() &amp;&amp; !didWarnAboutUseOpaqueIdentifier[name]) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The object passed back from useOpaqueIdentifier is meant to be &#x27;</span> + <span class="hljs-string">&#x27;passed through to attributes only. Do not read the &#x27;</span> + <span class="hljs-string">&#x27;value directly.&#x27;</span>);

        didWarnAboutUseOpaqueIdentifier[name] = <span class="hljs-literal">true</span>;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountOpaqueIdentifier</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> makeId = makeClientIdInDEV.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, warnOnOpaqueIdentifierAccessInDEV.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, currentlyRenderingFiber$<span class="hljs-number">1</span>));

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsHydrating</span>()) {
      <span class="hljs-keyword">var</span> didUpgrade = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> fiber = currentlyRenderingFiber$<span class="hljs-number">1</span>;

      <span class="hljs-keyword">var</span> readValue = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">if</span> (!didUpgrade) {</pre></div></div>
            
        </li>
        
        
        <li id="section-708">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-708">&#x00a7;</a>
              </div>
              <p>Only upgrade once. This works even inside the render phase because
the update is added to a shared queue, which outlasts the
in-progress render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          didUpgrade = <span class="hljs-literal">true</span>;

          {
            isUpdatingOpaqueValueInRenderPhase = <span class="hljs-literal">true</span>;
            <span class="hljs-title function_">setId</span>(<span class="hljs-title function_">makeId</span>());
            isUpdatingOpaqueValueInRenderPhase = <span class="hljs-literal">false</span>;
            <span class="hljs-title function_">warnOnOpaqueIdentifierAccessInDEV</span>(fiber);
          }
        }

        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly.&quot;</span>);
          }
        }
      };

      <span class="hljs-keyword">var</span> id = <span class="hljs-title function_">makeOpaqueHydratingObject</span>(readValue);
      <span class="hljs-keyword">var</span> setId = <span class="hljs-title function_">mountState</span>(id)[<span class="hljs-number">1</span>];

      <span class="hljs-keyword">if</span> ((currentlyRenderingFiber$<span class="hljs-number">1.</span>mode &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {
        currentlyRenderingFiber$<span class="hljs-number">1.</span>flags |= <span class="hljs-title class_">Update</span> | <span class="hljs-title class_">Passive</span>;
        <span class="hljs-title function_">pushEffect</span>(<span class="hljs-title class_">HasEffect</span> | <span class="hljs-title class_">Passive</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-title function_">setId</span>(<span class="hljs-title function_">makeId</span>());
        }, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>);
      }

      <span class="hljs-keyword">return</span> id;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> _id = <span class="hljs-title function_">makeId</span>();

      <span class="hljs-title function_">mountState</span>(_id);
      <span class="hljs-keyword">return</span> _id;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateOpaqueIdentifier</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> id = <span class="hljs-title function_">updateState</span>()[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> id;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">rerenderOpaqueIdentifier</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> id = <span class="hljs-title function_">rerenderState</span>()[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">return</span> id;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchAction</span>(<span class="hljs-params">fiber, queue, action</span>) {
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">3</span>] === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;State updates from the useState() and useReducer() Hooks don&#x27;t support the &quot;</span> + <span class="hljs-string">&#x27;second callback argument. To execute a side effect after &#x27;</span> + <span class="hljs-string">&#x27;rendering, declare it in the component body with useEffect().&#x27;</span>);
      }
    }

    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
    <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
    <span class="hljs-keyword">var</span> update = {
      <span class="hljs-attr">lane</span>: lane,
      <span class="hljs-attr">action</span>: action,
      <span class="hljs-attr">eagerReducer</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">eagerState</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">next</span>: <span class="hljs-literal">null</span>
    }; <span class="hljs-comment">// Append the update to the end of the list.</span>

    <span class="hljs-keyword">var</span> pending = queue.<span class="hljs-property">pending</span>;

    <span class="hljs-keyword">if</span> (pending === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-709">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-709">&#x00a7;</a>
              </div>
              <p>This is the first update. Create a circular list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      update.<span class="hljs-property">next</span> = update;
    } <span class="hljs-keyword">else</span> {
      update.<span class="hljs-property">next</span> = pending.<span class="hljs-property">next</span>;
      pending.<span class="hljs-property">next</span> = update;
    }

    queue.<span class="hljs-property">pending</span> = update;
    <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (fiber === currentlyRenderingFiber$<span class="hljs-number">1</span> || alternate !== <span class="hljs-literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber$<span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-710">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-710">&#x00a7;</a>
              </div>
              <p>This is a render phase update. Stash it in a lazily-created map of
queue -&gt; linked list of updates. After this render pass, we’ll restart
and apply the stashed updates on top of the work-in-progress hook.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">lanes</span> === <span class="hljs-title class_">NoLanes</span> &amp;&amp; (alternate === <span class="hljs-literal">null</span> || alternate.<span class="hljs-property">lanes</span> === <span class="hljs-title class_">NoLanes</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-711">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-711">&#x00a7;</a>
              </div>
              <p>The queue is currently empty, which means we can eagerly compute the
next state before entering the render phase. If the new state is the
same as the current state, we may be able to bail out entirely.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> lastRenderedReducer = queue.<span class="hljs-property">lastRenderedReducer</span>;

        <span class="hljs-keyword">if</span> (lastRenderedReducer !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> prevDispatcher;

          {
            prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
            <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;
          }

          <span class="hljs-keyword">try</span> {
            <span class="hljs-keyword">var</span> currentState = queue.<span class="hljs-property">lastRenderedState</span>;
            <span class="hljs-keyword">var</span> eagerState = <span class="hljs-title function_">lastRenderedReducer</span>(currentState, action); <span class="hljs-comment">// Stash the eagerly computed state, and the reducer used to compute</span></pre></div></div>
            
        </li>
        
        
        <li id="section-712">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-712">&#x00a7;</a>
              </div>
              <p>it, on the update object. If the reducer hasn’t changed by the
time we enter the render phase, then the eager state can be used
without calling the reducer again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            update.<span class="hljs-property">eagerReducer</span> = lastRenderedReducer;
            update.<span class="hljs-property">eagerState</span> = eagerState;

            <span class="hljs-keyword">if</span> (<span class="hljs-title function_">objectIs</span>(eagerState, currentState)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-713">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-713">&#x00a7;</a>
              </div>
              <p>Fast path. We can bail out without scheduling React to re-render.
It’s still possible that we’ll need to rebase this update later,
if the component re-renders for a different reason and by that
time the reducer has changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">return</span>;
            }
          } <span class="hljs-keyword">catch</span> (error) {<span class="hljs-comment">// Suppress the error. It will throw again in the render phase.</span>
          } <span class="hljs-keyword">finally</span> {
            {
              <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
            }
          }
        }
      }

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-714">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-714">&#x00a7;</a>
              </div>
              <p>$FlowExpectedError - jest isn’t a global, and isn’t recognized outside of tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;undefined&#x27;</span> !== <span class="hljs-keyword">typeof</span> jest) {
          <span class="hljs-title function_">warnIfNotScopedWithMatchingAct</span>(fiber);
          <span class="hljs-title function_">warnIfNotCurrentlyActingUpdatesInDev</span>(fiber);
        }
      }

      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);
    }

    {
      <span class="hljs-title function_">markStateUpdateScheduled</span>(fiber, lane);
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ContextOnlyDispatcher</span> = {
    <span class="hljs-attr">readContext</span>: readContext,
    <span class="hljs-attr">useCallback</span>: throwInvalidHookError,
    <span class="hljs-attr">useContext</span>: throwInvalidHookError,
    <span class="hljs-attr">useEffect</span>: throwInvalidHookError,
    <span class="hljs-attr">useImperativeHandle</span>: throwInvalidHookError,
    <span class="hljs-attr">useLayoutEffect</span>: throwInvalidHookError,
    <span class="hljs-attr">useMemo</span>: throwInvalidHookError,
    <span class="hljs-attr">useReducer</span>: throwInvalidHookError,
    <span class="hljs-attr">useRef</span>: throwInvalidHookError,
    <span class="hljs-attr">useState</span>: throwInvalidHookError,
    <span class="hljs-attr">useDebugValue</span>: throwInvalidHookError,
    <span class="hljs-attr">useDeferredValue</span>: throwInvalidHookError,
    <span class="hljs-attr">useTransition</span>: throwInvalidHookError,
    <span class="hljs-attr">useMutableSource</span>: throwInvalidHookError,
    <span class="hljs-attr">useOpaqueIdentifier</span>: throwInvalidHookError,
    <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
  };
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HooksDispatcherOnMountIn</span>DEV = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HooksDispatcherOnMountWithHookTypesIn</span>DEV = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HooksDispatcherOnUpdateIn</span>DEV = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">HooksDispatcherOnRerenderIn</span>DEV = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">InvalidNestedHooksDispatcherOnRerenderIn</span>DEV = <span class="hljs-literal">null</span>;

  {
    <span class="hljs-keyword">var</span> warnInvalidContextAccess = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Context can only be read while React is rendering. &#x27;</span> + <span class="hljs-string">&#x27;In classes, you can read it in the render method or getDerivedStateFromProps. &#x27;</span> + <span class="hljs-string">&#x27;In function components, you can read it directly in the function body, but not &#x27;</span> + <span class="hljs-string">&#x27;inside Hooks like useReducer() or useMemo().&#x27;</span>);
    };

    <span class="hljs-keyword">var</span> warnInvalidHookAccess = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. &#x27;</span> + <span class="hljs-string">&#x27;You can only call Hooks at the top level of your React function. &#x27;</span> + <span class="hljs-string">&#x27;For more information, see &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/rules-of-hooks&#x27;</span>);
    };

    <span class="hljs-title class_">HooksDispatcherOnMountIn</span>DEV = {
      <span class="hljs-attr">readContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useCallback&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-title function_">checkDepsAreArrayDev</span>(deps);
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountCallback</span>(callback, deps);
      },
      <span class="hljs-attr">useContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useContext&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useEffect&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-title function_">checkDepsAreArrayDev</span>(deps);
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountEffect</span>(create, deps);
      },
      <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useImperativeHandle&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-title function_">checkDepsAreArrayDev</span>(deps);
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountImperativeHandle</span>(ref, create, deps);
      },
      <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useLayoutEffect&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-title function_">checkDepsAreArrayDev</span>(deps);
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountLayoutEffect</span>(create, deps);
      },
      <span class="hljs-attr">useMemo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMemo&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-title function_">checkDepsAreArrayDev</span>(deps);
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountMemo</span>(create, deps);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useReducer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useReducer&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountReducer</span>(reducer, initialArg, init);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useRef</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useRef&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountRef</span>(initialValue);
      },
      <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useState&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountState</span>(initialState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useDebugValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDebugValue&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountDebugValue</span>();
      },
      <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDeferredValue&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountDeferredValue</span>(value);
      },
      <span class="hljs-attr">useTransition</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useTransition&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountTransition</span>();
      },
      <span class="hljs-attr">useMutableSource</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">source, getSnapshot, subscribe</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMutableSource&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountMutableSource</span>(source, getSnapshot, subscribe);
      },
      <span class="hljs-attr">useOpaqueIdentifier</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useOpaqueIdentifier&#x27;</span>;
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountOpaqueIdentifier</span>();
      },
      <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
    };
    <span class="hljs-title class_">HooksDispatcherOnMountWithHookTypesIn</span>DEV = {
      <span class="hljs-attr">readContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useCallback&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountCallback</span>(callback, deps);
      },
      <span class="hljs-attr">useContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useContext&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useEffect&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountEffect</span>(create, deps);
      },
      <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useImperativeHandle&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountImperativeHandle</span>(ref, create, deps);
      },
      <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useLayoutEffect&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountLayoutEffect</span>(create, deps);
      },
      <span class="hljs-attr">useMemo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMemo&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountMemo</span>(create, deps);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useReducer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useReducer&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountReducer</span>(reducer, initialArg, init);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useRef</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useRef&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountRef</span>(initialValue);
      },
      <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useState&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountState</span>(initialState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useDebugValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDebugValue&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountDebugValue</span>();
      },
      <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDeferredValue&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountDeferredValue</span>(value);
      },
      <span class="hljs-attr">useTransition</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useTransition&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountTransition</span>();
      },
      <span class="hljs-attr">useMutableSource</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">source, getSnapshot, subscribe</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMutableSource&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountMutableSource</span>(source, getSnapshot, subscribe);
      },
      <span class="hljs-attr">useOpaqueIdentifier</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useOpaqueIdentifier&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountOpaqueIdentifier</span>();
      },
      <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
    };
    <span class="hljs-title class_">HooksDispatcherOnUpdateIn</span>DEV = {
      <span class="hljs-attr">readContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useCallback&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateCallback</span>(callback, deps);
      },
      <span class="hljs-attr">useContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useContext&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useEffect&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateEffect</span>(create, deps);
      },
      <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useImperativeHandle&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateImperativeHandle</span>(ref, create, deps);
      },
      <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useLayoutEffect&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateLayoutEffect</span>(create, deps);
      },
      <span class="hljs-attr">useMemo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMemo&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMemo</span>(create, deps);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useReducer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useReducer&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateReducer</span>(reducer, initialArg, init);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useRef</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useRef&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateRef</span>();
      },
      <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useState&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateState</span>(initialState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useDebugValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDebugValue&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateDebugValue</span>();
      },
      <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDeferredValue&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateDeferredValue</span>(value);
      },
      <span class="hljs-attr">useTransition</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useTransition&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateTransition</span>();
      },
      <span class="hljs-attr">useMutableSource</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">source, getSnapshot, subscribe</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMutableSource&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMutableSource</span>(source, getSnapshot, subscribe);
      },
      <span class="hljs-attr">useOpaqueIdentifier</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useOpaqueIdentifier&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateOpaqueIdentifier</span>();
      },
      <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
    };
    <span class="hljs-title class_">HooksDispatcherOnRerenderIn</span>DEV = {
      <span class="hljs-attr">readContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useCallback&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateCallback</span>(callback, deps);
      },
      <span class="hljs-attr">useContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useContext&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useEffect&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateEffect</span>(create, deps);
      },
      <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useImperativeHandle&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateImperativeHandle</span>(ref, create, deps);
      },
      <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useLayoutEffect&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateLayoutEffect</span>(create, deps);
      },
      <span class="hljs-attr">useMemo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMemo&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnRerenderIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMemo</span>(create, deps);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useReducer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useReducer&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnRerenderIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderReducer</span>(reducer, initialArg, init);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useRef</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useRef&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateRef</span>();
      },
      <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useState&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnRerenderIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderState</span>(initialState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useDebugValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDebugValue&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateDebugValue</span>();
      },
      <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDeferredValue&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderDeferredValue</span>(value);
      },
      <span class="hljs-attr">useTransition</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useTransition&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderTransition</span>();
      },
      <span class="hljs-attr">useMutableSource</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">source, getSnapshot, subscribe</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMutableSource&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMutableSource</span>(source, getSnapshot, subscribe);
      },
      <span class="hljs-attr">useOpaqueIdentifier</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useOpaqueIdentifier&#x27;</span>;
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderOpaqueIdentifier</span>();
      },
      <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
    };
    <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV = {
      <span class="hljs-attr">readContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        <span class="hljs-title function_">warnInvalidContextAccess</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useCallback&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountCallback</span>(callback, deps);
      },
      <span class="hljs-attr">useContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useContext&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useEffect&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountEffect</span>(create, deps);
      },
      <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useImperativeHandle&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountImperativeHandle</span>(ref, create, deps);
      },
      <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useLayoutEffect&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountLayoutEffect</span>(create, deps);
      },
      <span class="hljs-attr">useMemo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMemo&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountMemo</span>(create, deps);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useReducer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useReducer&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountReducer</span>(reducer, initialArg, init);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useRef</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useRef&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountRef</span>(initialValue);
      },
      <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useState&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnMountIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountState</span>(initialState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useDebugValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDebugValue&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountDebugValue</span>();
      },
      <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDeferredValue&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountDeferredValue</span>(value);
      },
      <span class="hljs-attr">useTransition</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useTransition&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountTransition</span>();
      },
      <span class="hljs-attr">useMutableSource</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">source, getSnapshot, subscribe</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMutableSource&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountMutableSource</span>(source, getSnapshot, subscribe);
      },
      <span class="hljs-attr">useOpaqueIdentifier</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useOpaqueIdentifier&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">mountHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountOpaqueIdentifier</span>();
      },
      <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
    };
    <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV = {
      <span class="hljs-attr">readContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        <span class="hljs-title function_">warnInvalidContextAccess</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useCallback&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateCallback</span>(callback, deps);
      },
      <span class="hljs-attr">useContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useContext&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useEffect&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateEffect</span>(create, deps);
      },
      <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useImperativeHandle&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateImperativeHandle</span>(ref, create, deps);
      },
      <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useLayoutEffect&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateLayoutEffect</span>(create, deps);
      },
      <span class="hljs-attr">useMemo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMemo&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMemo</span>(create, deps);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useReducer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useReducer&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateReducer</span>(reducer, initialArg, init);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useRef</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useRef&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateRef</span>();
      },
      <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useState&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateState</span>(initialState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useDebugValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDebugValue&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateDebugValue</span>();
      },
      <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDeferredValue&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateDeferredValue</span>(value);
      },
      <span class="hljs-attr">useTransition</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useTransition&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateTransition</span>();
      },
      <span class="hljs-attr">useMutableSource</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">source, getSnapshot, subscribe</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMutableSource&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMutableSource</span>(source, getSnapshot, subscribe);
      },
      <span class="hljs-attr">useOpaqueIdentifier</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useOpaqueIdentifier&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateOpaqueIdentifier</span>();
      },
      <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
    };
    <span class="hljs-title class_">InvalidNestedHooksDispatcherOnRerenderIn</span>DEV = {
      <span class="hljs-attr">readContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        <span class="hljs-title function_">warnInvalidContextAccess</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useCallback</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">callback, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useCallback&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateCallback</span>(callback, deps);
      },
      <span class="hljs-attr">useContext</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">context, observedBits</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useContext&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">readContext</span>(context, observedBits);
      },
      <span class="hljs-attr">useEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useEffect&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateEffect</span>(create, deps);
      },
      <span class="hljs-attr">useImperativeHandle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ref, create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useImperativeHandle&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateImperativeHandle</span>(ref, create, deps);
      },
      <span class="hljs-attr">useLayoutEffect</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useLayoutEffect&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateLayoutEffect</span>(create, deps);
      },
      <span class="hljs-attr">useMemo</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">create, deps</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMemo&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMemo</span>(create, deps);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useReducer</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">reducer, initialArg, init</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useReducer&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderReducer</span>(reducer, initialArg, init);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useRef</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useRef&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateRef</span>();
      },
      <span class="hljs-attr">useState</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">initialState</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useState&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current;
        <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = <span class="hljs-title class_">InvalidNestedHooksDispatcherOnUpdateIn</span>DEV;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderState</span>(initialState);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">1.</span>current = prevDispatcher;
        }
      },
      <span class="hljs-attr">useDebugValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value, formatterFn</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDebugValue&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateDebugValue</span>();
      },
      <span class="hljs-attr">useDeferredValue</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useDeferredValue&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderDeferredValue</span>(value);
      },
      <span class="hljs-attr">useTransition</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useTransition&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderTransition</span>();
      },
      <span class="hljs-attr">useMutableSource</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">source, getSnapshot, subscribe</span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useMutableSource&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMutableSource</span>(source, getSnapshot, subscribe);
      },
      <span class="hljs-attr">useOpaqueIdentifier</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        currentHookNameInDev = <span class="hljs-string">&#x27;useOpaqueIdentifier&#x27;</span>;
        <span class="hljs-title function_">warnInvalidHookAccess</span>();
        <span class="hljs-title function_">updateHookTypesDev</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">rerenderOpaqueIdentifier</span>();
      },
      <span class="hljs-attr">unstable_isNewReconciler</span>: enableNewReconciler
    };
  }

  <span class="hljs-keyword">var</span> now$<span class="hljs-number">1</span> = unstable_now;
  <span class="hljs-keyword">var</span> commitTime = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> profilerStartTime = -<span class="hljs-number">1</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCommitTime</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> commitTime;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">recordCommitTime</span>(<span class="hljs-params"></span>) {

    commitTime = <span class="hljs-title function_">now$1</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">startProfilerTimer</span>(<span class="hljs-params">fiber</span>) {

    profilerStartTime = <span class="hljs-title function_">now$1</span>();

    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">actualStartTime</span> &lt; <span class="hljs-number">0</span>) {
      fiber.<span class="hljs-property">actualStartTime</span> = <span class="hljs-title function_">now$1</span>();
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopProfilerTimerIfRunning</span>(<span class="hljs-params">fiber</span>) {

    profilerStartTime = -<span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(<span class="hljs-params">fiber, overrideBaseTime</span>) {

    <span class="hljs-keyword">if</span> (profilerStartTime &gt;= <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> elapsedTime = <span class="hljs-title function_">now$1</span>() - profilerStartTime;
      fiber.<span class="hljs-property">actualDuration</span> += elapsedTime;

      <span class="hljs-keyword">if</span> (overrideBaseTime) {
        fiber.<span class="hljs-property">selfBaseDuration</span> = elapsedTime;
      }

      profilerStartTime = -<span class="hljs-number">1</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">transferActualDuration</span>(<span class="hljs-params">fiber</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-715">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-715">&#x00a7;</a>
              </div>
              <p>Transfer time spent rendering these children so we don’t lose it
after we rerender. This is used as a helper in special cases
where we should count the work of multiple passes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> child = fiber.<span class="hljs-property">child</span>;

    <span class="hljs-keyword">while</span> (child) {
      fiber.<span class="hljs-property">actualDuration</span> += child.<span class="hljs-property">actualDuration</span>;
      child = child.<span class="hljs-property">sibling</span>;
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">1</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentOwner</span>;
  <span class="hljs-keyword">var</span> didReceiveUpdate = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> didWarnAboutBadClass;
  <span class="hljs-keyword">var</span> didWarnAboutModulePatternComponent;
  <span class="hljs-keyword">var</span> didWarnAboutContextTypeOnFunctionComponent;
  <span class="hljs-keyword">var</span> didWarnAboutGetDerivedStateOnFunctionComponent;
  <span class="hljs-keyword">var</span> didWarnAboutFunctionRefs;
  <span class="hljs-keyword">var</span> didWarnAboutReassigningProps;
  <span class="hljs-keyword">var</span> didWarnAboutRevealOrder;
  <span class="hljs-keyword">var</span> didWarnAboutTailOptions;

  {
    didWarnAboutBadClass = {};
    didWarnAboutModulePatternComponent = {};
    didWarnAboutContextTypeOnFunctionComponent = {};
    didWarnAboutGetDerivedStateOnFunctionComponent = {};
    didWarnAboutFunctionRefs = {};
    didWarnAboutReassigningProps = <span class="hljs-literal">false</span>;
    didWarnAboutRevealOrder = {};
    didWarnAboutTailOptions = {};
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildren</span>(<span class="hljs-params">current, workInProgress, nextChildren, renderLanes</span>) {
    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-716">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-716">&#x00a7;</a>
              </div>
              <p>If this is a fresh new component that hasn’t been rendered yet, we
won’t update its child set by applying minimal side-effects. Instead,
we will add them all to the child before it gets rendered. That means
we can optimize this reconciliation pass by not tracking side-effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">mountChildFibers</span>(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderLanes);
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-717">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-717">&#x00a7;</a>
              </div>
              <p>If the current child is the same as the work in progress, it means that
we haven’t yet started any work on these children. Therefore, we use
the clone algorithm to create a copy of all the current children.
If we had any progressed work already, that is invalid at this point so
let’s throw it out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress, current.<span class="hljs-property">child</span>, nextChildren, renderLanes);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">forceUnmountCurrentAndReconcile</span>(<span class="hljs-params">current, workInProgress, nextChildren, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-718">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-718">&#x00a7;</a>
              </div>
              <p>This function is fork of reconcileChildren. It’s used in cases where we
want to reconcile without matching against the existing set. This has the
effect of all current children being unmounted; even if the type and key
are the same, the old child is unmounted and a new child is created.</p>
<p>To do this, we’re going to go through the reconcile algorithm twice. In
the first pass, we schedule a deletion for all the current children by
passing null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress, current.<span class="hljs-property">child</span>, <span class="hljs-literal">null</span>, renderLanes); <span class="hljs-comment">// In the second pass, we mount the new children. The trick here is that we</span></pre></div></div>
            
        </li>
        
        
        <li id="section-719">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-719">&#x00a7;</a>
              </div>
              <p>pass null in place of where we usually pass the current child set. This has
the effect of remounting all children regardless of whether their
identities match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderLanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateForwardRef</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-720">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-720">&#x00a7;</a>
              </div>
              <p>TODO: current can be non-null here even if the component
hasn’t yet mounted. This happens after the first render suspends.
We’ll need to figure out if this is fine or can cause issues.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    {
      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">elementType</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-721">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-721">&#x00a7;</a>
              </div>
              <p>Lazy component props can’t be validated in createElement
because they’re only guaranteed to be resolved here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> innerPropTypes = <span class="hljs-title class_">Component</span>.<span class="hljs-property">propTypes</span>;

        <span class="hljs-keyword">if</span> (innerPropTypes) {
          <span class="hljs-title function_">checkPropTypes</span>(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>));
        }
      }
    }

    <span class="hljs-keyword">var</span> render = <span class="hljs-title class_">Component</span>.<span class="hljs-property">render</span>;
    <span class="hljs-keyword">var</span> ref = workInProgress.<span class="hljs-property">ref</span>; <span class="hljs-comment">// The rest is a fork of updateFunctionComponent</span>

    <span class="hljs-keyword">var</span> nextChildren;
    <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);

    {
      <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">1.</span>current = workInProgress;
      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">true</span>);
      nextChildren = <span class="hljs-title function_">renderWithHooks</span>(current, workInProgress, render, nextProps, ref, renderLanes);

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-title function_">disableLogs</span>();

        <span class="hljs-keyword">try</span> {
          nextChildren = <span class="hljs-title function_">renderWithHooks</span>(current, workInProgress, render, nextProps, ref, renderLanes);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title function_">reenableLogs</span>();
        }
      }

      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">false</span>);
    }

    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) {
      <span class="hljs-title function_">bailoutHooks</span>(current, workInProgress, renderLanes);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
    } <span class="hljs-comment">// React DevTools reads this flag.</span>


    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateMemoComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, updateLanes, renderLanes</span>) {
    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> type = <span class="hljs-title class_">Component</span>.<span class="hljs-property">type</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSimpleFunctionComponent</span>(type) &amp;&amp; <span class="hljs-title class_">Component</span>.<span class="hljs-property">compare</span> === <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-comment">// SimpleMemoComponent codepath doesn&#x27;t resolve outer props either.</span>
        <span class="hljs-title class_">Component</span>.<span class="hljs-property">defaultProps</span> === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> resolvedType = type;

        {
          resolvedType = <span class="hljs-title function_">resolveFunctionForHotReloading</span>(type);
        } <span class="hljs-comment">// If this is a plain function component without default props,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-722">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-722">&#x00a7;</a>
              </div>
              <p>and with only the default shallow comparison, we upgrade it
to a SimpleMemoComponent to allow fast path updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        workInProgress.<span class="hljs-property">tag</span> = <span class="hljs-title class_">SimpleMemoComponent</span>;
        workInProgress.<span class="hljs-property">type</span> = resolvedType;

        {
          <span class="hljs-title function_">validateFunctionComponentInDev</span>(workInProgress, type);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSimpleMemoComponent</span>(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes);
      }

      {
        <span class="hljs-keyword">var</span> innerPropTypes = type.<span class="hljs-property">propTypes</span>;

        <span class="hljs-keyword">if</span> (innerPropTypes) {</pre></div></div>
            
        </li>
        
        
        <li id="section-723">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-723">&#x00a7;</a>
              </div>
              <p>Inner memo component props aren’t currently validated in createElement.
We could move it there, but we’d still need this for lazy code path.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">checkPropTypes</span>(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(type));
        }
      }

      <span class="hljs-keyword">var</span> child = <span class="hljs-title function_">createFiberFromTypeAndProps</span>(<span class="hljs-title class_">Component</span>.<span class="hljs-property">type</span>, <span class="hljs-literal">null</span>, nextProps, workInProgress, workInProgress.<span class="hljs-property">mode</span>, renderLanes);
      child.<span class="hljs-property">ref</span> = workInProgress.<span class="hljs-property">ref</span>;
      child.<span class="hljs-property">return</span> = workInProgress;
      workInProgress.<span class="hljs-property">child</span> = child;
      <span class="hljs-keyword">return</span> child;
    }

    {
      <span class="hljs-keyword">var</span> _type = <span class="hljs-title class_">Component</span>.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">var</span> _innerPropTypes = _type.<span class="hljs-property">propTypes</span>;

      <span class="hljs-keyword">if</span> (_innerPropTypes) {</pre></div></div>
            
        </li>
        
        
        <li id="section-724">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-724">&#x00a7;</a>
              </div>
              <p>Inner memo component props aren’t currently validated in createElement.
We could move it there, but we’d still need this for lazy code path.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">checkPropTypes</span>(_innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
          <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(_type));
      }
    }

    <span class="hljs-keyword">var</span> currentChild = current.<span class="hljs-property">child</span>; <span class="hljs-comment">// This is always exactly one child</span>

    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(updateLanes, renderLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-725">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-725">&#x00a7;</a>
              </div>
              <p>This will be the props with resolved defaultProps,
unlike current.memoizedProps which will be the unresolved ones.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> prevProps = currentChild.<span class="hljs-property">memoizedProps</span>; <span class="hljs-comment">// Default to shallow comparison</span>

      <span class="hljs-keyword">var</span> compare = <span class="hljs-title class_">Component</span>.<span class="hljs-property">compare</span>;
      compare = compare !== <span class="hljs-literal">null</span> ? compare : shallowEqual;

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">compare</span>(prevProps, nextProps) &amp;&amp; current.<span class="hljs-property">ref</span> === workInProgress.<span class="hljs-property">ref</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
      }
    } <span class="hljs-comment">// React DevTools reads this flag.</span>


    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;
    <span class="hljs-keyword">var</span> newChild = <span class="hljs-title function_">createWorkInProgress</span>(currentChild, nextProps);
    newChild.<span class="hljs-property">ref</span> = workInProgress.<span class="hljs-property">ref</span>;
    newChild.<span class="hljs-property">return</span> = workInProgress;
    workInProgress.<span class="hljs-property">child</span> = newChild;
    <span class="hljs-keyword">return</span> newChild;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSimpleMemoComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, updateLanes, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-726">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-726">&#x00a7;</a>
              </div>
              <p>TODO: current can be non-null here even if the component
hasn’t yet mounted. This happens when the inner render suspends.
We’ll need to figure out if this is fine or can cause issues.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    {
      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">elementType</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-727">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-727">&#x00a7;</a>
              </div>
              <p>Lazy component props can’t be validated in createElement
because they’re only guaranteed to be resolved here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> outerMemoType = workInProgress.<span class="hljs-property">elementType</span>;

        <span class="hljs-keyword">if</span> (outerMemoType.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_LAZY_TYPE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-728">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-728">&#x00a7;</a>
              </div>
              <p>We warn when you define propTypes on lazy()
so let’s just skip over it to find memo() outer wrapper.
Inner props for memo are validated later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> lazyComponent = outerMemoType;
          <span class="hljs-keyword">var</span> payload = lazyComponent.<span class="hljs-property">_payload</span>;
          <span class="hljs-keyword">var</span> init = lazyComponent.<span class="hljs-property">_init</span>;

          <span class="hljs-keyword">try</span> {
            outerMemoType = <span class="hljs-title function_">init</span>(payload);
          } <span class="hljs-keyword">catch</span> (x) {
            outerMemoType = <span class="hljs-literal">null</span>;
          } <span class="hljs-comment">// Inner propTypes will be validated in the function component path.</span>


          <span class="hljs-keyword">var</span> outerPropTypes = outerMemoType &amp;&amp; outerMemoType.<span class="hljs-property">propTypes</span>;

          <span class="hljs-keyword">if</span> (outerPropTypes) {
            <span class="hljs-title function_">checkPropTypes</span>(outerPropTypes, nextProps, <span class="hljs-comment">// Resolved (SimpleMemoComponent has no defaultProps)</span>
              <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(outerMemoType));
          }
        }
      }
    }

    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> prevProps = current.<span class="hljs-property">memoizedProps</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shallowEqual</span>(prevProps, nextProps) &amp;&amp; current.<span class="hljs-property">ref</span> === workInProgress.<span class="hljs-property">ref</span> &amp;&amp; ( <span class="hljs-comment">// Prevent bailout if the implementation changed due to hot reload.</span>
        workInProgress.<span class="hljs-property">type</span> === current.<span class="hljs-property">type</span>)) {
        didReceiveUpdate = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(renderLanes, updateLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-729">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-729">&#x00a7;</a>
              </div>
              <p>The pending lanes were cleared at the beginning of beginWork. We’re
about to bail out, but there might be other lanes that weren’t
included in the current render. Usually, the priority level of the
remaining updates is accumlated during the evaluation of the
component (i.e. when processing the update queue). But since since
we’re bailing out early <em>without</em> evaluating the component, we need
to account for it here, too. Reset to the value of the current fiber.
NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
because a MemoComponent fiber does not have hooks or an update queue;
rather, it wraps around an inner component, which may or may not
contains hooks.
TODO: Move the reset at in beginWork out of the common path so that
this is no longer necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          workInProgress.<span class="hljs-property">lanes</span> = current.<span class="hljs-property">lanes</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">ForceUpdateForLegacySuspense</span>) !== <span class="hljs-title class_">NoFlags</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-730">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-730">&#x00a7;</a>
              </div>
              <p>This is a special case that only exists for legacy mode.
See <a href="https://github.com/facebook/react/pull/19216">https://github.com/facebook/react/pull/19216</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          didReceiveUpdate = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderLanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateOffscreenComponent</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> nextChildren = nextProps.<span class="hljs-property">children</span>;
    <span class="hljs-keyword">var</span> prevState = current !== <span class="hljs-literal">null</span> ? current.<span class="hljs-property">memoizedState</span> : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-property">mode</span> === <span class="hljs-string">&#x27;hidden&#x27;</span> || nextProps.<span class="hljs-property">mode</span> === <span class="hljs-string">&#x27;unstable-defer-without-hiding&#x27;</span>) {
      <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ConcurrentMode</span>) === <span class="hljs-title class_">NoMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-731">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-731">&#x00a7;</a>
              </div>
              <p>In legacy sync mode, don’t defer the subtree. Render it now.
TODO: Figure out what we should do in Blocking mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> nextState = {
          <span class="hljs-attr">baseLanes</span>: <span class="hljs-title class_">NoLanes</span>
        };
        workInProgress.<span class="hljs-property">memoizedState</span> = nextState;
        <span class="hljs-title function_">pushRenderLanes</span>(workInProgress, renderLanes);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(renderLanes, <span class="hljs-title class_">OffscreenLane</span>)) {
        <span class="hljs-keyword">var</span> nextBaseLanes;

        <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> prevBaseLanes = prevState.<span class="hljs-property">baseLanes</span>;
          nextBaseLanes = <span class="hljs-title function_">mergeLanes</span>(prevBaseLanes, renderLanes);
        } <span class="hljs-keyword">else</span> {
          nextBaseLanes = renderLanes;
        } <span class="hljs-comment">// Schedule this fiber to re-render at offscreen priority. Then bailout.</span>


        {
          <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">OffscreenLane</span>);
        }

        workInProgress.<span class="hljs-property">lanes</span> = workInProgress.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">laneToLanes</span>(<span class="hljs-title class_">OffscreenLane</span>);
        <span class="hljs-keyword">var</span> _nextState = {
          <span class="hljs-attr">baseLanes</span>: nextBaseLanes
        };
        workInProgress.<span class="hljs-property">memoizedState</span> = _nextState; <span class="hljs-comment">// We&#x27;re about to bail out, but we need to push this to the stack anyway</span></pre></div></div>
            
        </li>
        
        
        <li id="section-732">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-732">&#x00a7;</a>
              </div>
              <p>to avoid a push/pop misalignment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">pushRenderLanes</span>(workInProgress, nextBaseLanes);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-733">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-733">&#x00a7;</a>
              </div>
              <p>Rendering at offscreen, so we can clear the base lanes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> _nextState2 = {
          <span class="hljs-attr">baseLanes</span>: <span class="hljs-title class_">NoLanes</span>
        };
        workInProgress.<span class="hljs-property">memoizedState</span> = _nextState2; <span class="hljs-comment">// Push the lanes that were skipped when we bailed out.</span>

        <span class="hljs-keyword">var</span> subtreeRenderLanes = prevState !== <span class="hljs-literal">null</span> ? prevState.<span class="hljs-property">baseLanes</span> : renderLanes;
        <span class="hljs-title function_">pushRenderLanes</span>(workInProgress, subtreeRenderLanes);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> _subtreeRenderLanes;

      <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
        _subtreeRenderLanes = <span class="hljs-title function_">mergeLanes</span>(prevState.<span class="hljs-property">baseLanes</span>, renderLanes); <span class="hljs-comment">// Since we&#x27;re not hidden anymore, reset the state</span>

        workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-734">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-734">&#x00a7;</a>
              </div>
              <p>We weren’t previously hidden, and we still aren’t, so there’s nothing
special to do. Need to push to the stack regardless, though, to avoid
a push/pop misalignment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        _subtreeRenderLanes = renderLanes;
      }

      <span class="hljs-title function_">pushRenderLanes</span>(workInProgress, _subtreeRenderLanes);
    }

    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  } <span class="hljs-comment">// Note: These happen to have identical begin phases, for now. We shouldn&#x27;t hold</span></pre></div></div>
            
        </li>
        
        
        <li id="section-735">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-735">&#x00a7;</a>
              </div>
              <p>ourselves to this constraint, though. If the behavior diverges, we should
fork the function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">var</span> updateLegacyHiddenComponent = updateOffscreenComponent;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFragment</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> nextChildren = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateMode</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> nextChildren = workInProgress.<span class="hljs-property">pendingProps</span>.<span class="hljs-property">children</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProfiler</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    {
      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>; <span class="hljs-comment">// Reset effect durations for the next eventual effect phase.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-736">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-736">&#x00a7;</a>
              </div>
              <p>These are reset during render to allow the DevTools commit hook a chance to read them,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> stateNode = workInProgress.<span class="hljs-property">stateNode</span>;
      stateNode.<span class="hljs-property">effectDuration</span> = <span class="hljs-number">0</span>;
      stateNode.<span class="hljs-property">passiveEffectDuration</span> = <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> nextChildren = nextProps.<span class="hljs-property">children</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRef</span>(<span class="hljs-params">current, workInProgress</span>) {
    <span class="hljs-keyword">var</span> ref = workInProgress.<span class="hljs-property">ref</span>;

    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> &amp;&amp; ref !== <span class="hljs-literal">null</span> || current !== <span class="hljs-literal">null</span> &amp;&amp; current.<span class="hljs-property">ref</span> !== ref) {</pre></div></div>
            
        </li>
        
        
        <li id="section-737">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-737">&#x00a7;</a>
              </div>
              <p>Schedule a Ref effect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Ref</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFunctionComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, renderLanes</span>) {
    {
      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">elementType</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-738">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-738">&#x00a7;</a>
              </div>
              <p>Lazy component props can’t be validated in createElement
because they’re only guaranteed to be resolved here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> innerPropTypes = <span class="hljs-title class_">Component</span>.<span class="hljs-property">propTypes</span>;

        <span class="hljs-keyword">if</span> (innerPropTypes) {
          <span class="hljs-title function_">checkPropTypes</span>(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>));
        }
      }
    }

    <span class="hljs-keyword">var</span> context;

    {
      <span class="hljs-keyword">var</span> unmaskedContext = <span class="hljs-title function_">getUnmaskedContext</span>(workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-literal">true</span>);
      context = <span class="hljs-title function_">getMaskedContext</span>(workInProgress, unmaskedContext);
    }

    <span class="hljs-keyword">var</span> nextChildren;
    <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);

    {
      <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">1.</span>current = workInProgress;
      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">true</span>);
      nextChildren = <span class="hljs-title function_">renderWithHooks</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, nextProps, context, renderLanes);

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-title function_">disableLogs</span>();

        <span class="hljs-keyword">try</span> {
          nextChildren = <span class="hljs-title function_">renderWithHooks</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, nextProps, context, renderLanes);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title function_">reenableLogs</span>();
        }
      }

      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">false</span>);
    }

    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) {
      <span class="hljs-title function_">bailoutHooks</span>(current, workInProgress, renderLanes);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
    } <span class="hljs-comment">// React DevTools reads this flag.</span>


    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateBlock</span>(<span class="hljs-params">current, workInProgress, block, nextProps, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-739">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-739">&#x00a7;</a>
              </div>
              <p>TODO: current can be non-null here even if the component
hasn’t yet mounted. This happens after the first render suspends.
We’ll need to figure out if this is fine or can cause issues.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> render = block.<span class="hljs-property">_render</span>;
    <span class="hljs-keyword">var</span> data = block.<span class="hljs-property">_data</span>; <span class="hljs-comment">// The rest is a fork of updateFunctionComponent</span>

    <span class="hljs-keyword">var</span> nextChildren;
    <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);

    {
      <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">1.</span>current = workInProgress;
      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">true</span>);
      nextChildren = <span class="hljs-title function_">renderWithHooks</span>(current, workInProgress, render, nextProps, data, renderLanes);

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-title function_">disableLogs</span>();

        <span class="hljs-keyword">try</span> {
          nextChildren = <span class="hljs-title function_">renderWithHooks</span>(current, workInProgress, render, nextProps, data, renderLanes);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-title function_">reenableLogs</span>();
        }
      }

      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">false</span>);
    }

    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; !didReceiveUpdate) {
      <span class="hljs-title function_">bailoutHooks</span>(current, workInProgress, renderLanes);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
    } <span class="hljs-comment">// React DevTools reads this flag.</span>


    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassComponent</span>(<span class="hljs-params">current, workInProgress, Component, nextProps, renderLanes</span>) {
    {
      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">elementType</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-740">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-740">&#x00a7;</a>
              </div>
              <p>Lazy component props can’t be validated in createElement
because they’re only guaranteed to be resolved here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> innerPropTypes = <span class="hljs-title class_">Component</span>.<span class="hljs-property">propTypes</span>;

        <span class="hljs-keyword">if</span> (innerPropTypes) {
          <span class="hljs-title function_">checkPropTypes</span>(innerPropTypes, nextProps, <span class="hljs-comment">// Resolved props</span>
            <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>));
        }
      }
    } <span class="hljs-comment">// Push context providers early to prevent context stack mismatches.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-741">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-741">&#x00a7;</a>
              </div>
              <p>During mounting we don’t know the child context yet as the instance doesn’t exist.
We will invalidate the child context in finishClassComponent() right after rendering.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> hasContext;

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
      hasContext = <span class="hljs-literal">true</span>;
      <span class="hljs-title function_">pushContextProvider</span>(workInProgress);
    } <span class="hljs-keyword">else</span> {
      hasContext = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);
    <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;
    <span class="hljs-keyword">var</span> shouldUpdate;

    <span class="hljs-keyword">if</span> (instance === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-742">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-742">&#x00a7;</a>
              </div>
              <p>A class component without an instance only mounts if it suspended
inside a non-concurrent tree, in an inconsistent state. We want to
treat it like a new mount, even though an empty version of it already
committed. Disconnect the alternate pointers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        current.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;
        workInProgress.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>;
      } <span class="hljs-comment">// In the initial pass we might need to construct the instance.</span>


      <span class="hljs-title function_">constructClassInstance</span>(workInProgress, <span class="hljs-title class_">Component</span>, nextProps);
      <span class="hljs-title function_">mountClassInstance</span>(workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderLanes);
      shouldUpdate = <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-743">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-743">&#x00a7;</a>
              </div>
              <p>In a resume, we’ll already have an instance we can reuse.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      shouldUpdate = <span class="hljs-title function_">resumeMountClassInstance</span>(workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderLanes);
    } <span class="hljs-keyword">else</span> {
      shouldUpdate = <span class="hljs-title function_">updateClassInstance</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderLanes);
    }

    <span class="hljs-keyword">var</span> nextUnitOfWork = <span class="hljs-title function_">finishClassComponent</span>(current, workInProgress, <span class="hljs-title class_">Component</span>, shouldUpdate, hasContext, renderLanes);

    {
      <span class="hljs-keyword">var</span> inst = workInProgress.<span class="hljs-property">stateNode</span>;

      <span class="hljs-keyword">if</span> (shouldUpdate &amp;&amp; inst.<span class="hljs-property">props</span> !== nextProps) {
        <span class="hljs-keyword">if</span> (!didWarnAboutReassigningProps) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;It looks like %s is reassigning its own `this.props` while rendering. &#x27;</span> + <span class="hljs-string">&#x27;This is not supported and can lead to confusing bugs.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(workInProgress.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;a component&#x27;</span>);
        }

        didWarnAboutReassigningProps = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">return</span> nextUnitOfWork;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">finishClassComponent</span>(<span class="hljs-params">current, workInProgress, Component, shouldUpdate, hasContext, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-744">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-744">&#x00a7;</a>
              </div>
              <p>Refs should update even if shouldComponentUpdate returns false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">markRef</span>(current, workInProgress);
    <span class="hljs-keyword">var</span> didCaptureError = (workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoFlags</span>;

    <span class="hljs-keyword">if</span> (!shouldUpdate &amp;&amp; !didCaptureError) {</pre></div></div>
            
        </li>
        
        
        <li id="section-745">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-745">&#x00a7;</a>
              </div>
              <p>Context providers should defer to sCU for rendering</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (hasContext) {
        <span class="hljs-title function_">invalidateContextProvider</span>(workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-literal">false</span>);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
    }

    <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// Rerender</span>

    <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">1.</span>current = workInProgress;
    <span class="hljs-keyword">var</span> nextChildren;

    <span class="hljs-keyword">if</span> (didCaptureError &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Component</span>.<span class="hljs-property">getDerivedStateFromError</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-746">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-746">&#x00a7;</a>
              </div>
              <p>If we captured an error, but getDerivedStateFromError is not defined,
unmount all the children. componentDidCatch will schedule an update to
re-render a fallback. This is temporary until we migrate everyone to
the new API.
TODO: Warn in a future release.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      nextChildren = <span class="hljs-literal">null</span>;

      {
        <span class="hljs-title function_">stopProfilerTimerIfRunning</span>();
      }
    } <span class="hljs-keyword">else</span> {
      {
        <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">true</span>);
        nextChildren = instance.<span class="hljs-title function_">render</span>();

        <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
          <span class="hljs-title function_">disableLogs</span>();

          <span class="hljs-keyword">try</span> {
            instance.<span class="hljs-title function_">render</span>();
          } <span class="hljs-keyword">finally</span> {
            <span class="hljs-title function_">reenableLogs</span>();
          }
        }

        <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">false</span>);
      }
    } <span class="hljs-comment">// React DevTools reads this flag.</span>


    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;

    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; didCaptureError) {</pre></div></div>
            
        </li>
        
        
        <li id="section-747">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-747">&#x00a7;</a>
              </div>
              <p>If we’re recovering from an error, reconcile without reusing any of
the existing children. Conceptually, the normal children and the children
that are shown on error are two different sets, so we shouldn’t reuse
normal children even if their identities match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">forceUnmountCurrentAndReconcile</span>(current, workInProgress, nextChildren, renderLanes);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    } <span class="hljs-comment">// Memoize state using the values we just used to render.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-748">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-748">&#x00a7;</a>
              </div>
              <p>TODO: Restructure so we never read values from the instance.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    workInProgress.<span class="hljs-property">memoizedState</span> = instance.<span class="hljs-property">state</span>; <span class="hljs-comment">// The context might have changed so we need to recalculate it.</span>

    <span class="hljs-keyword">if</span> (hasContext) {
      <span class="hljs-title function_">invalidateContextProvider</span>(workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-literal">true</span>);
    }

    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushHostRootContext</span>(<span class="hljs-params">workInProgress</span>) {
    <span class="hljs-keyword">var</span> root = workInProgress.<span class="hljs-property">stateNode</span>;

    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">pendingContext</span>) {
      <span class="hljs-title function_">pushTopLevelContextObject</span>(workInProgress, root.<span class="hljs-property">pendingContext</span>, root.<span class="hljs-property">pendingContext</span> !== root.<span class="hljs-property">context</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.<span class="hljs-property">context</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-749">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-749">&#x00a7;</a>
              </div>
              <p>Should always be set</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">pushTopLevelContextObject</span>(workInProgress, root.<span class="hljs-property">context</span>, <span class="hljs-literal">false</span>);
    }

    <span class="hljs-title function_">pushHostContainer</span>(workInProgress, root.<span class="hljs-property">containerInfo</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateHostRoot</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-title function_">pushHostRootContext</span>(workInProgress);
    <span class="hljs-keyword">var</span> updateQueue = workInProgress.<span class="hljs-property">updateQueue</span>;

    <span class="hljs-keyword">if</span> (!(current !== <span class="hljs-literal">null</span> &amp;&amp; updateQueue !== <span class="hljs-literal">null</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }

    <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> prevState = workInProgress.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> prevChildren = prevState !== <span class="hljs-literal">null</span> ? prevState.<span class="hljs-property">element</span> : <span class="hljs-literal">null</span>;
    <span class="hljs-title function_">cloneUpdateQueue</span>(current, workInProgress);
    <span class="hljs-title function_">processUpdateQueue</span>(workInProgress, nextProps, <span class="hljs-literal">null</span>, renderLanes);
    <span class="hljs-keyword">var</span> nextState = workInProgress.<span class="hljs-property">memoizedState</span>; <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span></pre></div></div>
            
        </li>
        
        
        <li id="section-750">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-750">&#x00a7;</a>
              </div>
              <p>being called “element”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> nextChildren = nextState.<span class="hljs-property">element</span>;

    <span class="hljs-keyword">if</span> (nextChildren === prevChildren) {
      <span class="hljs-title function_">resetHydrationState</span>();
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
    }

    <span class="hljs-keyword">var</span> root = workInProgress.<span class="hljs-property">stateNode</span>;

    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">hydrate</span> &amp;&amp; <span class="hljs-title function_">enterHydrationState</span>(workInProgress)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-751">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-751">&#x00a7;</a>
              </div>
              <p>If we don’t have any current children this might be the first pass.
We always try to hydrate. If this isn’t a hydration pass there won’t
be any children to hydrate which is effectively the same thing as
not hydrating.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        <span class="hljs-keyword">var</span> mutableSourceEagerHydrationData = root.<span class="hljs-property">mutableSourceEagerHydrationData</span>;

        <span class="hljs-keyword">if</span> (mutableSourceEagerHydrationData != <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mutableSourceEagerHydrationData.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {
            <span class="hljs-keyword">var</span> mutableSource = mutableSourceEagerHydrationData[i];
            <span class="hljs-keyword">var</span> version = mutableSourceEagerHydrationData[i + <span class="hljs-number">1</span>];
            <span class="hljs-title function_">setWorkInProgressVersion</span>(mutableSource, version);
          }
        }
      }

      <span class="hljs-keyword">var</span> child = <span class="hljs-title function_">mountChildFibers</span>(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderLanes);
      workInProgress.<span class="hljs-property">child</span> = child;
      <span class="hljs-keyword">var</span> node = child;

      <span class="hljs-keyword">while</span> (node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-752">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-752">&#x00a7;</a>
              </div>
              <p>Mark each child as hydrating. This is a fast path to know whether this
tree is part of a hydrating tree. This is used to determine if a child
node has fully mounted yet, and for scheduling event replaying.
Conceptually this is similar to Placement in that a new subtree is
inserted into the React tree here. It just happens to not need DOM
mutations because it already exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        node.<span class="hljs-property">flags</span> = node.<span class="hljs-property">flags</span> &amp; ~<span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">Hydrating</span>;
        node = node.<span class="hljs-property">sibling</span>;
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-753">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-753">&#x00a7;</a>
              </div>
              <p>Otherwise reset hydration state in case we aborted and resumed another
root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
      <span class="hljs-title function_">resetHydrationState</span>();
    }

    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateHostComponent</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-title function_">pushHostContext</span>(workInProgress);

    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">tryToClaimNextHydratableInstance</span>(workInProgress);
    }

    <span class="hljs-keyword">var</span> type = workInProgress.<span class="hljs-property">type</span>;
    <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> prevProps = current !== <span class="hljs-literal">null</span> ? current.<span class="hljs-property">memoizedProps</span> : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> nextChildren = nextProps.<span class="hljs-property">children</span>;
    <span class="hljs-keyword">var</span> isDirectTextChild = <span class="hljs-title function_">shouldSetTextContent</span>(type, nextProps);

    <span class="hljs-keyword">if</span> (isDirectTextChild) {</pre></div></div>
            
        </li>
        
        
        <li id="section-754">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-754">&#x00a7;</a>
              </div>
              <p>We special case a direct text child of a host node. This is a common
case. We won’t handle it as a reified child. We will instead handle
this in the host environment that also has access to this prop. That
avoids allocating another HostText fiber and traversing it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      nextChildren = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prevProps !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">shouldSetTextContent</span>(type, prevProps)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-755">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-755">&#x00a7;</a>
              </div>
              <p>If we’re switching from a direct text child to a normal child, or to
empty, we need to schedule the text content to be reset.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">ContentReset</span>;
    }

    <span class="hljs-title function_">markRef</span>(current, workInProgress);
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateHostText</span>(<span class="hljs-params">current, workInProgress</span>) {
    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">tryToClaimNextHydratableInstance</span>(workInProgress);
    } <span class="hljs-comment">// Nothing to do here. This is terminal. We&#x27;ll do the completion step</span></pre></div></div>
            
        </li>
        
        
        <li id="section-756">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-756">&#x00a7;</a>
              </div>
              <p>immediately after.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountLazyComponent</span>(<span class="hljs-params">_current, workInProgress, elementType, updateLanes, renderLanes</span>) {
    <span class="hljs-keyword">if</span> (_current !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-757">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-757">&#x00a7;</a>
              </div>
              <p>A lazy component only mounts if it suspended inside a non-
concurrent tree, in an inconsistent state. We want to treat it like
a new mount, even though an empty version of it already committed.
Disconnect the alternate pointers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _current.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>;
    }

    <span class="hljs-keyword">var</span> props = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> lazyComponent = elementType;
    <span class="hljs-keyword">var</span> payload = lazyComponent.<span class="hljs-property">_payload</span>;
    <span class="hljs-keyword">var</span> init = lazyComponent.<span class="hljs-property">_init</span>;
    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title function_">init</span>(payload); <span class="hljs-comment">// Store the unwrapped component in the type.</span>

    workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title class_">Component</span>;
    <span class="hljs-keyword">var</span> resolvedTag = workInProgress.<span class="hljs-property">tag</span> = <span class="hljs-title function_">resolveLazyComponentTag</span>(<span class="hljs-title class_">Component</span>);
    <span class="hljs-keyword">var</span> resolvedProps = <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-title class_">Component</span>, props);
    <span class="hljs-keyword">var</span> child;

    <span class="hljs-keyword">switch</span> (resolvedTag) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
        {
          {
            <span class="hljs-title function_">validateFunctionComponentInDev</span>(workInProgress, <span class="hljs-title class_">Component</span>);
            workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title class_">Component</span> = <span class="hljs-title function_">resolveFunctionForHotReloading</span>(<span class="hljs-title class_">Component</span>);
          }

          child = <span class="hljs-title function_">updateFunctionComponent</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, resolvedProps, renderLanes);
          <span class="hljs-keyword">return</span> child;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          {
            workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title class_">Component</span> = <span class="hljs-title function_">resolveClassForHotReloading</span>(<span class="hljs-title class_">Component</span>);
          }

          child = <span class="hljs-title function_">updateClassComponent</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, resolvedProps, renderLanes);
          <span class="hljs-keyword">return</span> child;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
        {
          {
            workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title class_">Component</span> = <span class="hljs-title function_">resolveForwardRefForHotReloading</span>(<span class="hljs-title class_">Component</span>);
          }

          child = <span class="hljs-title function_">updateForwardRef</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, resolvedProps, renderLanes);
          <span class="hljs-keyword">return</span> child;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:
        {
          {
            <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">elementType</span>) {
              <span class="hljs-keyword">var</span> outerPropTypes = <span class="hljs-title class_">Component</span>.<span class="hljs-property">propTypes</span>;

              <span class="hljs-keyword">if</span> (outerPropTypes) {
                <span class="hljs-title function_">checkPropTypes</span>(outerPropTypes, resolvedProps, <span class="hljs-comment">// Resolved for outer only</span>
                  <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>));
              }
            }
          }

          child = <span class="hljs-title function_">updateMemoComponent</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-title function_">resolveDefaultProps</span>(<span class="hljs-title class_">Component</span>.<span class="hljs-property">type</span>, resolvedProps), <span class="hljs-comment">// The inner type can have defaults too</span>
            updateLanes, renderLanes);
          <span class="hljs-keyword">return</span> child;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        {
          {</pre></div></div>
            
        </li>
        
        
        <li id="section-758">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-758">&#x00a7;</a>
              </div>
              <p>TODO: Resolve for Hot Reloading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            child = <span class="hljs-title function_">updateBlock</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, props, renderLanes);
            <span class="hljs-keyword">return</span> child;
          }
        }
    }

    <span class="hljs-keyword">var</span> hint = <span class="hljs-string">&#x27;&#x27;</span>;

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Component</span> !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Component</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-title class_">Component</span>.<span class="hljs-property">$$typeof</span> === <span class="hljs-variable constant_">REACT_LAZY_TYPE</span>) {
        hint = <span class="hljs-string">&#x27; Did you wrap a component in React.lazy() more than once?&#x27;</span>;
      }
    } <span class="hljs-comment">// This message intentionally doesn&#x27;t mention ForwardRef or MemoComponent</span></pre></div></div>
            
        </li>
        
        
        <li id="section-759">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-759">&#x00a7;</a>
              </div>
              <p>because the fact that it’s a separate type of work is an
implementation detail.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Element type is invalid. Received a promise that resolves to: &quot;</span> + <span class="hljs-title class_">Component</span> + <span class="hljs-string">&quot;. Lazy element type must resolve to a class or function.&quot;</span> + hint);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountIncompleteClassComponent</span>(<span class="hljs-params">_current, workInProgress, Component, nextProps, renderLanes</span>) {
    <span class="hljs-keyword">if</span> (_current !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-760">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-760">&#x00a7;</a>
              </div>
              <p>An incomplete component only mounts if it suspended inside a non-
concurrent tree, in an inconsistent state. We want to treat it like
a new mount, even though an empty version of it already committed.
Disconnect the alternate pointers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _current.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>;
    } <span class="hljs-comment">// Promote the fiber to a class and try rendering again.</span>


    workInProgress.<span class="hljs-property">tag</span> = <span class="hljs-title class_">ClassComponent</span>; <span class="hljs-comment">// The rest of this function is a fork of `updateClassComponent`</span></pre></div></div>
            
        </li>
        
        
        <li id="section-761">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-761">&#x00a7;</a>
              </div>
              <p>Push context providers early to prevent context stack mismatches.
During mounting we don’t know the child context yet as the instance doesn’t exist.
We will invalidate the child context in finishClassComponent() right after rendering.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> hasContext;

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
      hasContext = <span class="hljs-literal">true</span>;
      <span class="hljs-title function_">pushContextProvider</span>(workInProgress);
    } <span class="hljs-keyword">else</span> {
      hasContext = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);
    <span class="hljs-title function_">constructClassInstance</span>(workInProgress, <span class="hljs-title class_">Component</span>, nextProps);
    <span class="hljs-title function_">mountClassInstance</span>(workInProgress, <span class="hljs-title class_">Component</span>, nextProps, renderLanes);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">finishClassComponent</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-literal">true</span>, hasContext, renderLanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountIndeterminateComponent</span>(<span class="hljs-params">_current, workInProgress, Component, renderLanes</span>) {
    <span class="hljs-keyword">if</span> (_current !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-762">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-762">&#x00a7;</a>
              </div>
              <p>An indeterminate component only mounts if it suspended inside a non-
concurrent tree, in an inconsistent state. We want to treat it like
a new mount, even though an empty version of it already committed.
Disconnect the alternate pointers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      _current.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Since this is conceptually a new fiber, schedule a Placement effect</span>

      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>;
    }

    <span class="hljs-keyword">var</span> props = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> context;

    {
      <span class="hljs-keyword">var</span> unmaskedContext = <span class="hljs-title function_">getUnmaskedContext</span>(workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-literal">false</span>);
      context = <span class="hljs-title function_">getMaskedContext</span>(workInProgress, unmaskedContext);
    }

    <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);
    <span class="hljs-keyword">var</span> value;

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutBadClass[componentName]) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;The &lt;%s /&gt; component appears to have a render method, but doesn&#x27;t extend React.Component. &quot;</span> + <span class="hljs-string">&#x27;This is likely to cause errors. Change %s to extend React.Component instead.&#x27;</span>, componentName, componentName);

          didWarnAboutBadClass[componentName] = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-title function_">recordLegacyContextWarning</span>(workInProgress, <span class="hljs-literal">null</span>);
      }

      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">true</span>);
      <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">1.</span>current = workInProgress;
      value = <span class="hljs-title function_">renderWithHooks</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, props, context, renderLanes);
      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">false</span>);
    } <span class="hljs-comment">// React DevTools reads this flag.</span>


    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-763">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-763">&#x00a7;</a>
              </div>
              <p>Support for module components is deprecated and is removed behind a flag.
Whether or not it would crash later, we want to show a good message in DEV first.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">render</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; value.<span class="hljs-property">$$typeof</span> === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">var</span> _componentName = <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutModulePatternComponent[_componentName]) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The &lt;%s /&gt; component appears to be a function component that returns a class instance. &#x27;</span> + <span class="hljs-string">&#x27;Change %s to a class that extends React.Component instead. &#x27;</span> + <span class="hljs-string">&quot;If you can&#x27;t use a class try assigning the prototype on the function as a workaround. &quot;</span> + <span class="hljs-string">&quot;`%s.prototype = React.Component.prototype`. Don&#x27;t use an arrow function since it &quot;</span> + <span class="hljs-string">&#x27;cannot be called with `new` by React.&#x27;</span>, _componentName, _componentName, _componentName);

          didWarnAboutModulePatternComponent[_componentName] = <span class="hljs-literal">true</span>;
        }
      }
    }

    <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Run these checks in production only if the flag is off.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-764">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-764">&#x00a7;</a>
              </div>
              <p>Eventually we’ll delete this branch altogether.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">render</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; value.<span class="hljs-property">$$typeof</span> === <span class="hljs-literal">undefined</span>) {
      {
        <span class="hljs-keyword">var</span> _componentName2 = <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutModulePatternComponent[_componentName2]) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The &lt;%s /&gt; component appears to be a function component that returns a class instance. &#x27;</span> + <span class="hljs-string">&#x27;Change %s to a class that extends React.Component instead. &#x27;</span> + <span class="hljs-string">&quot;If you can&#x27;t use a class try assigning the prototype on the function as a workaround. &quot;</span> + <span class="hljs-string">&quot;`%s.prototype = React.Component.prototype`. Don&#x27;t use an arrow function since it &quot;</span> + <span class="hljs-string">&#x27;cannot be called with `new` by React.&#x27;</span>, _componentName2, _componentName2, _componentName2);

          didWarnAboutModulePatternComponent[_componentName2] = <span class="hljs-literal">true</span>;
        }
      } <span class="hljs-comment">// Proceed under the assumption that this is a class instance</span>


      workInProgress.<span class="hljs-property">tag</span> = <span class="hljs-title class_">ClassComponent</span>; <span class="hljs-comment">// Throw out any hooks that were used.</span>

      workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Push context providers early to prevent context stack mismatches.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-765">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-765">&#x00a7;</a>
              </div>
              <p>During mounting we don’t know the child context yet as the instance doesn’t exist.
We will invalidate the child context in finishClassComponent() right after rendering.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> hasContext = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
        hasContext = <span class="hljs-literal">true</span>;
        <span class="hljs-title function_">pushContextProvider</span>(workInProgress);
      } <span class="hljs-keyword">else</span> {
        hasContext = <span class="hljs-literal">false</span>;
      }

      workInProgress.<span class="hljs-property">memoizedState</span> = value.<span class="hljs-property">state</span> !== <span class="hljs-literal">null</span> &amp;&amp; value.<span class="hljs-property">state</span> !== <span class="hljs-literal">undefined</span> ? value.<span class="hljs-property">state</span> : <span class="hljs-literal">null</span>;
      <span class="hljs-title function_">initializeUpdateQueue</span>(workInProgress);
      <span class="hljs-keyword">var</span> getDerivedStateFromProps = <span class="hljs-title class_">Component</span>.<span class="hljs-property">getDerivedStateFromProps</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromProps === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">applyDerivedStateFromProps</span>(workInProgress, <span class="hljs-title class_">Component</span>, getDerivedStateFromProps, props);
      }

      <span class="hljs-title function_">adoptClassInstance</span>(workInProgress, value);
      <span class="hljs-title function_">mountClassInstance</span>(workInProgress, <span class="hljs-title class_">Component</span>, props, renderLanes);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">finishClassComponent</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, <span class="hljs-literal">true</span>, hasContext, renderLanes);
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-766">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-766">&#x00a7;</a>
              </div>
              <p>Proceed under the assumption that this is a function component</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">tag</span> = <span class="hljs-title class_">FunctionComponent</span>;

      {

        <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
          <span class="hljs-title function_">disableLogs</span>();

          <span class="hljs-keyword">try</span> {
            value = <span class="hljs-title function_">renderWithHooks</span>(<span class="hljs-literal">null</span>, workInProgress, <span class="hljs-title class_">Component</span>, props, context, renderLanes);
          } <span class="hljs-keyword">finally</span> {
            <span class="hljs-title function_">reenableLogs</span>();
          }
        }
      }

      <span class="hljs-title function_">reconcileChildren</span>(<span class="hljs-literal">null</span>, workInProgress, value, renderLanes);

      {
        <span class="hljs-title function_">validateFunctionComponentInDev</span>(workInProgress, <span class="hljs-title class_">Component</span>);
      }

      <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateFunctionComponentInDev</span>(<span class="hljs-params">workInProgress, Component</span>) {
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Component</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Component</span>.<span class="hljs-property">childContextTypes</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s(...): childContextTypes cannot be defined on a function component.&#x27;</span>, <span class="hljs-title class_">Component</span>.<span class="hljs-property">displayName</span> || <span class="hljs-title class_">Component</span>.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;Component&#x27;</span>);
        }
      }

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> info = <span class="hljs-string">&#x27;&#x27;</span>;
        <span class="hljs-keyword">var</span> ownerName = <span class="hljs-title function_">getCurrentFiberOwnerNameInDevOrNull</span>();

        <span class="hljs-keyword">if</span> (ownerName) {
          info += <span class="hljs-string">&#x27;\n\nCheck the render method of `&#x27;</span> + ownerName + <span class="hljs-string">&#x27;`.&#x27;</span>;
        }

        <span class="hljs-keyword">var</span> warningKey = ownerName || workInProgress.<span class="hljs-property">_debugID</span> || <span class="hljs-string">&#x27;&#x27;</span>;
        <span class="hljs-keyword">var</span> debugSource = workInProgress.<span class="hljs-property">_debugSource</span>;

        <span class="hljs-keyword">if</span> (debugSource) {
          warningKey = debugSource.<span class="hljs-property">fileName</span> + <span class="hljs-string">&#x27;:&#x27;</span> + debugSource.<span class="hljs-property">lineNumber</span>;
        }

        <span class="hljs-keyword">if</span> (!didWarnAboutFunctionRefs[warningKey]) {
          didWarnAboutFunctionRefs[warningKey] = <span class="hljs-literal">true</span>;

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Function components cannot be given refs. &#x27;</span> + <span class="hljs-string">&#x27;Attempts to access this ref will fail. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean to use React.forwardRef()?%s&#x27;</span>, info);
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Component</span>.<span class="hljs-property">getDerivedStateFromProps</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">var</span> _componentName3 = <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: Function components do not support getDerivedStateFromProps.&#x27;</span>, _componentName3);

          didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Component</span>.<span class="hljs-property">contextType</span> === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-title class_">Component</span>.<span class="hljs-property">contextType</span> !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> _componentName4 = <span class="hljs-title function_">getComponentName</span>(<span class="hljs-title class_">Component</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: Function components do not support contextType.&#x27;</span>, _componentName4);

          didWarnAboutContextTypeOnFunctionComponent[_componentName4] = <span class="hljs-literal">true</span>;
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">SUSPENDED_MARKER</span> = {
    <span class="hljs-attr">dehydrated</span>: <span class="hljs-literal">null</span>,
    <span class="hljs-attr">retryLane</span>: <span class="hljs-title class_">NoLane</span>
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountSuspenseOffscreenState</span>(<span class="hljs-params">renderLanes</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">baseLanes</span>: renderLanes
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSuspenseOffscreenState</span>(<span class="hljs-params">prevOffscreenState, renderLanes</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">baseLanes</span>: <span class="hljs-title function_">mergeLanes</span>(prevOffscreenState.<span class="hljs-property">baseLanes</span>, renderLanes)
    };
  } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Probably should inline this back</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldRemainOnFallback</span>(<span class="hljs-params">suspenseContext, current, workInProgress, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-767">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-767">&#x00a7;</a>
              </div>
              <p>If we’re already showing a fallback, there are cases where we need to
remain on that fallback regardless of whether the content has resolved.
For example, SuspenseList coordinates when nested content appears.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> suspenseState = current.<span class="hljs-property">memoizedState</span>;

      <span class="hljs-keyword">if</span> (suspenseState === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-768">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-768">&#x00a7;</a>
              </div>
              <p>Currently showing content. Don’t hide it, even if ForceSuspenseFallack
is true. More precise name might be “ForceRemainSuspenseFallback”.
Note: This is a factoring smell. Can’t remain on a fallback if there’s
no fallback to remain on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    } <span class="hljs-comment">// Not currently showing content. Consult the Suspense context.</span>


    <span class="hljs-keyword">return</span> <span class="hljs-title function_">hasSuspenseContext</span>(suspenseContext, <span class="hljs-title class_">ForceSuspenseFallback</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRemainingWorkInPrimaryTree</span>(<span class="hljs-params">current, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-769">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-769">&#x00a7;</a>
              </div>
              <p>TODO: Should not remove render lanes that were pinged during this render</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">removeLanes</span>(current.<span class="hljs-property">childLanes</span>, renderLanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSuspenseComponent</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>; <span class="hljs-comment">// This is used by DevTools to force a boundary to suspend.</span>

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldSuspend</span>(workInProgress)) {
        workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
      }
    }

    <span class="hljs-keyword">var</span> suspenseContext = suspenseStackCursor.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">var</span> showFallback = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">var</span> didSuspend = (workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoFlags</span>;

    <span class="hljs-keyword">if</span> (didSuspend || <span class="hljs-title function_">shouldRemainOnFallback</span>(suspenseContext, current)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-770">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-770">&#x00a7;</a>
              </div>
              <p>Something in this boundary’s subtree already suspended. Switch to
rendering the fallback children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      showFallback = <span class="hljs-literal">true</span>;
      workInProgress.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">DidCapture</span>;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-771">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-771">&#x00a7;</a>
              </div>
              <p>Attempting the main content</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">memoizedState</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-772">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-772">&#x00a7;</a>
              </div>
              <p>This is a new mount or this boundary is already showing a fallback state.
Mark this subtree context as having at least one invisible parent that could
handle the fallback state.
Boundaries without fallbacks or should be avoided are not considered since
they cannot handle preferred fallback states.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-property">fallback</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; nextProps.<span class="hljs-property">unstable_avoidThisFallback</span> !== <span class="hljs-literal">true</span>) {
          suspenseContext = <span class="hljs-title function_">addSubtreeSuspenseContext</span>(suspenseContext, <span class="hljs-title class_">InvisibleParentSuspenseContext</span>);
        }
      }
    }

    suspenseContext = <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseContext);
    <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, suspenseContext); <span class="hljs-comment">// OK, the next part is confusing. We&#x27;re about to reconcile the Suspense</span></pre></div></div>
            
        </li>
        
        
        <li id="section-773">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-773">&#x00a7;</a>
              </div>
              <p>boundary’s children. This involves some custom reconcilation logic. Two
main reasons this is so complicated.</p>
<p>First, Legacy Mode has different semantics for backwards compatibility. The
primary tree will commit in an inconsistent state, so when we do the
second pass to render the fallback, we do some exceedingly, uh, clever
hacks to make that not totally break. Like transferring effects and
deletions from hidden tree. In Concurrent Mode, it’s much simpler,
because we bailout on the primary tree completely and leave it in its old
state, no effects. Same as what we do for Offscreen (except that
Offscreen doesn’t have the first render pass).</p>
<p>Second is hydration. During hydration, the Suspense fiber has a slightly
different layout, where the child points to a dehydrated fragment, which
contains the DOM rendered by the server.</p>
<p>Third, even if you set all that aside, Suspense is like error boundaries in
that we first we try to render one tree, and if that fails, we render again
and switch to a different tree. Like a try/catch block. So we have to track
which branch we’re currently rendering. Ideally we would model this using
a stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-774">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-774">&#x00a7;</a>
              </div>
              <p>Initial mount
If we’re currently hydrating, try to hydrate this boundary.
But only if this has a fallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-property">fallback</span> !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-title function_">tryToClaimNextHydratableInstance</span>(workInProgress); <span class="hljs-comment">// This could&#x27;ve been a dehydrated suspense component.</span>

        {
          <span class="hljs-keyword">var</span> suspenseState = workInProgress.<span class="hljs-property">memoizedState</span>;

          <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> dehydrated = suspenseState.<span class="hljs-property">dehydrated</span>;

            <span class="hljs-keyword">if</span> (dehydrated !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountDehydratedSuspenseComponent</span>(workInProgress, dehydrated);
            }
          }
        }
      }

      <span class="hljs-keyword">var</span> nextPrimaryChildren = nextProps.<span class="hljs-property">children</span>;
      <span class="hljs-keyword">var</span> nextFallbackChildren = nextProps.<span class="hljs-property">fallback</span>;

      <span class="hljs-keyword">if</span> (showFallback) {
        <span class="hljs-keyword">var</span> fallbackFragment = <span class="hljs-title function_">mountSuspenseFallbackChildren</span>(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
        <span class="hljs-keyword">var</span> primaryChildFragment = workInProgress.<span class="hljs-property">child</span>;
        primaryChildFragment.<span class="hljs-property">memoizedState</span> = <span class="hljs-title function_">mountSuspenseOffscreenState</span>(renderLanes);
        workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-variable constant_">SUSPENDED_MARKER</span>;
        <span class="hljs-keyword">return</span> fallbackFragment;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextProps.<span class="hljs-property">unstable_expectedLoadTime</span> === <span class="hljs-string">&#x27;number&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-775">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-775">&#x00a7;</a>
              </div>
              <p>This is a CPU-bound tree. Skip this tree and show a placeholder to
unblock the surrounding content. Then immediately retry after the
initial commit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> _fallbackFragment = <span class="hljs-title function_">mountSuspenseFallbackChildren</span>(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);

        <span class="hljs-keyword">var</span> _primaryChildFragment = workInProgress.<span class="hljs-property">child</span>;
        _primaryChildFragment.<span class="hljs-property">memoizedState</span> = <span class="hljs-title function_">mountSuspenseOffscreenState</span>(renderLanes);
        workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-variable constant_">SUSPENDED_MARKER</span>; <span class="hljs-comment">// Since nothing actually suspended, there will nothing to ping this to</span></pre></div></div>
            
        </li>
        
        
        <li id="section-776">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-776">&#x00a7;</a>
              </div>
              <p>get it started back up to attempt the next item. While in terms of
priority this work has the same priority as this current render, it’s
not part of the same transition once the transition has committed. If
it’s sync, we still want to yield so that it can be painted.
Conceptually, this is really the same as pinging. We can use any
RetryLane even if it’s the one currently rendering since we’re leaving
it behind on this node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">SomeRetryLane</span>;

        {
          <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">SomeRetryLane</span>);
        }

        <span class="hljs-keyword">return</span> _fallbackFragment;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountSuspensePrimaryChildren</span>(workInProgress, nextPrimaryChildren, renderLanes);
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-777">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-777">&#x00a7;</a>
              </div>
              <p>This is an update.
If the current fiber has a SuspenseState, that means it’s already showing
a fallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> prevState = current.<span class="hljs-property">memoizedState</span>;

      <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-778">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-778">&#x00a7;</a>
              </div>
              <p>The current tree is already showing a fallback
Special path for hydration</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        {
          <span class="hljs-keyword">var</span> _dehydrated = prevState.<span class="hljs-property">dehydrated</span>;

          <span class="hljs-keyword">if</span> (_dehydrated !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (!didSuspend) {
              <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateDehydratedSuspenseComponent</span>(current, workInProgress, _dehydrated, prevState, renderLanes);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">memoizedState</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-779">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-779">&#x00a7;</a>
              </div>
              <p>Something suspended and we should still be in dehydrated mode.
Leave the existing child in place.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>; <span class="hljs-comment">// The dehydrated completion pass expects this flag to be there</span></pre></div></div>
            
        </li>
        
        
        <li id="section-780">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-780">&#x00a7;</a>
              </div>
              <p>but the normal suspense pass doesn’t.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-781">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-781">&#x00a7;</a>
              </div>
              <p>Suspended but we should no longer be in dehydrated mode.
Therefore we now have to render the fallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> _nextPrimaryChildren = nextProps.<span class="hljs-property">children</span>;
              <span class="hljs-keyword">var</span> _nextFallbackChildren = nextProps.<span class="hljs-property">fallback</span>;
              <span class="hljs-keyword">var</span> fallbackChildFragment = <span class="hljs-title function_">mountSuspenseFallbackAfterRetryWithoutHydrating</span>(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);
              <span class="hljs-keyword">var</span> _primaryChildFragment2 = workInProgress.<span class="hljs-property">child</span>;
              _primaryChildFragment2.<span class="hljs-property">memoizedState</span> = <span class="hljs-title function_">mountSuspenseOffscreenState</span>(renderLanes);
              workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-variable constant_">SUSPENDED_MARKER</span>;
              <span class="hljs-keyword">return</span> fallbackChildFragment;
            }
          }
        }

        <span class="hljs-keyword">if</span> (showFallback) {
          <span class="hljs-keyword">var</span> _nextFallbackChildren2 = nextProps.<span class="hljs-property">fallback</span>;
          <span class="hljs-keyword">var</span> _nextPrimaryChildren2 = nextProps.<span class="hljs-property">children</span>;

          <span class="hljs-keyword">var</span> _fallbackChildFragment = <span class="hljs-title function_">updateSuspenseFallbackChildren</span>(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);

          <span class="hljs-keyword">var</span> _primaryChildFragment3 = workInProgress.<span class="hljs-property">child</span>;
          <span class="hljs-keyword">var</span> prevOffscreenState = current.<span class="hljs-property">child</span>.<span class="hljs-property">memoizedState</span>;
          _primaryChildFragment3.<span class="hljs-property">memoizedState</span> = prevOffscreenState === <span class="hljs-literal">null</span> ? <span class="hljs-title function_">mountSuspenseOffscreenState</span>(renderLanes) : <span class="hljs-title function_">updateSuspenseOffscreenState</span>(prevOffscreenState, renderLanes);
          _primaryChildFragment3.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">getRemainingWorkInPrimaryTree</span>(current, renderLanes);
          workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-variable constant_">SUSPENDED_MARKER</span>;
          <span class="hljs-keyword">return</span> _fallbackChildFragment;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> _nextPrimaryChildren3 = nextProps.<span class="hljs-property">children</span>;

          <span class="hljs-keyword">var</span> _primaryChildFragment4 = <span class="hljs-title function_">updateSuspensePrimaryChildren</span>(current, workInProgress, _nextPrimaryChildren3, renderLanes);

          workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">return</span> _primaryChildFragment4;
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-782">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-782">&#x00a7;</a>
              </div>
              <p>The current tree is not already showing a fallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (showFallback) {</pre></div></div>
            
        </li>
        
        
        <li id="section-783">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-783">&#x00a7;</a>
              </div>
              <p>Timed out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> _nextFallbackChildren3 = nextProps.<span class="hljs-property">fallback</span>;
          <span class="hljs-keyword">var</span> _nextPrimaryChildren4 = nextProps.<span class="hljs-property">children</span>;

          <span class="hljs-keyword">var</span> _fallbackChildFragment2 = <span class="hljs-title function_">updateSuspenseFallbackChildren</span>(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);

          <span class="hljs-keyword">var</span> _primaryChildFragment5 = workInProgress.<span class="hljs-property">child</span>;
          <span class="hljs-keyword">var</span> _prevOffscreenState = current.<span class="hljs-property">child</span>.<span class="hljs-property">memoizedState</span>;
          _primaryChildFragment5.<span class="hljs-property">memoizedState</span> = _prevOffscreenState === <span class="hljs-literal">null</span> ? <span class="hljs-title function_">mountSuspenseOffscreenState</span>(renderLanes) : <span class="hljs-title function_">updateSuspenseOffscreenState</span>(_prevOffscreenState, renderLanes);
          _primaryChildFragment5.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">getRemainingWorkInPrimaryTree</span>(current, renderLanes); <span class="hljs-comment">// Skip the primary children, and continue working on the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-784">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-784">&#x00a7;</a>
              </div>
              <p>fallback children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-variable constant_">SUSPENDED_MARKER</span>;
          <span class="hljs-keyword">return</span> _fallbackChildFragment2;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-785">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-785">&#x00a7;</a>
              </div>
              <p>Still haven’t timed out. Continue rendering the children, like we
normally do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> _nextPrimaryChildren5 = nextProps.<span class="hljs-property">children</span>;

          <span class="hljs-keyword">var</span> _primaryChildFragment6 = <span class="hljs-title function_">updateSuspensePrimaryChildren</span>(current, workInProgress, _nextPrimaryChildren5, renderLanes);

          workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">return</span> _primaryChildFragment6;
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountSuspensePrimaryChildren</span>(<span class="hljs-params">workInProgress, primaryChildren, renderLanes</span>) {
    <span class="hljs-keyword">var</span> mode = workInProgress.<span class="hljs-property">mode</span>;
    <span class="hljs-keyword">var</span> primaryChildProps = {
      <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;visible&#x27;</span>,
      <span class="hljs-attr">children</span>: primaryChildren
    };
    <span class="hljs-keyword">var</span> primaryChildFragment = <span class="hljs-title function_">createFiberFromOffscreen</span>(primaryChildProps, mode, renderLanes, <span class="hljs-literal">null</span>);
    primaryChildFragment.<span class="hljs-property">return</span> = workInProgress;
    workInProgress.<span class="hljs-property">child</span> = primaryChildFragment;
    <span class="hljs-keyword">return</span> primaryChildFragment;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountSuspenseFallbackChildren</span>(<span class="hljs-params">workInProgress, primaryChildren, fallbackChildren, renderLanes</span>) {
    <span class="hljs-keyword">var</span> mode = workInProgress.<span class="hljs-property">mode</span>;
    <span class="hljs-keyword">var</span> progressedPrimaryFragment = workInProgress.<span class="hljs-property">child</span>;
    <span class="hljs-keyword">var</span> primaryChildProps = {
      <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;hidden&#x27;</span>,
      <span class="hljs-attr">children</span>: primaryChildren
    };
    <span class="hljs-keyword">var</span> primaryChildFragment;
    <span class="hljs-keyword">var</span> fallbackChildFragment;

    <span class="hljs-keyword">if</span> ((mode &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span> &amp;&amp; progressedPrimaryFragment !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-786">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-786">&#x00a7;</a>
              </div>
              <p>In legacy mode, we commit the primary tree as if it successfully
completed, even though it’s in an inconsistent state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      primaryChildFragment = progressedPrimaryFragment;
      primaryChildFragment.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;
      primaryChildFragment.<span class="hljs-property">pendingProps</span> = primaryChildProps;

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-787">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-787">&#x00a7;</a>
              </div>
              <p>Reset the durations from the first pass so they aren’t included in the
final amounts. This seems counterintuitive, since we’re intentionally
not measuring part of the render phase, but this makes it match what we
do in Concurrent Mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        primaryChildFragment.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;
        primaryChildFragment.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;
        primaryChildFragment.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-number">0</span>;
        primaryChildFragment.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-number">0</span>;
      }

      fallbackChildFragment = <span class="hljs-title function_">createFiberFromFragment</span>(fallbackChildren, mode, renderLanes, <span class="hljs-literal">null</span>);
    } <span class="hljs-keyword">else</span> {
      primaryChildFragment = <span class="hljs-title function_">createFiberFromOffscreen</span>(primaryChildProps, mode, <span class="hljs-title class_">NoLanes</span>, <span class="hljs-literal">null</span>);
      fallbackChildFragment = <span class="hljs-title function_">createFiberFromFragment</span>(fallbackChildren, mode, renderLanes, <span class="hljs-literal">null</span>);
    }

    primaryChildFragment.<span class="hljs-property">return</span> = workInProgress;
    fallbackChildFragment.<span class="hljs-property">return</span> = workInProgress;
    primaryChildFragment.<span class="hljs-property">sibling</span> = fallbackChildFragment;
    workInProgress.<span class="hljs-property">child</span> = primaryChildFragment;
    <span class="hljs-keyword">return</span> fallbackChildFragment;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkInProgressOffscreenFiber</span>(<span class="hljs-params">current, offscreenProps</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-788">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-788">&#x00a7;</a>
              </div>
              <p>The props argument to <code>createWorkInProgress</code> is <code>any</code> typed, so we use this
wrapper function to constrain it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createWorkInProgress</span>(current, offscreenProps);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSuspensePrimaryChildren</span>(<span class="hljs-params">current, workInProgress, primaryChildren, renderLanes</span>) {
    <span class="hljs-keyword">var</span> currentPrimaryChildFragment = current.<span class="hljs-property">child</span>;
    <span class="hljs-keyword">var</span> currentFallbackChildFragment = currentPrimaryChildFragment.<span class="hljs-property">sibling</span>;
    <span class="hljs-keyword">var</span> primaryChildFragment = <span class="hljs-title function_">createWorkInProgressOffscreenFiber</span>(currentPrimaryChildFragment, {
      <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;visible&#x27;</span>,
      <span class="hljs-attr">children</span>: primaryChildren
    });

    <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {
      primaryChildFragment.<span class="hljs-property">lanes</span> = renderLanes;
    }

    primaryChildFragment.<span class="hljs-property">return</span> = workInProgress;
    primaryChildFragment.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (currentFallbackChildFragment !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-789">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-789">&#x00a7;</a>
              </div>
              <p>Delete the fallback child fragment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      currentFallbackChildFragment.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
      currentFallbackChildFragment.<span class="hljs-property">flags</span> = <span class="hljs-title class_">Deletion</span>;
      workInProgress.<span class="hljs-property">firstEffect</span> = workInProgress.<span class="hljs-property">lastEffect</span> = currentFallbackChildFragment;
    }

    workInProgress.<span class="hljs-property">child</span> = primaryChildFragment;
    <span class="hljs-keyword">return</span> primaryChildFragment;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSuspenseFallbackChildren</span>(<span class="hljs-params">current, workInProgress, primaryChildren, fallbackChildren, renderLanes</span>) {
    <span class="hljs-keyword">var</span> mode = workInProgress.<span class="hljs-property">mode</span>;
    <span class="hljs-keyword">var</span> currentPrimaryChildFragment = current.<span class="hljs-property">child</span>;
    <span class="hljs-keyword">var</span> currentFallbackChildFragment = currentPrimaryChildFragment.<span class="hljs-property">sibling</span>;
    <span class="hljs-keyword">var</span> primaryChildProps = {
      <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;hidden&#x27;</span>,
      <span class="hljs-attr">children</span>: primaryChildren
    };
    <span class="hljs-keyword">var</span> primaryChildFragment;

    <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// In legacy mode, we commit the primary tree as if it successfully</span></pre></div></div>
            
        </li>
        
        
        <li id="section-790">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-790">&#x00a7;</a>
              </div>
              <p>completed, even though it’s in an inconsistent state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (mode &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span> &amp;&amp; <span class="hljs-comment">// Make sure we&#x27;re on the second pass, i.e. the primary child fragment was</span></pre></div></div>
            
        </li>
        
        
        <li id="section-791">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-791">&#x00a7;</a>
              </div>
              <p>already cloned. In legacy mode, the only case where this isn’t true is
when DevTools forces us to display a fallback; we skip the first render
pass entirely and go straight to rendering the fallback. (In Concurrent
Mode, SuspenseList can also trigger this scenario, but this is a legacy-
only codepath.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">child</span> !== currentPrimaryChildFragment) {
      <span class="hljs-keyword">var</span> progressedPrimaryFragment = workInProgress.<span class="hljs-property">child</span>;
      primaryChildFragment = progressedPrimaryFragment;
      primaryChildFragment.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;
      primaryChildFragment.<span class="hljs-property">pendingProps</span> = primaryChildProps;

      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-792">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-792">&#x00a7;</a>
              </div>
              <p>Reset the durations from the first pass so they aren’t included in the
final amounts. This seems counterintuitive, since we’re intentionally
not measuring part of the render phase, but this makes it match what we
do in Concurrent Mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        primaryChildFragment.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;
        primaryChildFragment.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;
        primaryChildFragment.<span class="hljs-property">selfBaseDuration</span> = currentPrimaryChildFragment.<span class="hljs-property">selfBaseDuration</span>;
        primaryChildFragment.<span class="hljs-property">treeBaseDuration</span> = currentPrimaryChildFragment.<span class="hljs-property">treeBaseDuration</span>;
      } <span class="hljs-comment">// The fallback fiber was added as a deletion effect during the first pass.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-793">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-793">&#x00a7;</a>
              </div>
              <p>However, since we’re going to remain on the fallback, we no longer want
to delete it. So we need to remove it from the list. Deletions are stored
on the same list as effects. We want to keep the effects from the primary
tree. So we copy the primary child fragment’s effect list, which does not
include the fallback deletion effect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> progressedLastEffect = primaryChildFragment.<span class="hljs-property">lastEffect</span>;

      <span class="hljs-keyword">if</span> (progressedLastEffect !== <span class="hljs-literal">null</span>) {
        workInProgress.<span class="hljs-property">firstEffect</span> = primaryChildFragment.<span class="hljs-property">firstEffect</span>;
        workInProgress.<span class="hljs-property">lastEffect</span> = progressedLastEffect;
        progressedLastEffect.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-794">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-794">&#x00a7;</a>
              </div>
              <p>TODO: Reset this somewhere else? Lol legacy mode is so weird.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgress.<span class="hljs-property">firstEffect</span> = workInProgress.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
      }
    } <span class="hljs-keyword">else</span> {
      primaryChildFragment = <span class="hljs-title function_">createWorkInProgressOffscreenFiber</span>(currentPrimaryChildFragment, primaryChildProps);
    }

    <span class="hljs-keyword">var</span> fallbackChildFragment;

    <span class="hljs-keyword">if</span> (currentFallbackChildFragment !== <span class="hljs-literal">null</span>) {
      fallbackChildFragment = <span class="hljs-title function_">createWorkInProgress</span>(currentFallbackChildFragment, fallbackChildren);
    } <span class="hljs-keyword">else</span> {
      fallbackChildFragment = <span class="hljs-title function_">createFiberFromFragment</span>(fallbackChildren, mode, renderLanes, <span class="hljs-literal">null</span>); <span class="hljs-comment">// Needs a placement effect because the parent (the Suspense boundary) already</span></pre></div></div>
            
        </li>
        
        
        <li id="section-795">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-795">&#x00a7;</a>
              </div>
              <p>mounted but this is a new fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      fallbackChildFragment.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>;
    }

    fallbackChildFragment.<span class="hljs-property">return</span> = workInProgress;
    primaryChildFragment.<span class="hljs-property">return</span> = workInProgress;
    primaryChildFragment.<span class="hljs-property">sibling</span> = fallbackChildFragment;
    workInProgress.<span class="hljs-property">child</span> = primaryChildFragment;
    <span class="hljs-keyword">return</span> fallbackChildFragment;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">retrySuspenseComponentWithoutHydrating</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-796">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-796">&#x00a7;</a>
              </div>
              <p>This will add the old fiber to the deletion list</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress, current.<span class="hljs-property">child</span>, <span class="hljs-literal">null</span>, renderLanes); <span class="hljs-comment">// We&#x27;re now not suspended nor dehydrated.</span>

    <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> primaryChildren = nextProps.<span class="hljs-property">children</span>;
    <span class="hljs-keyword">var</span> primaryChildFragment = <span class="hljs-title function_">mountSuspensePrimaryChildren</span>(workInProgress, primaryChildren, renderLanes); <span class="hljs-comment">// Needs a placement effect because the parent (the Suspense boundary) already</span></pre></div></div>
            
        </li>
        
        
        <li id="section-797">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-797">&#x00a7;</a>
              </div>
              <p>mounted but this is a new fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    primaryChildFragment.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>;
    workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> primaryChildFragment;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountSuspenseFallbackAfterRetryWithoutHydrating</span>(<span class="hljs-params">current, workInProgress, primaryChildren, fallbackChildren, renderLanes</span>) {
    <span class="hljs-keyword">var</span> mode = workInProgress.<span class="hljs-property">mode</span>;
    <span class="hljs-keyword">var</span> primaryChildFragment = <span class="hljs-title function_">createFiberFromOffscreen</span>(primaryChildren, mode, <span class="hljs-title class_">NoLanes</span>, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">var</span> fallbackChildFragment = <span class="hljs-title function_">createFiberFromFragment</span>(fallbackChildren, mode, renderLanes, <span class="hljs-literal">null</span>); <span class="hljs-comment">// Needs a placement effect because the parent (the Suspense</span></pre></div></div>
            
        </li>
        
        
        <li id="section-798">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-798">&#x00a7;</a>
              </div>
              <p>boundary) already mounted but this is a new fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    fallbackChildFragment.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>;
    primaryChildFragment.<span class="hljs-property">return</span> = workInProgress;
    fallbackChildFragment.<span class="hljs-property">return</span> = workInProgress;
    primaryChildFragment.<span class="hljs-property">sibling</span> = fallbackChildFragment;
    workInProgress.<span class="hljs-property">child</span> = primaryChildFragment;

    <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) !== <span class="hljs-title class_">NoMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-799">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-799">&#x00a7;</a>
              </div>
              <p>We will have dropped the effect list which contains the
deletion. We need to reconcile to delete the current child.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress, current.<span class="hljs-property">child</span>, <span class="hljs-literal">null</span>, renderLanes);
    }

    <span class="hljs-keyword">return</span> fallbackChildFragment;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountDehydratedSuspenseComponent</span>(<span class="hljs-params">workInProgress, suspenseInstance, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-800">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-800">&#x00a7;</a>
              </div>
              <p>During the first pass, we’ll bail out and not drill into the children.
Instead, we’ll leave the content in place and try to hydrate it later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {
      {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Cannot hydrate Suspense in legacy mode. Switch from &#x27;</span> + <span class="hljs-string">&#x27;ReactDOM.hydrate(element, container) to &#x27;</span> + <span class="hljs-string">&#x27;ReactDOM.createBlockingRoot(container, { hydrate: true })&#x27;</span> + <span class="hljs-string">&#x27;.render(element) or remove the Suspense components from &#x27;</span> + <span class="hljs-string">&#x27;the server rendered components.&#x27;</span>);
      }

      workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">laneToLanes</span>(<span class="hljs-title class_">SyncLane</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSuspenseInstanceFallback</span>(suspenseInstance)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-801">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-801">&#x00a7;</a>
              </div>
              <p>This is a client-only boundary. Since we won’t get any content from the server
for this, we need to schedule that at a higher priority based on when it would
have timed out. In theory we could render it in this pass but it would have the
wrong priority associated with it and will prevent hydration of parent path.
Instead, we’ll leave work left on it to render it in a separate commit.
TODO This time should be the time at which the server rendered response that is
a parent to this boundary was displayed. However, since we currently don’t have
a protocol to transfer that time, we’ll just estimate it by using the current
time. This will mean that Suspense timeouts are slightly shifted to later than
they should be.
Schedule a normal pri update to render this content.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">DefaultHydrationLane</span>);
      }

      workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">laneToLanes</span>(<span class="hljs-title class_">DefaultHydrationLane</span>);
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-802">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-802">&#x00a7;</a>
              </div>
              <p>We’ll continue hydrating the rest at offscreen priority since we’ll already
be showing the right content coming from the server, it is no rush.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">laneToLanes</span>(<span class="hljs-title class_">OffscreenLane</span>);

      {
        <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">OffscreenLane</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateDehydratedSuspenseComponent</span>(<span class="hljs-params">current, workInProgress, suspenseInstance, suspenseState, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-803">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-803">&#x00a7;</a>
              </div>
              <p>We should never be hydrating at this point because it is the first pass,
but after we’ve already committed once.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title function_">warnIfHydrating</span>();

    <span class="hljs-keyword">if</span> ((<span class="hljs-title function_">getExecutionContext</span>() &amp; <span class="hljs-title class_">RetryAfterError</span>) !== <span class="hljs-title class_">NoContext</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">retrySuspenseComponentWithoutHydrating</span>(current, workInProgress, renderLanes);
    }

    <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">retrySuspenseComponentWithoutHydrating</span>(current, workInProgress, renderLanes);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSuspenseInstanceFallback</span>(suspenseInstance)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-804">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-804">&#x00a7;</a>
              </div>
              <p>This boundary is in a permanent fallback state. In this case, we’ll never
get an update and we’ll never be able to hydrate the final content. Let’s just try the
client side render instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">retrySuspenseComponentWithoutHydrating</span>(current, workInProgress, renderLanes);
    } <span class="hljs-comment">// We use lanes to indicate that a child might depend on context, so if</span></pre></div></div>
            
        </li>
        
        
        <li id="section-805">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-805">&#x00a7;</a>
              </div>
              <p>any context has changed, we need to treat is as if the input might have changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> hasContextChanged = <span class="hljs-title function_">includesSomeLane</span>(renderLanes, current.<span class="hljs-property">childLanes</span>);

    <span class="hljs-keyword">if</span> (didReceiveUpdate || hasContextChanged) {</pre></div></div>
            
        </li>
        
        
        <li id="section-806">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-806">&#x00a7;</a>
              </div>
              <p>This boundary has changed since the first render. This means that we are now unable to
hydrate it. We might still be able to hydrate it using a higher priority lane.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">getWorkInProgressRoot</span>();

      <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> attemptHydrationAtLane = <span class="hljs-title function_">getBumpedLaneForHydration</span>(root, renderLanes);

        <span class="hljs-keyword">if</span> (attemptHydrationAtLane !== <span class="hljs-title class_">NoLane</span> &amp;&amp; attemptHydrationAtLane !== suspenseState.<span class="hljs-property">retryLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-807">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-807">&#x00a7;</a>
              </div>
              <p>Intentionally mutating since this render will get interrupted. This
is one of the very rare times where we mutate the current tree
during the render phase.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          suspenseState.<span class="hljs-property">retryLane</span> = attemptHydrationAtLane; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Ideally this would inherit the event time of the current render</span>

          <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title class_">NoTimestamp</span>;
          <span class="hljs-title function_">scheduleUpdateOnFiber</span>(current, attemptHydrationAtLane, eventTime);
        }
      } <span class="hljs-comment">// If we have scheduled higher pri work above, this will probably just abort the render</span></pre></div></div>
            
        </li>
        
        
        <li id="section-808">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-808">&#x00a7;</a>
              </div>
              <p>since we now have higher priority work, but in case it doesn’t, we need to prepare to
render something, if we time out. Even if that requires us to delete everything and
skip hydration.
Delay having to do this as long as the suspense timeout allows us.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-title function_">renderDidSuspendDelayIfPossible</span>();
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">retrySuspenseComponentWithoutHydrating</span>(current, workInProgress, renderLanes);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSuspenseInstancePending</span>(suspenseInstance)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-809">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-809">&#x00a7;</a>
              </div>
              <p>This component is still pending more data from the server, so we can’t hydrate its
content. We treat it as if this component suspended itself. It might seem as if
we could just try to render it client-side instead. However, this will perform a
lot of unnecessary work and is unlikely to complete since it often will suspend
on missing data anyway. Additionally, the server might be able to render more
than we can on the client yet. In that case we’d end up with more fallback states
on the client than if we just leave it alone. If the server times out or errors
these should update this boundary to the permanent Fallback state instead.
Mark it as having captured (i.e. suspended).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>; <span class="hljs-comment">// Leave the child in place. I.e. the dehydrated fragment.</span>

      workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>; <span class="hljs-comment">// Register a callback to retry this boundary once the server has sent the result.</span>

      <span class="hljs-keyword">var</span> retry = retryDehydratedSuspenseBoundary.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, current);

      {
        retry = <span class="hljs-title function_">unstable_wrap</span>(retry);
      }

      <span class="hljs-title function_">registerSuspenseInstanceRetry</span>(suspenseInstance, retry);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-810">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-810">&#x00a7;</a>
              </div>
              <p>This is the first attempt.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">reenterHydrationStateFromDehydratedSuspenseInstance</span>(workInProgress, suspenseInstance);
      <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
      <span class="hljs-keyword">var</span> primaryChildren = nextProps.<span class="hljs-property">children</span>;
      <span class="hljs-keyword">var</span> primaryChildFragment = <span class="hljs-title function_">mountSuspensePrimaryChildren</span>(workInProgress, primaryChildren, renderLanes); <span class="hljs-comment">// Mark the children as hydrating. This is a fast path to know whether this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-811">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-811">&#x00a7;</a>
              </div>
              <p>tree is part of a hydrating tree. This is used to determine if a child
node has fully mounted yet, and for scheduling event replaying.
Conceptually this is similar to Placement in that a new subtree is
inserted into the React tree here. It just happens to not need DOM
mutations because it already exists.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      primaryChildFragment.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Hydrating</span>;
      <span class="hljs-keyword">return</span> primaryChildFragment;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleWorkOnFiber</span>(<span class="hljs-params">fiber, renderLanes</span>) {
    fiber.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(fiber.<span class="hljs-property">lanes</span>, renderLanes);
    <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
      alternate.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(alternate.<span class="hljs-property">lanes</span>, renderLanes);
    }

    <span class="hljs-title function_">scheduleWorkOnParentPath</span>(fiber.<span class="hljs-property">return</span>, renderLanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">propagateSuspenseContextChange</span>(<span class="hljs-params">workInProgress, firstChild, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-812">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-812">&#x00a7;</a>
              </div>
              <p>Mark any Suspense boundaries with fallbacks as having work to do.
If they were previously forced into fallbacks, they may now be able
to unblock.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> node = firstChild;

    <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span>) {
        <span class="hljs-keyword">var</span> state = node.<span class="hljs-property">memoizedState</span>;

        <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">scheduleWorkOnFiber</span>(node, renderLanes);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseListComponent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-813">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-813">&#x00a7;</a>
              </div>
              <p>If the tail is hidden there might not be an Suspense boundaries
to schedule work on. In this case we have to schedule it on the
list itself.
We don’t have to traverse to the children of the list since
the list will propagate the change when it rerenders.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">scheduleWorkOnFiber</span>(node, renderLanes);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {
        node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
        node = node.<span class="hljs-property">child</span>;
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (node === workInProgress) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">return</span> === workInProgress) {
          <span class="hljs-keyword">return</span>;
        }

        node = node.<span class="hljs-property">return</span>;
      }

      node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
      node = node.<span class="hljs-property">sibling</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findLastContentRow</span>(<span class="hljs-params">firstChild</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-814">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-814">&#x00a7;</a>
              </div>
              <p>This is going to find the last row among these children that is already
showing content on the screen, as opposed to being in fallback state or
new. If a row has multiple Suspense boundaries, any of them being in the
fallback state, counts as the whole row being in a fallback state.
Note that the “rows” will be workInProgress, but any nested children
will still be current since we haven’t rendered them yet. The mounted
order may not be the same as the new order. We use the new order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> row = firstChild;
    <span class="hljs-keyword">var</span> lastContentRow = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">while</span> (row !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> currentRow = row.<span class="hljs-property">alternate</span>; <span class="hljs-comment">// New rows can&#x27;t be content rows.</span>

      <span class="hljs-keyword">if</span> (currentRow !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">findFirstSuspended</span>(currentRow) === <span class="hljs-literal">null</span>) {
        lastContentRow = row;
      }

      row = row.<span class="hljs-property">sibling</span>;
    }

    <span class="hljs-keyword">return</span> lastContentRow;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateRevealOrder</span>(<span class="hljs-params">revealOrder</span>) {
    {
      <span class="hljs-keyword">if</span> (revealOrder !== <span class="hljs-literal">undefined</span> &amp;&amp; revealOrder !== <span class="hljs-string">&#x27;forwards&#x27;</span> &amp;&amp; revealOrder !== <span class="hljs-string">&#x27;backwards&#x27;</span> &amp;&amp; revealOrder !== <span class="hljs-string">&#x27;together&#x27;</span> &amp;&amp; !didWarnAboutRevealOrder[revealOrder]) {
        didWarnAboutRevealOrder[revealOrder] = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> revealOrder === <span class="hljs-string">&#x27;string&#x27;</span>) {
          <span class="hljs-keyword">switch</span> (revealOrder.<span class="hljs-title function_">toLowerCase</span>()) {
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;together&#x27;</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;forwards&#x27;</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;backwards&#x27;</span>:
              {
                <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. &#x27;</span> + <span class="hljs-string">&#x27;Use lowercase &quot;%s&quot; instead.&#x27;</span>, revealOrder, revealOrder.<span class="hljs-title function_">toLowerCase</span>());

                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;forward&#x27;</span>:
            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;backward&#x27;</span>:
              {
                <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;&quot;%s&quot; is not a valid value for revealOrder on &lt;SuspenseList /&gt;. &#x27;</span> + <span class="hljs-string">&#x27;React uses the -s suffix in the spelling. Use &quot;%ss&quot; instead.&#x27;</span>, revealOrder, revealOrder.<span class="hljs-title function_">toLowerCase</span>());

                <span class="hljs-keyword">break</span>;
              }

            <span class="hljs-attr">default</span>:
              <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;&quot;%s&quot; is not a supported revealOrder on &lt;SuspenseList /&gt;. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?&#x27;</span>, revealOrder);

              <span class="hljs-keyword">break</span>;
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s is not a supported value for revealOrder on &lt;SuspenseList /&gt;. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean &quot;together&quot;, &quot;forwards&quot; or &quot;backwards&quot;?&#x27;</span>, revealOrder);
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateTailOptions</span>(<span class="hljs-params">tailMode, revealOrder</span>) {
    {
      <span class="hljs-keyword">if</span> (tailMode !== <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnAboutTailOptions[tailMode]) {
        <span class="hljs-keyword">if</span> (tailMode !== <span class="hljs-string">&#x27;collapsed&#x27;</span> &amp;&amp; tailMode !== <span class="hljs-string">&#x27;hidden&#x27;</span>) {
          didWarnAboutTailOptions[tailMode] = <span class="hljs-literal">true</span>;

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;&quot;%s&quot; is not a supported value for tail on &lt;SuspenseList /&gt;. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean &quot;collapsed&quot; or &quot;hidden&quot;?&#x27;</span>, tailMode);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (revealOrder !== <span class="hljs-string">&#x27;forwards&#x27;</span> &amp;&amp; revealOrder !== <span class="hljs-string">&#x27;backwards&#x27;</span>) {
          didWarnAboutTailOptions[tailMode] = <span class="hljs-literal">true</span>;

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;&lt;SuspenseList tail=&quot;%s&quot; /&gt; is only valid if revealOrder is &#x27;</span> + <span class="hljs-string">&#x27;&quot;forwards&quot; or &quot;backwards&quot;. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean to specify revealOrder=&quot;forwards&quot;?&#x27;</span>, tailMode);
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateSuspenseListNestedChild</span>(<span class="hljs-params">childSlot, index</span>) {
    {
      <span class="hljs-keyword">var</span> isArray = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(childSlot);
      <span class="hljs-keyword">var</span> isIterable = !isArray &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title function_">getIteratorFn</span>(childSlot) === <span class="hljs-string">&#x27;function&#x27;</span>;

      <span class="hljs-keyword">if</span> (isArray || isIterable) {
        <span class="hljs-keyword">var</span> type = isArray ? <span class="hljs-string">&#x27;array&#x27;</span> : <span class="hljs-string">&#x27;iterable&#x27;</span>;

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A nested %s was passed to row #%s in &lt;SuspenseList /&gt;. Wrap it in &#x27;</span> + <span class="hljs-string">&#x27;an additional SuspenseList to configure its revealOrder: &#x27;</span> + <span class="hljs-string">&#x27;&lt;SuspenseList revealOrder=...&gt; ... &#x27;</span> + <span class="hljs-string">&#x27;&lt;SuspenseList revealOrder=...&gt;{%s}&lt;/SuspenseList&gt; ... &#x27;</span> + <span class="hljs-string">&#x27;&lt;/SuspenseList&gt;&#x27;</span>, type, index, type);

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">validateSuspenseListChildren</span>(<span class="hljs-params">children, revealOrder</span>) {
    {
      <span class="hljs-keyword">if</span> ((revealOrder === <span class="hljs-string">&#x27;forwards&#x27;</span> || revealOrder === <span class="hljs-string">&#x27;backwards&#x27;</span>) &amp;&amp; children !== <span class="hljs-literal">undefined</span> &amp;&amp; children !== <span class="hljs-literal">null</span> &amp;&amp; children !== <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(children)) {
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) {
            <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">validateSuspenseListNestedChild</span>(children[i], i)) {
              <span class="hljs-keyword">return</span>;
            }
          }
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">var</span> iteratorFn = <span class="hljs-title function_">getIteratorFn</span>(children);

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> iteratorFn === <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-keyword">var</span> childrenIterator = iteratorFn.<span class="hljs-title function_">call</span>(children);

            <span class="hljs-keyword">if</span> (childrenIterator) {
              <span class="hljs-keyword">var</span> step = childrenIterator.<span class="hljs-title function_">next</span>();
              <span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>;

              <span class="hljs-keyword">for</span> (; !step.<span class="hljs-property">done</span>; step = childrenIterator.<span class="hljs-title function_">next</span>()) {
                <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">validateSuspenseListNestedChild</span>(step.<span class="hljs-property">value</span>, _i)) {
                  <span class="hljs-keyword">return</span>;
                }

                _i++;
              }
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A single row was passed to a &lt;SuspenseList revealOrder=&quot;%s&quot; /&gt;. &#x27;</span> + <span class="hljs-string">&#x27;This is not useful since it needs multiple rows. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean to pass multiple children or an array?&#x27;</span>, revealOrder);
          }
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">initSuspenseListRenderState</span>(<span class="hljs-params">workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering</span>) {
    <span class="hljs-keyword">var</span> renderState = workInProgress.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (renderState === <span class="hljs-literal">null</span>) {
      workInProgress.<span class="hljs-property">memoizedState</span> = {
        <span class="hljs-attr">isBackwards</span>: isBackwards,
        <span class="hljs-attr">rendering</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">renderingStartTime</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">last</span>: lastContentRow,
        <span class="hljs-attr">tail</span>: tail,
        <span class="hljs-attr">tailMode</span>: tailMode,
        <span class="hljs-attr">lastEffect</span>: lastEffectBeforeRendering
      };
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-815">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-815">&#x00a7;</a>
              </div>
              <p>We can reuse the existing object from previous renders.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      renderState.<span class="hljs-property">isBackwards</span> = isBackwards;
      renderState.<span class="hljs-property">rendering</span> = <span class="hljs-literal">null</span>;
      renderState.<span class="hljs-property">renderingStartTime</span> = <span class="hljs-number">0</span>;
      renderState.<span class="hljs-property">last</span> = lastContentRow;
      renderState.<span class="hljs-property">tail</span> = tail;
      renderState.<span class="hljs-property">tailMode</span> = tailMode;
      renderState.<span class="hljs-property">lastEffect</span> = lastEffectBeforeRendering;
    }
  } <span class="hljs-comment">// This can end up rendering this component multiple passes.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-816">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-816">&#x00a7;</a>
              </div>
              <p>The first pass splits the children fibers into two sets. A head and tail.
We first render the head. If anything is in fallback state, we do another
pass through beginWork to rerender all children (including the tail) with
the force suspend context. If the first render didn’t have anything in
in fallback state. Then we render each row in the tail one-by-one.
That happens in the completeWork phase without going back to beginWork.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateSuspenseListComponent</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> nextProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> revealOrder = nextProps.<span class="hljs-property">revealOrder</span>;
    <span class="hljs-keyword">var</span> tailMode = nextProps.<span class="hljs-property">tail</span>;
    <span class="hljs-keyword">var</span> newChildren = nextProps.<span class="hljs-property">children</span>;
    <span class="hljs-title function_">validateRevealOrder</span>(revealOrder);
    <span class="hljs-title function_">validateTailOptions</span>(tailMode, revealOrder);
    <span class="hljs-title function_">validateSuspenseListChildren</span>(newChildren, revealOrder);
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, newChildren, renderLanes);
    <span class="hljs-keyword">var</span> suspenseContext = suspenseStackCursor.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">var</span> shouldForceFallback = <span class="hljs-title function_">hasSuspenseContext</span>(suspenseContext, <span class="hljs-title class_">ForceSuspenseFallback</span>);

    <span class="hljs-keyword">if</span> (shouldForceFallback) {
      suspenseContext = <span class="hljs-title function_">setShallowSuspenseContext</span>(suspenseContext, <span class="hljs-title class_">ForceSuspenseFallback</span>);
      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> didSuspendBefore = current !== <span class="hljs-literal">null</span> &amp;&amp; (current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoFlags</span>;

      <span class="hljs-keyword">if</span> (didSuspendBefore) {</pre></div></div>
            
        </li>
        
        
        <li id="section-817">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-817">&#x00a7;</a>
              </div>
              <p>If we previously forced a fallback, we need to schedule work
on any nested boundaries to let them know to try to render
again. This is the same as context updating.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">propagateSuspenseContextChange</span>(workInProgress, workInProgress.<span class="hljs-property">child</span>, renderLanes);
      }

      suspenseContext = <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseContext);
    }

    <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, suspenseContext);

    <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-818">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-818">&#x00a7;</a>
              </div>
              <p>In legacy mode, SuspenseList doesn’t work so we just
use make it a noop by treating it as the default revealOrder.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">switch</span> (revealOrder) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;forwards&#x27;</span>:
          {
            <span class="hljs-keyword">var</span> lastContentRow = <span class="hljs-title function_">findLastContentRow</span>(workInProgress.<span class="hljs-property">child</span>);
            <span class="hljs-keyword">var</span> tail;

            <span class="hljs-keyword">if</span> (lastContentRow === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-819">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-819">&#x00a7;</a>
              </div>
              <p>The whole list is part of the tail.
TODO: We could fast path by just rendering the tail now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              tail = workInProgress.<span class="hljs-property">child</span>;
              workInProgress.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;
            } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-820">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-820">&#x00a7;</a>
              </div>
              <p>Disconnect the tail rows after the content row.
We’re going to render them separately later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              tail = lastContentRow.<span class="hljs-property">sibling</span>;
              lastContentRow.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
            }

            <span class="hljs-title function_">initSuspenseListRenderState</span>(workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-comment">// isBackwards</span>
              tail, lastContentRow, tailMode, workInProgress.<span class="hljs-property">lastEffect</span>);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;backwards&#x27;</span>:
          {</pre></div></div>
            
        </li>
        
        
        <li id="section-821">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-821">&#x00a7;</a>
              </div>
              <p>We’re going to find the first row that has existing content.
At the same time we’re going to reverse the list of everything
we pass in the meantime. That’s going to be our tail in reverse
order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> _tail = <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">var</span> row = workInProgress.<span class="hljs-property">child</span>;
            workInProgress.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">while</span> (row !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> currentRow = row.<span class="hljs-property">alternate</span>; <span class="hljs-comment">// New rows can&#x27;t be content rows.</span>

              <span class="hljs-keyword">if</span> (currentRow !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">findFirstSuspended</span>(currentRow) === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-822">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-822">&#x00a7;</a>
              </div>
              <p>This is the beginning of the main content.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                workInProgress.<span class="hljs-property">child</span> = row;
                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">var</span> nextRow = row.<span class="hljs-property">sibling</span>;
              row.<span class="hljs-property">sibling</span> = _tail;
              _tail = row;
              row = nextRow;
            } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> If workInProgress.child is null, we can continue on the tail immediately.</span>


            <span class="hljs-title function_">initSuspenseListRenderState</span>(workInProgress, <span class="hljs-literal">true</span>, <span class="hljs-comment">// isBackwards</span>
              _tail, <span class="hljs-literal">null</span>, <span class="hljs-comment">// last</span>
              tailMode, workInProgress.<span class="hljs-property">lastEffect</span>);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;together&#x27;</span>:
          {
            <span class="hljs-title function_">initSuspenseListRenderState</span>(workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-comment">// isBackwards</span>
              <span class="hljs-literal">null</span>, <span class="hljs-comment">// tail</span>
              <span class="hljs-literal">null</span>, <span class="hljs-comment">// last</span>
              <span class="hljs-literal">undefined</span>, workInProgress.<span class="hljs-property">lastEffect</span>);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-attr">default</span>:
          {</pre></div></div>
            
        </li>
        
        
        <li id="section-823">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-823">&#x00a7;</a>
              </div>
              <p>The default reveal order is the same as not having
a boundary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
          }
      }
    }

    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updatePortalComponent</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-title function_">pushHostContainer</span>(workInProgress, workInProgress.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>);
    <span class="hljs-keyword">var</span> nextChildren = workInProgress.<span class="hljs-property">pendingProps</span>;

    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-824">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-824">&#x00a7;</a>
              </div>
              <p>Portals are special because we don’t append the children during mount
but at commit. Therefore we need to track insertions which the normal
flow doesn’t do during mount. This doesn’t happen at the root because
the root always starts with a “current” with a null child.
TODO: Consider unifying this with how the root works.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">child</span> = <span class="hljs-title function_">reconcileChildFibers</span>(workInProgress, <span class="hljs-literal">null</span>, nextChildren, renderLanes);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, nextChildren, renderLanes);
    }

    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">var</span> hasWarnedAboutUsingNoValuePropOnContextProvider = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContextProvider</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> providerType = workInProgress.<span class="hljs-property">type</span>;
    <span class="hljs-keyword">var</span> context = providerType.<span class="hljs-property">_context</span>;
    <span class="hljs-keyword">var</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> oldProps = workInProgress.<span class="hljs-property">memoizedProps</span>;
    <span class="hljs-keyword">var</span> newValue = newProps.<span class="hljs-property">value</span>;

    {
      <span class="hljs-keyword">if</span> (!(<span class="hljs-string">&#x27;value&#x27;</span> <span class="hljs-keyword">in</span> newProps)) {
        <span class="hljs-keyword">if</span> (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
          hasWarnedAboutUsingNoValuePropOnContextProvider = <span class="hljs-literal">true</span>;

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;The `value` prop is required for the `&lt;Context.Provider&gt;`. Did you misspell it or forget to pass it?&#x27;</span>);
        }
      }

      <span class="hljs-keyword">var</span> providerPropTypes = workInProgress.<span class="hljs-property">type</span>.<span class="hljs-property">propTypes</span>;

      <span class="hljs-keyword">if</span> (providerPropTypes) {
        <span class="hljs-title function_">checkPropTypes</span>(providerPropTypes, newProps, <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-string">&#x27;Context.Provider&#x27;</span>);
      }
    }

    <span class="hljs-title function_">pushProvider</span>(workInProgress, newValue);

    <span class="hljs-keyword">if</span> (oldProps !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> oldValue = oldProps.<span class="hljs-property">value</span>;
      <span class="hljs-keyword">var</span> changedBits = <span class="hljs-title function_">calculateChangedBits</span>(context, newValue, oldValue);

      <span class="hljs-keyword">if</span> (changedBits === <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-825">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-825">&#x00a7;</a>
              </div>
              <p>No change. Bailout early if children are the same.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (oldProps.<span class="hljs-property">children</span> === newProps.<span class="hljs-property">children</span> &amp;&amp; !<span class="hljs-title function_">hasContextChanged</span>()) {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-826">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-826">&#x00a7;</a>
              </div>
              <p>The context value changed. Search for matching consumers and schedule
them to update.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">propagateContextChange</span>(workInProgress, context, changedBits, renderLanes);
      }
    }

    <span class="hljs-keyword">var</span> newChildren = newProps.<span class="hljs-property">children</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, newChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">var</span> hasWarnedAboutUsingContextAsConsumer = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContextConsumer</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> context = workInProgress.<span class="hljs-property">type</span>; <span class="hljs-comment">// The logic below for Context differs depending on PROD or DEV mode. In</span></pre></div></div>
            
        </li>
        
        
        <li id="section-827">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-827">&#x00a7;</a>
              </div>
              <p>DEV mode, we create a separate object for Context.Consumer that acts
like a proxy to Context. This proxy object adds unnecessary code in PROD
so we use the old behaviour (Context.Consumer references Context) to
reduce size and overhead. The separate object references context via
a property called “_context”, which also gives us the ability to check
in DEV mode if this property exists or not and warn if it does not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    {
      <span class="hljs-keyword">if</span> (context.<span class="hljs-property">_context</span> === <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-828">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-828">&#x00a7;</a>
              </div>
              <p>This may be because it’s a Context (rather than a Consumer).
Or it may be because it’s older React where they’re the same thing.
We only want to warn if we’re sure it’s a new React.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (context !== context.<span class="hljs-property">Consumer</span>) {
          <span class="hljs-keyword">if</span> (!hasWarnedAboutUsingContextAsConsumer) {
            hasWarnedAboutUsingContextAsConsumer = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Rendering &lt;Context&gt; directly is not supported and will be removed in &#x27;</span> + <span class="hljs-string">&#x27;a future major release. Did you mean to render &lt;Context.Consumer&gt; instead?&#x27;</span>);
          }
        }
      } <span class="hljs-keyword">else</span> {
        context = context.<span class="hljs-property">_context</span>;
      }
    }

    <span class="hljs-keyword">var</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;
    <span class="hljs-keyword">var</span> render = newProps.<span class="hljs-property">children</span>;

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> render !== <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;A context consumer was rendered with multiple children, or a child &#x27;</span> + <span class="hljs-string">&quot;that isn&#x27;t a function. A context consumer expects a single child &quot;</span> + <span class="hljs-string">&#x27;that is a function. If you did pass a function, make sure there &#x27;</span> + <span class="hljs-string">&#x27;is no trailing or leading whitespace around it.&#x27;</span>);
      }
    }

    <span class="hljs-title function_">prepareToReadContext</span>(workInProgress, renderLanes);
    <span class="hljs-keyword">var</span> newValue = <span class="hljs-title function_">readContext</span>(context, newProps.<span class="hljs-property">unstable_observedBits</span>);
    <span class="hljs-keyword">var</span> newChildren;

    {
      <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">1.</span>current = workInProgress;
      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">true</span>);
      newChildren = <span class="hljs-title function_">render</span>(newValue);
      <span class="hljs-title function_">setIsRendering</span>(<span class="hljs-literal">false</span>);
    } <span class="hljs-comment">// React DevTools reads this flag.</span>


    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PerformedWork</span>;
    <span class="hljs-title function_">reconcileChildren</span>(current, workInProgress, newChildren, renderLanes);
    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markWorkInProgressReceivedUpdate</span>(<span class="hljs-params"></span>) {
    didReceiveUpdate = <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-829">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-829">&#x00a7;</a>
              </div>
              <p>Reuse previous dependencies</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">dependencies</span> = current.<span class="hljs-property">dependencies</span>;
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-830">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-830">&#x00a7;</a>
              </div>
              <p>Don’t update “base” render times for bailouts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">stopProfilerTimerIfRunning</span>();
    }

    <span class="hljs-title function_">markSkippedUpdateLanes</span>(workInProgress.<span class="hljs-property">lanes</span>); <span class="hljs-comment">// Check if the children have any pending work.</span>

    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(renderLanes, workInProgress.<span class="hljs-property">childLanes</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-831">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-831">&#x00a7;</a>
              </div>
              <p>The children don’t have any work either. We can skip them.
TODO: Once we add back resuming, we should check if the children are
a work-in-progress set. If so, we need to transfer their effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-832">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-832">&#x00a7;</a>
              </div>
              <p>This fiber doesn’t have work, but its subtree does. Clone the child
fibers and continue.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">cloneChildFibers</span>(current, workInProgress);
      <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">remountFiber</span>(<span class="hljs-params">current, oldWorkInProgress, newWorkInProgress</span>) {
    {
      <span class="hljs-keyword">var</span> returnFiber = oldWorkInProgress.<span class="hljs-property">return</span>;

      <span class="hljs-keyword">if</span> (returnFiber === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Cannot swap the root fiber.&#x27;</span>);
      } <span class="hljs-comment">// Disconnect from the old current.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-833">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-833">&#x00a7;</a>
              </div>
              <p>It will get deleted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      current.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;
      oldWorkInProgress.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Connect to the new tree.</span>

      newWorkInProgress.<span class="hljs-property">index</span> = oldWorkInProgress.<span class="hljs-property">index</span>;
      newWorkInProgress.<span class="hljs-property">sibling</span> = oldWorkInProgress.<span class="hljs-property">sibling</span>;
      newWorkInProgress.<span class="hljs-property">return</span> = oldWorkInProgress.<span class="hljs-property">return</span>;
      newWorkInProgress.<span class="hljs-property">ref</span> = oldWorkInProgress.<span class="hljs-property">ref</span>; <span class="hljs-comment">// Replace the child/sibling pointers above it.</span>

      <span class="hljs-keyword">if</span> (oldWorkInProgress === returnFiber.<span class="hljs-property">child</span>) {
        returnFiber.<span class="hljs-property">child</span> = newWorkInProgress;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> prevSibling = returnFiber.<span class="hljs-property">child</span>;

        <span class="hljs-keyword">if</span> (prevSibling === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected parent to have a child.&#x27;</span>);
        }

        <span class="hljs-keyword">while</span> (prevSibling.<span class="hljs-property">sibling</span> !== oldWorkInProgress) {
          prevSibling = prevSibling.<span class="hljs-property">sibling</span>;

          <span class="hljs-keyword">if</span> (prevSibling === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected to find the previous sibling.&#x27;</span>);
          }
        }

        prevSibling.<span class="hljs-property">sibling</span> = newWorkInProgress;
      } <span class="hljs-comment">// Delete the old fiber and place the new one.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-834">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-834">&#x00a7;</a>
              </div>
              <p>Since the old fiber is disconnected, we have to schedule it manually.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> last = returnFiber.<span class="hljs-property">lastEffect</span>;

      <span class="hljs-keyword">if</span> (last !== <span class="hljs-literal">null</span>) {
        last.<span class="hljs-property">nextEffect</span> = current;
        returnFiber.<span class="hljs-property">lastEffect</span> = current;
      } <span class="hljs-keyword">else</span> {
        returnFiber.<span class="hljs-property">firstEffect</span> = returnFiber.<span class="hljs-property">lastEffect</span> = current;
      }

      current.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
      current.<span class="hljs-property">flags</span> = <span class="hljs-title class_">Deletion</span>;
      newWorkInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Placement</span>; <span class="hljs-comment">// Restart work from the new fiber.</span>

      <span class="hljs-keyword">return</span> newWorkInProgress;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">beginWork</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> updateLanes = workInProgress.<span class="hljs-property">lanes</span>;

    {
      <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">_debugNeedsRemount</span> &amp;&amp; current !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-835">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-835">&#x00a7;</a>
              </div>
              <p>This will restart the begin phase with a new fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">remountFiber</span>(current, workInProgress, <span class="hljs-title function_">createFiberFromTypeAndProps</span>(workInProgress.<span class="hljs-property">type</span>, workInProgress.<span class="hljs-property">key</span>, workInProgress.<span class="hljs-property">pendingProps</span>, workInProgress.<span class="hljs-property">_debugOwner</span> || <span class="hljs-literal">null</span>, workInProgress.<span class="hljs-property">mode</span>, workInProgress.<span class="hljs-property">lanes</span>));
      }
    }

    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;
      <span class="hljs-keyword">var</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;

      <span class="hljs-keyword">if</span> (oldProps !== newProps || <span class="hljs-title function_">hasContextChanged</span>() || ( <span class="hljs-comment">// Force a re-render if the implementation changed due to hot reload:</span>
        workInProgress.<span class="hljs-property">type</span> !== current.<span class="hljs-property">type</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-836">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-836">&#x00a7;</a>
              </div>
              <p>If props or context changed, mark the fiber as having performed work.
This may be unset if the props are determined to be equal later (memo).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        didReceiveUpdate = <span class="hljs-literal">true</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(renderLanes, updateLanes)) {
        didReceiveUpdate = <span class="hljs-literal">false</span>; <span class="hljs-comment">// This fiber does not have any pending work. Bailout without entering</span></pre></div></div>
            
        </li>
        
        
        <li id="section-837">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-837">&#x00a7;</a>
              </div>
              <p>the begin phase. There’s still some bookkeeping we that needs to be done
in this optimized path, mostly pushing stuff onto the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
            <span class="hljs-title function_">pushHostRootContext</span>(workInProgress);
            <span class="hljs-title function_">resetHydrationState</span>();
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
            <span class="hljs-title function_">pushHostContext</span>(workInProgress);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
            {
              <span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;

              <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
                <span class="hljs-title function_">pushContextProvider</span>(workInProgress);
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
            <span class="hljs-title function_">pushHostContainer</span>(workInProgress, workInProgress.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>);
            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>:
            {
              <span class="hljs-keyword">var</span> newValue = workInProgress.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">value</span>;
              <span class="hljs-title function_">pushProvider</span>(workInProgress, newValue);
              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
            {</pre></div></div>
            
        </li>
        
        
        <li id="section-838">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-838">&#x00a7;</a>
              </div>
              <p>Profiler should only call onRender when one of its descendants actually rendered.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> hasChildWork = <span class="hljs-title function_">includesSomeLane</span>(renderLanes, workInProgress.<span class="hljs-property">childLanes</span>);

              <span class="hljs-keyword">if</span> (hasChildWork) {
                workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
              } <span class="hljs-comment">// Reset effect durations for the next eventual effect phase.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-839">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-839">&#x00a7;</a>
              </div>
              <p>These are reset during render to allow the DevTools commit hook a chance to read them,</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

              <span class="hljs-keyword">var</span> stateNode = workInProgress.<span class="hljs-property">stateNode</span>;
              stateNode.<span class="hljs-property">effectDuration</span> = <span class="hljs-number">0</span>;
              stateNode.<span class="hljs-property">passiveEffectDuration</span> = <span class="hljs-number">0</span>;
            }

            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
            {
              <span class="hljs-keyword">var</span> state = workInProgress.<span class="hljs-property">memoizedState</span>;

              <span class="hljs-keyword">if</span> (state !== <span class="hljs-literal">null</span>) {
                {
                  <span class="hljs-keyword">if</span> (state.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {
                    <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>)); <span class="hljs-comment">// We know that this component will suspend again because if it has</span></pre></div></div>
            
        </li>
        
        
        <li id="section-840">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-840">&#x00a7;</a>
              </div>
              <p>been unsuspended it has committed as a resolved Suspense component.
If it needs to be retried, it should have work scheduled on it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>; <span class="hljs-comment">// We should never render the children of a dehydrated boundary until we</span></pre></div></div>
            
        </li>
        
        
        <li id="section-841">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-841">&#x00a7;</a>
              </div>
              <p>upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                  }
                } <span class="hljs-comment">// If this boundary is currently timed out, we need to decide</span></pre></div></div>
            
        </li>
        
        
        <li id="section-842">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-842">&#x00a7;</a>
              </div>
              <p>whether to retry the primary children, or to skip over it and
go straight to the fallback. Check the priority of the primary
child fragment.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

                <span class="hljs-keyword">var</span> primaryChildFragment = workInProgress.<span class="hljs-property">child</span>;
                <span class="hljs-keyword">var</span> primaryChildLanes = primaryChildFragment.<span class="hljs-property">childLanes</span>;

                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesSomeLane</span>(renderLanes, primaryChildLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-843">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-843">&#x00a7;</a>
              </div>
              <p>The primary children have pending work. Use the normal path
to attempt to render the primary children again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseComponent</span>(current, workInProgress, renderLanes);
                } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-844">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-844">&#x00a7;</a>
              </div>
              <p>The primary child fragment does not have pending work marked
on it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>)); <span class="hljs-comment">// The primary children do not have pending work with sufficient</span></pre></div></div>
            
        </li>
        
        
        <li id="section-845">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-845">&#x00a7;</a>
              </div>
              <p>priority. Bailout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                  <span class="hljs-keyword">var</span> child = <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);

                  <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-846">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-846">&#x00a7;</a>
              </div>
              <p>The fallback children have pending work. Skip over the
primary children and work on the fallback.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">return</span> child.<span class="hljs-property">sibling</span>;
                  } <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                  }
                }
              } <span class="hljs-keyword">else</span> {
                <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>));
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
            {
              <span class="hljs-keyword">var</span> didSuspendBefore = (current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoFlags</span>;

              <span class="hljs-keyword">var</span> _hasChildWork = <span class="hljs-title function_">includesSomeLane</span>(renderLanes, workInProgress.<span class="hljs-property">childLanes</span>);

              <span class="hljs-keyword">if</span> (didSuspendBefore) {
                <span class="hljs-keyword">if</span> (_hasChildWork) {</pre></div></div>
            
        </li>
        
        
        <li id="section-847">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-847">&#x00a7;</a>
              </div>
              <p>If something was in fallback state last time, and we have all the
same children then we’re still in progressive loading state.
Something might get unblocked by state updates or retries in the
tree which will affect the tail. So we need to use the normal
path to compute the correct tail.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseListComponent</span>(current, workInProgress, renderLanes);
                } <span class="hljs-comment">// If none of the children had any work, that means that none of</span></pre></div></div>
            
        </li>
        
        
        <li id="section-848">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-848">&#x00a7;</a>
              </div>
              <p>them got retried so they’ll still be blocked in the same way
as before. We can fast bail out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

                workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
              } <span class="hljs-comment">// If nothing suspended before and we&#x27;re rendering the same children,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-849">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-849">&#x00a7;</a>
              </div>
              <p>then the tail doesn’t matter. Anything new that suspends will work
in the “together” mode, so we can continue from the state we had.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

              <span class="hljs-keyword">var</span> renderState = workInProgress.<span class="hljs-property">memoizedState</span>;

              <span class="hljs-keyword">if</span> (renderState !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-850">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-850">&#x00a7;</a>
              </div>
              <p>Reset to the “together” mode in case we’ve started a different
update in the past but didn’t complete it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                renderState.<span class="hljs-property">rendering</span> = <span class="hljs-literal">null</span>;
                renderState.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;
                renderState.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
              }

              <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, suspenseStackCursor.<span class="hljs-property">current</span>);

              <span class="hljs-keyword">if</span> (_hasChildWork) {
                <span class="hljs-keyword">break</span>;
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-851">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-851">&#x00a7;</a>
              </div>
              <p>If none of the children had any work, that means that none of
them got retried so they’ll still be blocked in the same way
as before. We can fast bail out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
            }

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenComponent</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyHiddenComponent</span>:
            {</pre></div></div>
            
        </li>
        
        
        <li id="section-852">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-852">&#x00a7;</a>
              </div>
              <p>Need to check if the tree still needs to be deferred. This is
almost identical to the logic used in the normal update path,
so we’ll just enter that. The only difference is we’ll bail out
at the next level instead of this one, because the child props
have not changed. Which is fine.
TODO: Probably should refactor <code>beginWork</code> to split the bailout
path from the normal path. I’m tempted to do a labeled break here
but I won’t :)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;
              <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateOffscreenComponent</span>(current, workInProgress, renderLanes);
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> ((current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">ForceUpdateForLegacySuspense</span>) !== <span class="hljs-title class_">NoFlags</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-853">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-853">&#x00a7;</a>
              </div>
              <p>This is a special case that only exists for legacy mode.
See <a href="https://github.com/facebook/react/pull/19216">https://github.com/facebook/react/pull/19216</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          didReceiveUpdate = <span class="hljs-literal">true</span>;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-854">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-854">&#x00a7;</a>
              </div>
              <p>An update was scheduled on this fiber, but there are no new props
nor legacy context. Set this to false. If an update queue or context
consumer produces a changed value, it will set this to true. Otherwise,
the component will assume the children have not changed and bail out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          didReceiveUpdate = <span class="hljs-literal">false</span>;
        }
      }
    } <span class="hljs-keyword">else</span> {
      didReceiveUpdate = <span class="hljs-literal">false</span>;
    } <span class="hljs-comment">// Before entering the begin phase, clear pending update priority.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-855">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-855">&#x00a7;</a>
              </div>
              <p>TODO: This assumes that we’re about to evaluate the component and process
the update queue. However, there’s an exception: SimpleMemoComponent
sometimes bails out later in the begin phase. This indicates that we should
move this assignment out of the common path and into each branch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;

    <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>:
        {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountIndeterminateComponent</span>(current, workInProgress, workInProgress.<span class="hljs-property">type</span>, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LazyComponent</span>:
        {
          <span class="hljs-keyword">var</span> elementType = workInProgress.<span class="hljs-property">elementType</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountLazyComponent</span>(current, workInProgress, elementType, updateLanes, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
        {
          <span class="hljs-keyword">var</span> _Component = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">var</span> unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;
          <span class="hljs-keyword">var</span> resolvedProps = workInProgress.<span class="hljs-property">elementType</span> === _Component ? unresolvedProps : <span class="hljs-title function_">resolveDefaultProps</span>(_Component, unresolvedProps);
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFunctionComponent</span>(current, workInProgress, _Component, resolvedProps, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-keyword">var</span> _Component2 = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">var</span> _unresolvedProps = workInProgress.<span class="hljs-property">pendingProps</span>;

          <span class="hljs-keyword">var</span> _resolvedProps = workInProgress.<span class="hljs-property">elementType</span> === _Component2 ? _unresolvedProps : <span class="hljs-title function_">resolveDefaultProps</span>(_Component2, _unresolvedProps);

          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateClassComponent</span>(current, workInProgress, _Component2, _resolvedProps, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostRoot</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostComponent</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateHostText</span>(current, workInProgress);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseComponent</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updatePortalComponent</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
        {
          <span class="hljs-keyword">var</span> type = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">var</span> _unresolvedProps2 = workInProgress.<span class="hljs-property">pendingProps</span>;

          <span class="hljs-keyword">var</span> _resolvedProps2 = workInProgress.<span class="hljs-property">elementType</span> === type ? _unresolvedProps2 : <span class="hljs-title function_">resolveDefaultProps</span>(type, _unresolvedProps2);

          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateForwardRef</span>(current, workInProgress, type, _resolvedProps2, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Fragment</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateFragment</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Mode</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMode</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateProfiler</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateContextProvider</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextConsumer</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateContextConsumer</span>(current, workInProgress, renderLanes);

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:
        {
          <span class="hljs-keyword">var</span> _type2 = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">var</span> _unresolvedProps3 = workInProgress.<span class="hljs-property">pendingProps</span>; <span class="hljs-comment">// Resolve outer props first, then resolve inner props.</span>

          <span class="hljs-keyword">var</span> _resolvedProps3 = <span class="hljs-title function_">resolveDefaultProps</span>(_type2, _unresolvedProps3);

          {
            <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">type</span> !== workInProgress.<span class="hljs-property">elementType</span>) {
              <span class="hljs-keyword">var</span> outerPropTypes = _type2.<span class="hljs-property">propTypes</span>;

              <span class="hljs-keyword">if</span> (outerPropTypes) {
                <span class="hljs-title function_">checkPropTypes</span>(outerPropTypes, _resolvedProps3, <span class="hljs-comment">// Resolved for outer only</span>
                  <span class="hljs-string">&#x27;prop&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(_type2));
              }
            }
          }

          _resolvedProps3 = <span class="hljs-title function_">resolveDefaultProps</span>(_type2.<span class="hljs-property">type</span>, _resolvedProps3);
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateMemoComponent</span>(current, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
        {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSimpleMemoComponent</span>(current, workInProgress, workInProgress.<span class="hljs-property">type</span>, workInProgress.<span class="hljs-property">pendingProps</span>, updateLanes, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IncompleteClassComponent</span>:
        {
          <span class="hljs-keyword">var</span> _Component3 = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">var</span> _unresolvedProps4 = workInProgress.<span class="hljs-property">pendingProps</span>;

          <span class="hljs-keyword">var</span> _resolvedProps4 = workInProgress.<span class="hljs-property">elementType</span> === _Component3 ? _unresolvedProps4 : <span class="hljs-title function_">resolveDefaultProps</span>(_Component3, _unresolvedProps4);

          <span class="hljs-keyword">return</span> <span class="hljs-title function_">mountIncompleteClassComponent</span>(current, workInProgress, _Component3, _resolvedProps4, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
        {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateSuspenseListComponent</span>(current, workInProgress, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>:
        {

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>:
        {

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        {
          {
            <span class="hljs-keyword">var</span> block = workInProgress.<span class="hljs-property">type</span>;
            <span class="hljs-keyword">var</span> props = workInProgress.<span class="hljs-property">pendingProps</span>;
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateBlock</span>(current, workInProgress, block, props, renderLanes);
          }
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenComponent</span>:
        {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateOffscreenComponent</span>(current, workInProgress, renderLanes);
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyHiddenComponent</span>:
        {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">updateLegacyHiddenComponent</span>(current, workInProgress, renderLanes);
        }
    }

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unknown unit of work tag (&quot;</span> + workInProgress.<span class="hljs-property">tag</span> + <span class="hljs-string">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markUpdate</span>(<span class="hljs-params">workInProgress</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-856">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-856">&#x00a7;</a>
              </div>
              <p>Tag the fiber with an update effect. This turns a Placement into
a PlacementAndUpdate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRef$1</span>(<span class="hljs-params">workInProgress</span>) {
    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Ref</span>;
  }

  <span class="hljs-keyword">var</span> appendAllChildren;
  <span class="hljs-keyword">var</span> updateHostContainer;
  <span class="hljs-keyword">var</span> updateHostComponent$<span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> updateHostText$<span class="hljs-number">1</span>;

  {</pre></div></div>
            
        </li>
        
        
        <li id="section-857">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-857">&#x00a7;</a>
              </div>
              <p>Mutation mode</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    appendAllChildren = <span class="hljs-keyword">function</span> (<span class="hljs-params">parent, workInProgress, needsVisibilityToggle, isHidden</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-858">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-858">&#x00a7;</a>
              </div>
              <p>We only have the top Fiber that was created but we need recurse down its
children to find all the terminal nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> node = workInProgress.<span class="hljs-property">child</span>;

      <span class="hljs-keyword">while</span> (node !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span> || node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span>) {
          <span class="hljs-title function_">appendInitialChild</span>(parent, node.<span class="hljs-property">stateNode</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostPortal</span>); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {
          node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
          node = node.<span class="hljs-property">child</span>;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === workInProgress) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">return</span> === workInProgress) {
            <span class="hljs-keyword">return</span>;
          }

          node = node.<span class="hljs-property">return</span>;
        }

        node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
        node = node.<span class="hljs-property">sibling</span>;
      }
    };

    updateHostContainer = <span class="hljs-keyword">function</span> (<span class="hljs-params">workInProgress</span>) {<span class="hljs-comment">// Noop</span>
    };

    updateHostComponent$<span class="hljs-number">1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">current, workInProgress, type, newProps, rootContainerInstance</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-859">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-859">&#x00a7;</a>
              </div>
              <p>If we have an alternate, that means this is an update and we need to
schedule a side-effect to do the updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> oldProps = current.<span class="hljs-property">memoizedProps</span>;

      <span class="hljs-keyword">if</span> (oldProps === newProps) {</pre></div></div>
            
        </li>
        
        
        <li id="section-860">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-860">&#x00a7;</a>
              </div>
              <p>In mutation mode, this is sufficient for a bailout because
we won’t touch this node even if children changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// If we get updated because one of our children updated, we don&#x27;t</span></pre></div></div>
            
        </li>
        
        
        <li id="section-861">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-861">&#x00a7;</a>
              </div>
              <p>have newProps so we’ll have to reuse them.
TODO: Split the update API as separate for the props vs. children.
Even better would be if children weren’t special cased at all tho.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;
      <span class="hljs-keyword">var</span> currentHostContext = <span class="hljs-title function_">getHostContext</span>(); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Experiencing an error where oldProps is null. Suggests a host</span></pre></div></div>
            
        </li>
        
        
        <li id="section-862">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-862">&#x00a7;</a>
              </div>
              <p>component is hitting the resume path. Figure out why. Possibly
related to <code>hidden</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> updatePayload = <span class="hljs-title function_">prepareUpdate</span>(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Type this specific to this type of component.</span>

      workInProgress.<span class="hljs-property">updateQueue</span> = updatePayload; <span class="hljs-comment">// If the update payload indicates that there is a change or if there</span></pre></div></div>
            
        </li>
        
        
        <li id="section-863">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-863">&#x00a7;</a>
              </div>
              <p>is a new ref we mark this as an update. All the work is done in commitWork.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (updatePayload) {
        <span class="hljs-title function_">markUpdate</span>(workInProgress);
      }
    };

    updateHostText$<span class="hljs-number">1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">current, workInProgress, oldText, newText</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-864">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-864">&#x00a7;</a>
              </div>
              <p>If the text differs, mark it as an update. All the work in done in commitWork.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (oldText !== newText) {
        <span class="hljs-title function_">markUpdate</span>(workInProgress);
      }
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">cutOffTailIfNeeded</span>(<span class="hljs-params">renderState, hasRenderedATailFallback</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">getIsHydrating</span>()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-865">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-865">&#x00a7;</a>
              </div>
              <p>If we’re hydrating, we should consume as many items as we can
so we don’t leave any behind.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">switch</span> (renderState.<span class="hljs-property">tailMode</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hidden&#x27;</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-866">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-866">&#x00a7;</a>
              </div>
              <p>Any insertions at the end of the tail list after this point
should be invisible. If there are already mounted boundaries
anything before them are not considered for collapsing.
Therefore we need to go through the whole tail to find if
there are any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> tailNode = renderState.<span class="hljs-property">tail</span>;
          <span class="hljs-keyword">var</span> lastTailNode = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">while</span> (tailNode !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (tailNode.<span class="hljs-property">alternate</span> !== <span class="hljs-literal">null</span>) {
              lastTailNode = tailNode;
            }

            tailNode = tailNode.<span class="hljs-property">sibling</span>;
          } <span class="hljs-comment">// Next we&#x27;re simply going to delete all insertions after the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-867">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-867">&#x00a7;</a>
              </div>
              <p>last rendered item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          <span class="hljs-keyword">if</span> (lastTailNode === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-868">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-868">&#x00a7;</a>
              </div>
              <p>All remaining items in the tail are insertions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            renderState.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-869">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-869">&#x00a7;</a>
              </div>
              <p>Detach the insertion after the last node that was already
inserted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            lastTailNode.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;collapsed&#x27;</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-870">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-870">&#x00a7;</a>
              </div>
              <p>Any insertions at the end of the tail list after this point
should be invisible. If there are already mounted boundaries
anything before them are not considered for collapsing.
Therefore we need to go through the whole tail to find if
there are any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> _tailNode = renderState.<span class="hljs-property">tail</span>;
          <span class="hljs-keyword">var</span> _lastTailNode = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">while</span> (_tailNode !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (_tailNode.<span class="hljs-property">alternate</span> !== <span class="hljs-literal">null</span>) {
              _lastTailNode = _tailNode;
            }

            _tailNode = _tailNode.<span class="hljs-property">sibling</span>;
          } <span class="hljs-comment">// Next we&#x27;re simply going to delete all insertions after the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-871">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-871">&#x00a7;</a>
              </div>
              <p>last rendered item.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          <span class="hljs-keyword">if</span> (_lastTailNode === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-872">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-872">&#x00a7;</a>
              </div>
              <p>All remaining items in the tail are insertions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!hasRenderedATailFallback &amp;&amp; renderState.<span class="hljs-property">tail</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-873">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-873">&#x00a7;</a>
              </div>
              <p>We suspended during the head. We want to show at least one
row at the tail. So we’ll keep on and cut off the rest.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              renderState.<span class="hljs-property">tail</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
            } <span class="hljs-keyword">else</span> {
              renderState.<span class="hljs-property">tail</span> = <span class="hljs-literal">null</span>;
            }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-874">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-874">&#x00a7;</a>
              </div>
              <p>Detach the insertion after the last node that was already
inserted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            _lastTailNode.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">break</span>;
        }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">completeWork</span>(<span class="hljs-params">current, workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">var</span> newProps = workInProgress.<span class="hljs-property">pendingProps</span>;

    <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LazyComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Fragment</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Mode</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextConsumer</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
            <span class="hljs-title function_">popContext</span>(workInProgress);
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        {
          <span class="hljs-title function_">popHostContainer</span>(workInProgress);
          <span class="hljs-title function_">popTopLevelContextObject</span>(workInProgress);
          <span class="hljs-title function_">resetWorkInProgressVersions</span>();
          <span class="hljs-keyword">var</span> fiberRoot = workInProgress.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (fiberRoot.<span class="hljs-property">pendingContext</span>) {
            fiberRoot.<span class="hljs-property">context</span> = fiberRoot.<span class="hljs-property">pendingContext</span>;
            fiberRoot.<span class="hljs-property">pendingContext</span> = <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current.<span class="hljs-property">child</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-875">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-875">&#x00a7;</a>
              </div>
              <p>If we hydrated, pop so that we can delete any remaining children
that weren’t hydrated.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> wasHydrated = <span class="hljs-title function_">popHydrationState</span>(workInProgress);

            <span class="hljs-keyword">if</span> (wasHydrated) {</pre></div></div>
            
        </li>
        
        
        <li id="section-876">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-876">&#x00a7;</a>
              </div>
              <p>If we hydrated, then we’ll need to schedule an update for
the commit side-effects on the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-title function_">markUpdate</span>(workInProgress);
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!fiberRoot.<span class="hljs-property">hydrate</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-877">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-877">&#x00a7;</a>
              </div>
              <p>Schedule an effect to clear this container at the start of the next commit.
This handles the case of React rendering into a container with previous children.
It’s also safe to do for updates too, because current.child would only be null
if the previous render was null (so the the container would already be empty).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Snapshot</span>;
            }
          }

          <span class="hljs-title function_">updateHostContainer</span>(workInProgress);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        {
          <span class="hljs-title function_">popHostContext</span>(workInProgress);
          <span class="hljs-keyword">var</span> rootContainerInstance = <span class="hljs-title function_">getRootHostContainer</span>();
          <span class="hljs-keyword">var</span> type = workInProgress.<span class="hljs-property">type</span>;

          <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span> &amp;&amp; workInProgress.<span class="hljs-property">stateNode</span> != <span class="hljs-literal">null</span>) {
            <span class="hljs-title function_">updateHostComponent$1</span>(current, workInProgress, type, newProps, rootContainerInstance);

            <span class="hljs-keyword">if</span> (current.<span class="hljs-property">ref</span> !== workInProgress.<span class="hljs-property">ref</span>) {
              <span class="hljs-title function_">markRef$1</span>(workInProgress);
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (!newProps) {
              <span class="hljs-keyword">if</span> (!(workInProgress.<span class="hljs-property">stateNode</span> !== <span class="hljs-literal">null</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
                }
              } <span class="hljs-comment">// This can happen when we abort work.</span>


              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
            }

            <span class="hljs-keyword">var</span> currentHostContext = <span class="hljs-title function_">getHostContext</span>(); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move createInstance to beginWork and keep it on a context</span></pre></div></div>
            
        </li>
        
        
        <li id="section-878">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-878">&#x00a7;</a>
              </div>
              <p>“stack” as the parent. Then append children as we go in beginWork
or completeWork depending on whether we want to add them top-&gt;down or
bottom-&gt;up. Top-&gt;down is faster in IE11.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> _wasHydrated = <span class="hljs-title function_">popHydrationState</span>(workInProgress);

            <span class="hljs-keyword">if</span> (_wasHydrated) {</pre></div></div>
            
        </li>
        
        
        <li id="section-879">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-879">&#x00a7;</a>
              </div>
              <p>TODO: Move this and createInstance step into the beginPhase
to consolidate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">if</span> (<span class="hljs-title function_">prepareToHydrateHostInstance</span>(workInProgress, rootContainerInstance, currentHostContext)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-880">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-880">&#x00a7;</a>
              </div>
              <p>If changes to the hydrated node need to be applied at the
commit-phase we mark this as such.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-title function_">markUpdate</span>(workInProgress);
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> instance = <span class="hljs-title function_">createInstance</span>(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
              <span class="hljs-title function_">appendAllChildren</span>(instance, workInProgress, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
              workInProgress.<span class="hljs-property">stateNode</span> = instance; <span class="hljs-comment">// Certain renderers require commit-time effects for initial mount.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-881">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-881">&#x00a7;</a>
              </div>
              <p>(eg DOM renderer supports auto-focus for certain elements).
Make sure such renderers get scheduled for later work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              <span class="hljs-keyword">if</span> (<span class="hljs-title function_">finalizeInitialChildren</span>(instance, type, newProps, rootContainerInstance)) {
                <span class="hljs-title function_">markUpdate</span>(workInProgress);
              }
            }

            <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">ref</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-882">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-882">&#x00a7;</a>
              </div>
              <p>If there is a ref on a host node we need to schedule a callback</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-title function_">markRef$1</span>(workInProgress);
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
        {
          <span class="hljs-keyword">var</span> newText = newProps;

          <span class="hljs-keyword">if</span> (current &amp;&amp; workInProgress.<span class="hljs-property">stateNode</span> != <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> oldText = current.<span class="hljs-property">memoizedProps</span>; <span class="hljs-comment">// If we have an alternate, that means this is an update and we need</span></pre></div></div>
            
        </li>
        
        
        <li id="section-883">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-883">&#x00a7;</a>
              </div>
              <p>to schedule a side-effect to do the updates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-title function_">updateHostText$1</span>(current, workInProgress, oldText, newText);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newText !== <span class="hljs-string">&#x27;string&#x27;</span>) {
              <span class="hljs-keyword">if</span> (!(workInProgress.<span class="hljs-property">stateNode</span> !== <span class="hljs-literal">null</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
                }
              } <span class="hljs-comment">// This can happen when we abort work.</span>

            }

            <span class="hljs-keyword">var</span> _rootContainerInstance = <span class="hljs-title function_">getRootHostContainer</span>();

            <span class="hljs-keyword">var</span> _currentHostContext = <span class="hljs-title function_">getHostContext</span>();

            <span class="hljs-keyword">var</span> _wasHydrated2 = <span class="hljs-title function_">popHydrationState</span>(workInProgress);

            <span class="hljs-keyword">if</span> (_wasHydrated2) {
              <span class="hljs-keyword">if</span> (<span class="hljs-title function_">prepareToHydrateHostTextInstance</span>(workInProgress)) {
                <span class="hljs-title function_">markUpdate</span>(workInProgress);
              }
            } <span class="hljs-keyword">else</span> {
              workInProgress.<span class="hljs-property">stateNode</span> = <span class="hljs-title function_">createTextInstance</span>(newText, _rootContainerInstance, _currentHostContext, workInProgress);
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        {
          <span class="hljs-title function_">popSuspenseContext</span>(workInProgress);
          <span class="hljs-keyword">var</span> nextState = workInProgress.<span class="hljs-property">memoizedState</span>;

          {
            <span class="hljs-keyword">if</span> (nextState !== <span class="hljs-literal">null</span> &amp;&amp; nextState.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">var</span> _wasHydrated3 = <span class="hljs-title function_">popHydrationState</span>(workInProgress);

                <span class="hljs-keyword">if</span> (!_wasHydrated3) {
                  {
                    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.&quot;</span>);
                  }
                }

                <span class="hljs-title function_">prepareToHydrateHostSuspenseInstance</span>(workInProgress);

                {
                  <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">OffscreenLane</span>);
                }

                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-884">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-884">&#x00a7;</a>
              </div>
              <p>We should never have been in a hydration state if we didn’t have a current.
However, in some of those paths, we might have reentered a hydration state
and then we might be inside a hydration state. In that case, we’ll need to exit out of it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-title function_">resetHydrationState</span>();

                <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoFlags</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-885">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-885">&#x00a7;</a>
              </div>
              <p>This boundary did not suspend so it’s now hydrated and unsuspended.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
                } <span class="hljs-comment">// If nothing suspended, we need to schedule an effect to mark this boundary</span></pre></div></div>
            
        </li>
        
        
        <li id="section-886">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-886">&#x00a7;</a>
              </div>
              <p>as having hydrated so events know that they’re free to be invoked.
It’s also a signal to replay events and the suspense callback.
If something suspended, schedule an effect to attach retry listeners.
So we might as well always mark this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

                workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
              }
            }
          }

          <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoFlags</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-887">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-887">&#x00a7;</a>
              </div>
              <p>Something suspended. Re-render with the fallback children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            workInProgress.<span class="hljs-property">lanes</span> = renderLanes; <span class="hljs-comment">// Do not reset the effect list.</span>

            <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) {
              <span class="hljs-title function_">transferActualDuration</span>(workInProgress);
            }

            <span class="hljs-keyword">return</span> workInProgress;
          }

          <span class="hljs-keyword">var</span> nextDidTimeout = nextState !== <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">var</span> prevDidTimeout = <span class="hljs-literal">false</span>;

          <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (workInProgress.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">fallback</span> !== <span class="hljs-literal">undefined</span>) {
              <span class="hljs-title function_">popHydrationState</span>(workInProgress);
            }
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">var</span> prevState = current.<span class="hljs-property">memoizedState</span>;
            prevDidTimeout = prevState !== <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">if</span> (nextDidTimeout &amp;&amp; !prevDidTimeout) {</pre></div></div>
            
        </li>
        
        
        <li id="section-888">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-888">&#x00a7;</a>
              </div>
              <p>If this subtreee is running in blocking mode we can suspend,
otherwise we won’t suspend.
TODO: This will still suspend a synchronous tree if anything
in the concurrent tree already suspended during this render.
This is a known bug.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) !== <span class="hljs-title class_">NoMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-889">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-889">&#x00a7;</a>
              </div>
              <p>TODO: Move this back to throwException because this is too late
if this is a large tree which is common for initial loads. We
don’t know if we should restart a render or not until we get
this marker, and this is too late.
If this render already had a ping or lower pri updates,
and this is the first time we know we’re going to suspend we
should be able to immediately restart from within throwException.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> hasInvisibleChildContext = current === <span class="hljs-literal">null</span> &amp;&amp; workInProgress.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">unstable_avoidThisFallback</span> !== <span class="hljs-literal">true</span>;

              <span class="hljs-keyword">if</span> (hasInvisibleChildContext || <span class="hljs-title function_">hasSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>, <span class="hljs-title class_">InvisibleParentSuspenseContext</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-890">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-890">&#x00a7;</a>
              </div>
              <p>If this was in an invisible tree or a new render, then showing
this boundary is ok.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-title function_">renderDidSuspend</span>();
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-891">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-891">&#x00a7;</a>
              </div>
              <p>Otherwise, we’re going to have to hide content so we should
suspend for longer if possible.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-title function_">renderDidSuspendDelayIfPossible</span>();
              }
            }
          }

          {</pre></div></div>
            
        </li>
        
        
        <li id="section-892">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-892">&#x00a7;</a>
              </div>
              <p>TODO: Only schedule updates if these values are non equal, i.e. it changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (nextDidTimeout || prevDidTimeout) {</pre></div></div>
            
        </li>
        
        
        <li id="section-893">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-893">&#x00a7;</a>
              </div>
              <p>If this boundary just timed out, schedule an effect to attach a
retry listener to the promise. This flag is also used to hide the
primary children. In mutation mode, we also need the flag to
<em>unhide</em> children that were previously hidden, so check if this
is currently timed out, too.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
        <span class="hljs-title function_">popHostContainer</span>(workInProgress);
        <span class="hljs-title function_">updateHostContainer</span>(workInProgress);

        <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">preparePortalMount</span>(workInProgress.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-894">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-894">&#x00a7;</a>
              </div>
              <p>Pop provider fiber</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">popProvider</span>(workInProgress);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IncompleteClassComponent</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-895">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-895">&#x00a7;</a>
              </div>
              <p>Same as class component case. I put it down here so that the tags are
sequential to ensure this switch is compiled to a jump table.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> _Component = workInProgress.<span class="hljs-property">type</span>;

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(_Component)) {
            <span class="hljs-title function_">popContext</span>(workInProgress);
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
        {
          <span class="hljs-title function_">popSuspenseContext</span>(workInProgress);
          <span class="hljs-keyword">var</span> renderState = workInProgress.<span class="hljs-property">memoizedState</span>;

          <span class="hljs-keyword">if</span> (renderState === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-896">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-896">&#x00a7;</a>
              </div>
              <p>We’re running in the default, “independent” mode.
We don’t do anything in this mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          }

          <span class="hljs-keyword">var</span> didSuspendAlready = (workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) !== <span class="hljs-title class_">NoFlags</span>;
          <span class="hljs-keyword">var</span> renderedTail = renderState.<span class="hljs-property">rendering</span>;

          <span class="hljs-keyword">if</span> (renderedTail === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-897">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-897">&#x00a7;</a>
              </div>
              <p>We just rendered the head.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!didSuspendAlready) {</pre></div></div>
            
        </li>
        
        
        <li id="section-898">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-898">&#x00a7;</a>
              </div>
              <p>This is the first pass. We need to figure out if anything is still
suspended in the rendered set.
If new content unsuspended, but there’s still some content that
didn’t. Then we need to do a second pass that forces everything
to keep showing their fallbacks.
We might be suspended if something in this render pass suspended, or
something in the previous committed pass suspended. Otherwise,
there’s no chance so we can skip the expensive call to
findFirstSuspended.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="hljs-keyword">var</span> cannotBeSuspended = <span class="hljs-title function_">renderHasNotSuspendedYet</span>() &amp;&amp; (current === <span class="hljs-literal">null</span> || (current.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoFlags</span>);

              <span class="hljs-keyword">if</span> (!cannotBeSuspended) {
                <span class="hljs-keyword">var</span> row = workInProgress.<span class="hljs-property">child</span>;

                <span class="hljs-keyword">while</span> (row !== <span class="hljs-literal">null</span>) {
                  <span class="hljs-keyword">var</span> suspended = <span class="hljs-title function_">findFirstSuspended</span>(row);

                  <span class="hljs-keyword">if</span> (suspended !== <span class="hljs-literal">null</span>) {
                    didSuspendAlready = <span class="hljs-literal">true</span>;
                    workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
                    <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">false</span>); <span class="hljs-comment">// If this is a newly suspended tree, it might not get committed as</span></pre></div></div>
            
        </li>
        
        
        <li id="section-899">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-899">&#x00a7;</a>
              </div>
              <p>part of the second pass. In that case nothing will subscribe to
its thennables. Instead, we’ll transfer its thennables to the
SuspenseList so that it can retry if they resolve.
There might be multiple of these in the list but since we’re
going to wait for all of them anyway, it doesn’t really matter
which ones gets to ping. In theory we could get clever and keep
track of how many dependencies remain but it gets tricky because
in the meantime, we can add/remove/change items and dependencies.
We might bail out of the loop before finding any but that
doesn’t matter since that means that the other boundaries that
we did find already has their listeners attached.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                    <span class="hljs-keyword">var</span> newThennables = suspended.<span class="hljs-property">updateQueue</span>;

                    <span class="hljs-keyword">if</span> (newThennables !== <span class="hljs-literal">null</span>) {
                      workInProgress.<span class="hljs-property">updateQueue</span> = newThennables;
                      workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
                    } <span class="hljs-comment">// Rerender the whole list, but this time, we&#x27;ll force fallbacks</span></pre></div></div>
            
        </li>
        
        
        <li id="section-900">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-900">&#x00a7;</a>
              </div>
              <p>to stay in place.
Reset the effect list before doing the second pass since that’s now invalid.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

                    <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">lastEffect</span> === <span class="hljs-literal">null</span>) {
                      workInProgress.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
                    }

                    workInProgress.<span class="hljs-property">lastEffect</span> = renderState.<span class="hljs-property">lastEffect</span>; <span class="hljs-comment">// Reset the child fibers to their original state.</span>

                    <span class="hljs-title function_">resetChildFibers</span>(workInProgress, renderLanes); <span class="hljs-comment">// Set up the Suspense Context to force suspense and immediately</span></pre></div></div>
            
        </li>
        
        
        <li id="section-901">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-901">&#x00a7;</a>
              </div>
              <p>rerender the children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                    <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, <span class="hljs-title function_">setShallowSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>, <span class="hljs-title class_">ForceSuspenseFallback</span>));
                    <span class="hljs-keyword">return</span> workInProgress.<span class="hljs-property">child</span>;
                  }

                  row = row.<span class="hljs-property">sibling</span>;
                }
              }

              <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">tail</span> !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">now</span>() &gt; <span class="hljs-title function_">getRenderTargetTime</span>()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-902">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-902">&#x00a7;</a>
              </div>
              <p>We have already passed our CPU deadline but we still have rows
left in the tail. We’ll just give up further attempts to render
the main content and only render fallbacks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
                didSuspendAlready = <span class="hljs-literal">true</span>;
                <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Since nothing actually suspended, there will nothing to ping this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-903">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-903">&#x00a7;</a>
              </div>
              <p>to get it started back up to attempt the next item. While in terms
of priority this work has the same priority as this current render,
it’s not part of the same transition once the transition has
committed. If it’s sync, we still want to yield so that it can be
painted. Conceptually, this is really the same as pinging.
We can use any RetryLane even if it’s the one currently rendering
since we’re leaving it behind on this node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">SomeRetryLane</span>;

                {
                  <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">SomeRetryLane</span>);
                }
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">false</span>);
            } <span class="hljs-comment">// Next we&#x27;re going to render the tail.</span>

          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-904">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-904">&#x00a7;</a>
              </div>
              <p>Append the rendered row to the child list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!didSuspendAlready) {
              <span class="hljs-keyword">var</span> _suspended = <span class="hljs-title function_">findFirstSuspended</span>(renderedTail);

              <span class="hljs-keyword">if</span> (_suspended !== <span class="hljs-literal">null</span>) {
                workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
                didSuspendAlready = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Ensure we transfer the update queue to the parent so that it doesn&#x27;t</span></pre></div></div>
            
        </li>
        
        
        <li id="section-905">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-905">&#x00a7;</a>
              </div>
              <p>get lost if this row ends up dropped during a second pass.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                <span class="hljs-keyword">var</span> _newThennables = _suspended.<span class="hljs-property">updateQueue</span>;

                <span class="hljs-keyword">if</span> (_newThennables !== <span class="hljs-literal">null</span>) {
                  workInProgress.<span class="hljs-property">updateQueue</span> = _newThennables;
                  workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
                }

                <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">true</span>); <span class="hljs-comment">// This might have been modified.</span>

                <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">tail</span> === <span class="hljs-literal">null</span> &amp;&amp; renderState.<span class="hljs-property">tailMode</span> === <span class="hljs-string">&#x27;hidden&#x27;</span> &amp;&amp; !renderedTail.<span class="hljs-property">alternate</span> &amp;&amp; !<span class="hljs-title function_">getIsHydrating</span>() <span class="hljs-comment">// We don&#x27;t cut it if we&#x27;re hydrating.</span>
                ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-906">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-906">&#x00a7;</a>
              </div>
              <p>We need to delete the row we just rendered.
Reset the effect list to what it was before we rendered this
child. The nested children have already appended themselves.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  <span class="hljs-keyword">var</span> lastEffect = workInProgress.<span class="hljs-property">lastEffect</span> = renderState.<span class="hljs-property">lastEffect</span>; <span class="hljs-comment">// Remove any effects that were appended after this point.</span>

                  <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
                    lastEffect.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
                  } <span class="hljs-comment">// We&#x27;re done.</span>


                  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                }
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// The time it took to render last row is greater than the remaining</span></pre></div></div>
            
        </li>
        
        
        <li id="section-907">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-907">&#x00a7;</a>
              </div>
              <p>time we have to render. So rendering one more row would likely
exceed it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-title function_">now</span>() * <span class="hljs-number">2</span> - renderState.<span class="hljs-property">renderingStartTime</span> &gt; <span class="hljs-title function_">getRenderTargetTime</span>() &amp;&amp; renderLanes !== <span class="hljs-title class_">OffscreenLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-908">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-908">&#x00a7;</a>
              </div>
              <p>We have now passed our CPU deadline and we’ll just give up further
attempts to render the main content and only render fallbacks.
The assumption is that this is usually faster.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
                didSuspendAlready = <span class="hljs-literal">true</span>;
                <span class="hljs-title function_">cutOffTailIfNeeded</span>(renderState, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Since nothing actually suspended, there will nothing to ping this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-909">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-909">&#x00a7;</a>
              </div>
              <p>to get it started back up to attempt the next item. While in terms
of priority this work has the same priority as this current render,
it’s not part of the same transition once the transition has
committed. If it’s sync, we still want to yield so that it can be
painted. Conceptually, this is really the same as pinging.
We can use any RetryLane even if it’s the one currently rendering
since we’re leaving it behind on this node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
                workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">SomeRetryLane</span>;

                {
                  <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-title class_">SomeRetryLane</span>);
                }
              }
            }

            <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">isBackwards</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-910">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-910">&#x00a7;</a>
              </div>
              <p>The effect list of the backwards tail will have been added
to the end. This breaks the guarantee that life-cycles fire in
sibling order but that isn’t a strong guarantee promised by React.
Especially since these might also just pop in during future commits.
Append to the beginning of the list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              renderedTail.<span class="hljs-property">sibling</span> = workInProgress.<span class="hljs-property">child</span>;
              workInProgress.<span class="hljs-property">child</span> = renderedTail;
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> previousSibling = renderState.<span class="hljs-property">last</span>;

              <span class="hljs-keyword">if</span> (previousSibling !== <span class="hljs-literal">null</span>) {
                previousSibling.<span class="hljs-property">sibling</span> = renderedTail;
              } <span class="hljs-keyword">else</span> {
                workInProgress.<span class="hljs-property">child</span> = renderedTail;
              }

              renderState.<span class="hljs-property">last</span> = renderedTail;
            }
          }

          <span class="hljs-keyword">if</span> (renderState.<span class="hljs-property">tail</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-911">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-911">&#x00a7;</a>
              </div>
              <p>We still have tail rows to render.
Pop a row.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> next = renderState.<span class="hljs-property">tail</span>;
            renderState.<span class="hljs-property">rendering</span> = next;
            renderState.<span class="hljs-property">tail</span> = next.<span class="hljs-property">sibling</span>;
            renderState.<span class="hljs-property">lastEffect</span> = workInProgress.<span class="hljs-property">lastEffect</span>;
            renderState.<span class="hljs-property">renderingStartTime</span> = <span class="hljs-title function_">now</span>();
            next.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Restore the context.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-912">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-912">&#x00a7;</a>
              </div>
              <p>TODO: We can probably just avoid popping it instead and only
setting it the first time we go from not suspended to suspended.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> suspenseContext = suspenseStackCursor.<span class="hljs-property">current</span>;

            <span class="hljs-keyword">if</span> (didSuspendAlready) {
              suspenseContext = <span class="hljs-title function_">setShallowSuspenseContext</span>(suspenseContext, <span class="hljs-title class_">ForceSuspenseFallback</span>);
            } <span class="hljs-keyword">else</span> {
              suspenseContext = <span class="hljs-title function_">setDefaultShallowSuspenseContext</span>(suspenseContext);
            }

            <span class="hljs-title function_">pushSuspenseContext</span>(workInProgress, suspenseContext); <span class="hljs-comment">// Do a pass over the next row.</span>

            <span class="hljs-keyword">return</span> next;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>:
        {

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>:
        {

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyHiddenComponent</span>:
        {
          <span class="hljs-title function_">popRenderLanes</span>(workInProgress);

          <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> _nextState = workInProgress.<span class="hljs-property">memoizedState</span>;
            <span class="hljs-keyword">var</span> _prevState = current.<span class="hljs-property">memoizedState</span>;
            <span class="hljs-keyword">var</span> prevIsHidden = _prevState !== <span class="hljs-literal">null</span>;
            <span class="hljs-keyword">var</span> nextIsHidden = _nextState !== <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">if</span> (prevIsHidden !== nextIsHidden &amp;&amp; newProps.<span class="hljs-property">mode</span> !== <span class="hljs-string">&#x27;unstable-defer-without-hiding&#x27;</span>) {
              workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Update</span>;
            }
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unknown unit of work tag (&quot;</span> + workInProgress.<span class="hljs-property">tag</span> + <span class="hljs-string">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unwindWork</span>(<span class="hljs-params">workInProgress, renderLanes</span>) {
    <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = workInProgress.<span class="hljs-property">type</span>;

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
            <span class="hljs-title function_">popContext</span>(workInProgress);
          }

          <span class="hljs-keyword">var</span> flags = workInProgress.<span class="hljs-property">flags</span>;

          <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">ShouldCapture</span>) {
            workInProgress.<span class="hljs-property">flags</span> = flags &amp; ~<span class="hljs-title class_">ShouldCapture</span> | <span class="hljs-title class_">DidCapture</span>;

            <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) {
              <span class="hljs-title function_">transferActualDuration</span>(workInProgress);
            }

            <span class="hljs-keyword">return</span> workInProgress;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        {
          <span class="hljs-title function_">popHostContainer</span>(workInProgress);
          <span class="hljs-title function_">popTopLevelContextObject</span>(workInProgress);
          <span class="hljs-title function_">resetWorkInProgressVersions</span>();
          <span class="hljs-keyword">var</span> _flags = workInProgress.<span class="hljs-property">flags</span>;

          <span class="hljs-keyword">if</span> (!((_flags &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoFlags</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;The root failed to unmount after an error. This is likely a bug in React. Please file an issue.&quot;</span>);
            }
          }

          workInProgress.<span class="hljs-property">flags</span> = _flags &amp; ~<span class="hljs-title class_">ShouldCapture</span> | <span class="hljs-title class_">DidCapture</span>;
          <span class="hljs-keyword">return</span> workInProgress;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-913">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-913">&#x00a7;</a>
              </div>
              <p>TODO: popHydrationState</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">popHostContext</span>(workInProgress);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        {
          <span class="hljs-title function_">popSuspenseContext</span>(workInProgress);

          {
            <span class="hljs-keyword">var</span> suspenseState = workInProgress.<span class="hljs-property">memoizedState</span>;

            <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span> &amp;&amp; suspenseState.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">if</span> (!(workInProgress.<span class="hljs-property">alternate</span> !== <span class="hljs-literal">null</span>)) {
                {
                  <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.&quot;</span>);
                }
              }

              <span class="hljs-title function_">resetHydrationState</span>();
            }
          }

          <span class="hljs-keyword">var</span> _flags2 = workInProgress.<span class="hljs-property">flags</span>;

          <span class="hljs-keyword">if</span> (_flags2 &amp; <span class="hljs-title class_">ShouldCapture</span>) {
            workInProgress.<span class="hljs-property">flags</span> = _flags2 &amp; ~<span class="hljs-title class_">ShouldCapture</span> | <span class="hljs-title class_">DidCapture</span>; <span class="hljs-comment">// Captured a suspense effect. Re-render the boundary.</span>

            <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) {
              <span class="hljs-title function_">transferActualDuration</span>(workInProgress);
            }

            <span class="hljs-keyword">return</span> workInProgress;
          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
        {
          <span class="hljs-title function_">popSuspenseContext</span>(workInProgress); <span class="hljs-comment">// SuspenseList doesn&#x27;t actually catch anything. It should&#x27;ve been</span></pre></div></div>
            
        </li>
        
        
        <li id="section-914">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-914">&#x00a7;</a>
              </div>
              <p>caught by a nested boundary. If not, it should bubble through.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
        <span class="hljs-title function_">popHostContainer</span>(workInProgress);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>:
        <span class="hljs-title function_">popProvider</span>(workInProgress);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyHiddenComponent</span>:
        <span class="hljs-title function_">popRenderLanes</span>(workInProgress);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unwindInterruptedWork</span>(<span class="hljs-params">interruptedWork</span>) {
    <span class="hljs-keyword">switch</span> (interruptedWork.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-keyword">var</span> childContextTypes = interruptedWork.<span class="hljs-property">type</span>.<span class="hljs-property">childContextTypes</span>;

          <span class="hljs-keyword">if</span> (childContextTypes !== <span class="hljs-literal">null</span> &amp;&amp; childContextTypes !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-title function_">popContext</span>(interruptedWork);
          }

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        {
          <span class="hljs-title function_">popHostContainer</span>(interruptedWork);
          <span class="hljs-title function_">popTopLevelContextObject</span>(interruptedWork);
          <span class="hljs-title function_">resetWorkInProgressVersions</span>();
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        {
          <span class="hljs-title function_">popHostContext</span>(interruptedWork);
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
        <span class="hljs-title function_">popHostContainer</span>(interruptedWork);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        <span class="hljs-title function_">popSuspenseContext</span>(interruptedWork);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
        <span class="hljs-title function_">popSuspenseContext</span>(interruptedWork);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ContextProvider</span>:
        <span class="hljs-title function_">popProvider</span>(interruptedWork);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyHiddenComponent</span>:
        <span class="hljs-title function_">popRenderLanes</span>(interruptedWork);
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createCapturedValue</span>(<span class="hljs-params">value, source</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-915">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-915">&#x00a7;</a>
              </div>
              <p>If the value is an error, call this function immediately after it is thrown
so the stack is accurate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">value</span>: value,
      <span class="hljs-attr">source</span>: source,
      <span class="hljs-attr">stack</span>: <span class="hljs-title function_">getStackByFiberInDevAndProd</span>(source)
    };
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-916">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-916">&#x00a7;</a>
              </div>
              <p>This module is forked in different environments.
By default, return <code>true</code> to log errors to the console.
Forks can return <code>false</code> if this isn’t desirable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">showErrorDialog</span>(<span class="hljs-params">boundary, errorInfo</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">logCapturedError</span>(<span class="hljs-params">boundary, errorInfo</span>) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> logError = <span class="hljs-title function_">showErrorDialog</span>(boundary, errorInfo); <span class="hljs-comment">// Allow injected showErrorDialog() to prevent default console.error logging.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-917">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-917">&#x00a7;</a>
              </div>
              <p>This enables renderers like ReactNative to better manage redbox behavior.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (logError === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> error = errorInfo.<span class="hljs-property">value</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> source = errorInfo.<span class="hljs-property">source</span>;
        <span class="hljs-keyword">var</span> stack = errorInfo.<span class="hljs-property">stack</span>;
        <span class="hljs-keyword">var</span> componentStack = stack !== <span class="hljs-literal">null</span> ? stack : <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">// Browsers support silencing uncaught errors by calling</span></pre></div></div>
            
        </li>
        
        
        <li id="section-918">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-918">&#x00a7;</a>
              </div>
              <p><code>preventDefault()</code> in window <code>error</code> handler.
We record this information as an expando on the error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (error != <span class="hljs-literal">null</span> &amp;&amp; error.<span class="hljs-property">_suppressLogging</span>) {
          <span class="hljs-keyword">if</span> (boundary.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-919">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-919">&#x00a7;</a>
              </div>
              <p>The error is recoverable and was silenced.
Ignore it and don’t print the stack addendum.
This is handy for testing error boundaries without noise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span>;
          } <span class="hljs-comment">// The error is fatal. Since the silencing might have</span></pre></div></div>
            
        </li>
        
        
        <li id="section-920">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-920">&#x00a7;</a>
              </div>
              <p>been accidental, we’ll surface it anyway.
However, the browser would have silenced the original error
so we’ll print it first, and then print the stack addendum.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          <span class="hljs-variable language_">console</span>[<span class="hljs-string">&#x27;error&#x27;</span>](error); <span class="hljs-comment">// Don&#x27;t transform to our wrapper</span></pre></div></div>
            
        </li>
        
        
        <li id="section-921">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-921">&#x00a7;</a>
              </div>
              <p>For a more detailed description of this block, see:
<a href="https://github.com/facebook/react/pull/13384">https://github.com/facebook/react/pull/13384</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        }

        <span class="hljs-keyword">var</span> componentName = source ? <span class="hljs-title function_">getComponentName</span>(source.<span class="hljs-property">type</span>) : <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">var</span> componentNameMessage = componentName ? <span class="hljs-string">&quot;The above error occurred in the &lt;&quot;</span> + componentName + <span class="hljs-string">&quot;&gt; component:&quot;</span> : <span class="hljs-string">&#x27;The above error occurred in one of your React components:&#x27;</span>;
        <span class="hljs-keyword">var</span> errorBoundaryMessage;
        <span class="hljs-keyword">var</span> errorBoundaryName = <span class="hljs-title function_">getComponentName</span>(boundary.<span class="hljs-property">type</span>);

        <span class="hljs-keyword">if</span> (errorBoundaryName) {
          errorBoundaryMessage = <span class="hljs-string">&quot;React will try to recreate this component tree from scratch &quot;</span> + (<span class="hljs-string">&quot;using the error boundary you provided, &quot;</span> + errorBoundaryName + <span class="hljs-string">&quot;.&quot;</span>);
        } <span class="hljs-keyword">else</span> {
          errorBoundaryMessage = <span class="hljs-string">&#x27;Consider adding an error boundary to your tree to customize error handling behavior.\n&#x27;</span> + <span class="hljs-string">&#x27;Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.&#x27;</span>;
        }

        <span class="hljs-keyword">var</span> combinedMessage = componentNameMessage + <span class="hljs-string">&quot;\n&quot;</span> + componentStack + <span class="hljs-string">&quot;\n\n&quot;</span> + (<span class="hljs-string">&quot;&quot;</span> + errorBoundaryMessage); <span class="hljs-comment">// In development, we provide our own message with just the component stack.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-922">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-922">&#x00a7;</a>
              </div>
              <p>We don’t include the original error message and JS stack because the browser
has already printed it. Even if the application swallows the error, it is still
displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-variable language_">console</span>[<span class="hljs-string">&#x27;error&#x27;</span>](combinedMessage); <span class="hljs-comment">// Don&#x27;t transform to our wrapper</span>
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-923">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-923">&#x00a7;</a>
              </div>
              <p>In production, we print the error directly.
This will include the message, the JS stack, and anything the browser wants to show.
We pass the error object instead of custom message so that the browser displays the error natively.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-variable language_">console</span>[<span class="hljs-string">&#x27;error&#x27;</span>](error); <span class="hljs-comment">// Don&#x27;t transform to our wrapper</span>
      }
    } <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-924">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-924">&#x00a7;</a>
              </div>
              <p>This method must not throw, or React internal state will get messed up.
If console.error is overridden, or logCapturedError() shows a dialog that throws,
we want to report this error outside of the normal stack as a last resort.
<a href="https://github.com/facebook/react/issues/13188">https://github.com/facebook/react/issues/13188</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">throw</span> e;
      });
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">PossiblyWeakMap</span>$<span class="hljs-number">2</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WeakMap</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title class_">WeakMap</span> : <span class="hljs-title class_">Map</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRootErrorUpdate</span>(<span class="hljs-params">fiber, errorInfo, lane</span>) {
    <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(<span class="hljs-title class_">NoTimestamp</span>, lane); <span class="hljs-comment">// Unmount the root by rendering null.</span>

    update.<span class="hljs-property">tag</span> = <span class="hljs-title class_">CaptureUpdate</span>; <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span></pre></div></div>
            
        </li>
        
        
        <li id="section-925">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-925">&#x00a7;</a>
              </div>
              <p>being called “element”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    update.<span class="hljs-property">payload</span> = {
      <span class="hljs-attr">element</span>: <span class="hljs-literal">null</span>
    };
    <span class="hljs-keyword">var</span> error = errorInfo.<span class="hljs-property">value</span>;

    update.<span class="hljs-property">callback</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-title function_">onUncaughtError</span>(error);
      <span class="hljs-title function_">logCapturedError</span>(fiber, errorInfo);
    };

    <span class="hljs-keyword">return</span> update;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createClassErrorUpdate</span>(<span class="hljs-params">fiber, errorInfo, lane</span>) {
    <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(<span class="hljs-title class_">NoTimestamp</span>, lane);
    update.<span class="hljs-property">tag</span> = <span class="hljs-title class_">CaptureUpdate</span>;
    <span class="hljs-keyword">var</span> getDerivedStateFromError = fiber.<span class="hljs-property">type</span>.<span class="hljs-property">getDerivedStateFromError</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromError === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">var</span> error$<span class="hljs-number">1</span> = errorInfo.<span class="hljs-property">value</span>;

      update.<span class="hljs-property">payload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">logCapturedError</span>(fiber, errorInfo);
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getDerivedStateFromError</span>(error$<span class="hljs-number">1</span>);
      };
    }

    <span class="hljs-keyword">var</span> inst = fiber.<span class="hljs-property">stateNode</span>;

    <span class="hljs-keyword">if</span> (inst !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> inst.<span class="hljs-property">componentDidCatch</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      update.<span class="hljs-property">callback</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">callback</span>(<span class="hljs-params"></span>) {
        {
          <span class="hljs-title function_">markFailedErrorBoundaryForHotReloading</span>(fiber);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromError !== <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-926">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-926">&#x00a7;</a>
              </div>
              <p>To preserve the preexisting retry behavior of error boundaries,
we keep track of which ones already failed during this batch.
This gets reset before we yield back to the browser.
TODO: Warn in strict mode if getDerivedStateFromError is
not defined.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">markLegacyErrorBoundaryAsFailed</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// Only log here if componentDidCatch is the only error boundary method defined</span>

          <span class="hljs-title function_">logCapturedError</span>(fiber, errorInfo);
        }

        <span class="hljs-keyword">var</span> error$<span class="hljs-number">1</span> = errorInfo.<span class="hljs-property">value</span>;
        <span class="hljs-keyword">var</span> stack = errorInfo.<span class="hljs-property">stack</span>;
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">componentDidCatch</span>(error$<span class="hljs-number">1</span>, {
          <span class="hljs-attr">componentStack</span>: stack !== <span class="hljs-literal">null</span> ? stack : <span class="hljs-string">&#x27;&#x27;</span>
        });

        {
          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> getDerivedStateFromError !== <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-927">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-927">&#x00a7;</a>
              </div>
              <p>If componentDidCatch is the only error boundary method defined,
then it needs to call setState to recover from errors.
If no state update is scheduled then the boundary will swallow the error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(fiber.<span class="hljs-property">lanes</span>, <span class="hljs-title class_">SyncLane</span>)) {
              <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s: Error boundaries should implement getDerivedStateFromError(). &#x27;</span> + <span class="hljs-string">&#x27;In that method, return a state update to display an error message or fallback UI.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>);
            }
          }
        }
      };
    } <span class="hljs-keyword">else</span> {
      update.<span class="hljs-property">callback</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">markFailedErrorBoundaryForHotReloading</span>(fiber);
      };
    }

    <span class="hljs-keyword">return</span> update;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attachPingListener</span>(<span class="hljs-params">root, wakeable, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-928">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-928">&#x00a7;</a>
              </div>
              <p>Attach a listener to the promise to “ping” the root and retry. But only if
one does not already exist for the lanes we’re currently rendering (which
acts like a “thread ID” here).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> pingCache = root.<span class="hljs-property">pingCache</span>;
    <span class="hljs-keyword">var</span> threadIDs;

    <span class="hljs-keyword">if</span> (pingCache === <span class="hljs-literal">null</span>) {
      pingCache = root.<span class="hljs-property">pingCache</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PossiblyWeakMap</span><span class="hljs-title function_">$2</span>();
      threadIDs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
      pingCache.<span class="hljs-title function_">set</span>(wakeable, threadIDs);
    } <span class="hljs-keyword">else</span> {
      threadIDs = pingCache.<span class="hljs-title function_">get</span>(wakeable);

      <span class="hljs-keyword">if</span> (threadIDs === <span class="hljs-literal">undefined</span>) {
        threadIDs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
        pingCache.<span class="hljs-title function_">set</span>(wakeable, threadIDs);
      }
    }

    <span class="hljs-keyword">if</span> (!threadIDs.<span class="hljs-title function_">has</span>(lanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-929">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-929">&#x00a7;</a>
              </div>
              <p>Memoize using the thread ID to prevent redundant listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      threadIDs.<span class="hljs-title function_">add</span>(lanes);
      <span class="hljs-keyword">var</span> ping = pingSuspendedRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root, wakeable, lanes);
      wakeable.<span class="hljs-title function_">then</span>(ping, ping);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">throwException</span>(<span class="hljs-params">root, returnFiber, sourceFiber, value, rootRenderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-930">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-930">&#x00a7;</a>
              </div>
              <p>The source fiber did not complete.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sourceFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Incomplete</span>; <span class="hljs-comment">// Its effect list is no longer valid.</span>

    sourceFiber.<span class="hljs-property">firstEffect</span> = sourceFiber.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (value !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-931">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-931">&#x00a7;</a>
              </div>
              <p>This is a wakeable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> wakeable = value;

      {
        <span class="hljs-title function_">markComponentSuspended</span>(sourceFiber, wakeable);
      }

      <span class="hljs-keyword">if</span> ((sourceFiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-932">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-932">&#x00a7;</a>
              </div>
              <p>Reset the memoizedState to what it was before we attempted
to render it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> currentSource = sourceFiber.<span class="hljs-property">alternate</span>;

        <span class="hljs-keyword">if</span> (currentSource) {
          sourceFiber.<span class="hljs-property">updateQueue</span> = currentSource.<span class="hljs-property">updateQueue</span>;
          sourceFiber.<span class="hljs-property">memoizedState</span> = currentSource.<span class="hljs-property">memoizedState</span>;
          sourceFiber.<span class="hljs-property">lanes</span> = currentSource.<span class="hljs-property">lanes</span>;
        } <span class="hljs-keyword">else</span> {
          sourceFiber.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;
          sourceFiber.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
        }
      }

      <span class="hljs-keyword">var</span> hasInvisibleParentBoundary = <span class="hljs-title function_">hasSuspenseContext</span>(suspenseStackCursor.<span class="hljs-property">current</span>, <span class="hljs-title class_">InvisibleParentSuspenseContext</span>); <span class="hljs-comment">// Schedule the nearest Suspense to re-render the timed out view.</span>

      <span class="hljs-keyword">var</span> _workInProgress = returnFiber;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> (_workInProgress.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span> &amp;&amp; <span class="hljs-title function_">shouldCaptureSuspense</span>(_workInProgress, hasInvisibleParentBoundary)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-933">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-933">&#x00a7;</a>
              </div>
              <p>Found the nearest boundary.
Stash the promise on the boundary fiber. If the boundary times out, we’ll
attach another listener to flip the boundary back to its normal state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> wakeables = _workInProgress.<span class="hljs-property">updateQueue</span>;

          <span class="hljs-keyword">if</span> (wakeables === <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> updateQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
            updateQueue.<span class="hljs-title function_">add</span>(wakeable);
            _workInProgress.<span class="hljs-property">updateQueue</span> = updateQueue;
          } <span class="hljs-keyword">else</span> {
            wakeables.<span class="hljs-title function_">add</span>(wakeable);
          } <span class="hljs-comment">// If the boundary is outside of blocking mode, we should *not*</span></pre></div></div>
            
        </li>
        
        
        <li id="section-934">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-934">&#x00a7;</a>
              </div>
              <p>suspend the commit. Pretend as if the suspended component rendered
null and keep rendering. In the commit phase, we’ll schedule a
subsequent synchronous update to re-render the Suspense.</p>
<p>Note: It doesn’t matter whether the component that suspended was
inside a blocking mode tree. If the Suspense is outside of it, we
should <em>not</em> suspend the commit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          <span class="hljs-keyword">if</span> ((_workInProgress.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {
            _workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">DidCapture</span>;
            sourceFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">ForceUpdateForLegacySuspense</span>; <span class="hljs-comment">// We&#x27;re going to commit this fiber even though it didn&#x27;t complete.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-935">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-935">&#x00a7;</a>
              </div>
              <p>But we shouldn’t call any lifecycle methods or callbacks. Remove
all lifecycle effect tags.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            sourceFiber.<span class="hljs-property">flags</span> &amp;= ~(<span class="hljs-title class_">LifecycleEffectMask</span> | <span class="hljs-title class_">Incomplete</span>);

            <span class="hljs-keyword">if</span> (sourceFiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) {
              <span class="hljs-keyword">var</span> currentSourceFiber = sourceFiber.<span class="hljs-property">alternate</span>;

              <span class="hljs-keyword">if</span> (currentSourceFiber === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-936">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-936">&#x00a7;</a>
              </div>
              <p>This is a new mount. Change the tag so it’s not mistaken for a
completed class component. For example, we should not call
componentWillUnmount if it is deleted.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                sourceFiber.<span class="hljs-property">tag</span> = <span class="hljs-title class_">IncompleteClassComponent</span>;
              } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-937">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-937">&#x00a7;</a>
              </div>
              <p>When we try rendering again, we should not reuse the current fiber,
since it’s known to be in an inconsistent state. Use a force update to
prevent a bail out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(<span class="hljs-title class_">NoTimestamp</span>, <span class="hljs-title class_">SyncLane</span>);
                update.<span class="hljs-property">tag</span> = <span class="hljs-title class_">ForceUpdate</span>;
                <span class="hljs-title function_">enqueueUpdate</span>(sourceFiber, update);
              }
            } <span class="hljs-comment">// The source fiber did not complete. Mark it with Sync priority to</span></pre></div></div>
            
        </li>
        
        
        <li id="section-938">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-938">&#x00a7;</a>
              </div>
              <p>indicate that it still has pending work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

            sourceFiber.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(sourceFiber.<span class="hljs-property">lanes</span>, <span class="hljs-title class_">SyncLane</span>); <span class="hljs-comment">// Exit without suspending.</span>

            <span class="hljs-keyword">return</span>;
          } <span class="hljs-comment">// Confirmed that the boundary is in a concurrent mode tree. Continue</span></pre></div></div>
            
        </li>
        
        
        <li id="section-939">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-939">&#x00a7;</a>
              </div>
              <p>with the normal suspend path.</p>
<p>After this we’ll use a set of heuristics to determine whether this
render pass will run to completion or restart or “suspend” the commit.
The actual logic for this is spread out in different places.</p>
<p>This first principle is that if we’re going to suspend when we complete
a root, then we should also restart if we get an update or ping that
might unsuspend it, and vice versa. The only reason to suspend is
because you think you might want to restart before committing. However,
it doesn’t make sense to restart only while in the period we’re suspended.</p>
<p>Restarting too aggressively is also not good because it starves out any
intermediate loading state. So we use heuristics to determine when.
Suspense Heuristics</p>
<p>If nothing threw a Promise or all the same fallbacks are already showing,
then don’t suspend/restart.</p>
<p>If this is an initial render of a new tree of Suspense boundaries and
those trigger a fallback, then don’t suspend/restart. We want to ensure
that we can show the initial loading state as quickly as possible.</p>
<p>If we hit a “Delayed” case, such as when we’d switch from content back into
a fallback, then we should always suspend/restart. Transitions apply
to this case. If none is defined, JND is used instead.</p>
<p>If we’re already showing a fallback and it gets “retried”, allowing us to show
another level, but there’s still an inner boundary that would show a fallback,
then we suspend/restart for 500ms since the last time we showed a fallback
anywhere in the tree. This effectively throttles progressive loading into a
consistent train of commits. This also gives us an opportunity to restart to
get to the completed state slightly earlier.</p>
<p>If there’s ambiguity due to batching it’s resolved in preference of:</p>
<ol>
<li>“delayed”, 2) “initial render”, 3) “retry”.</li>
</ol>
<p>We want to ensure that a “busy” state doesn’t get force committed. We want to
ensure that new initial loading states can commit as soon as possible.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          <span class="hljs-title function_">attachPingListener</span>(root, wakeable, rootRenderLanes);
          _workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">ShouldCapture</span>;
          _workInProgress.<span class="hljs-property">lanes</span> = rootRenderLanes;
          <span class="hljs-keyword">return</span>;
        } <span class="hljs-comment">// This boundary already captured during this render. Continue to the next</span></pre></div></div>
            
        </li>
        
        
        <li id="section-940">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-940">&#x00a7;</a>
              </div>
              <p>boundary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        _workInProgress = _workInProgress.<span class="hljs-property">return</span>;
      } <span class="hljs-keyword">while</span> (_workInProgress !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// No boundary was found. Fallthrough to error mode.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-941">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-941">&#x00a7;</a>
              </div>
              <p>TODO: Use invariant so the message is stripped in prod?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>((<span class="hljs-title function_">getComponentName</span>(sourceFiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;A React component&#x27;</span>) + <span class="hljs-string">&#x27; suspended while rendering, but no fallback UI was specified.\n&#x27;</span> + <span class="hljs-string">&#x27;\n&#x27;</span> + <span class="hljs-string">&#x27;Add a &lt;Suspense fallback=...&gt; component higher in the tree to &#x27;</span> + <span class="hljs-string">&#x27;provide a loading indicator or placeholder to display.&#x27;</span>);
    } <span class="hljs-comment">// We didn&#x27;t find a boundary that could handle this type of exception. Start</span></pre></div></div>
            
        </li>
        
        
        <li id="section-942">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-942">&#x00a7;</a>
              </div>
              <p>over and traverse parent path again, this time treating the exception
as an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-title function_">renderDidError</span>();
    value = <span class="hljs-title function_">createCapturedValue</span>(value, sourceFiber);
    <span class="hljs-keyword">var</span> workInProgress = returnFiber;

    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
          {
            <span class="hljs-keyword">var</span> _errorInfo = value;
            workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">ShouldCapture</span>;
            <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">pickArbitraryLane</span>(rootRenderLanes);
            workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(workInProgress.<span class="hljs-property">lanes</span>, lane);

            <span class="hljs-keyword">var</span> _update = <span class="hljs-title function_">createRootErrorUpdate</span>(workInProgress, _errorInfo, lane);

            <span class="hljs-title function_">enqueueCapturedUpdate</span>(workInProgress, _update);
            <span class="hljs-keyword">return</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-943">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-943">&#x00a7;</a>
              </div>
              <p>Capture and retry</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> errorInfo = value;
          <span class="hljs-keyword">var</span> ctor = workInProgress.<span class="hljs-property">type</span>;
          <span class="hljs-keyword">var</span> instance = workInProgress.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> ((workInProgress.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">DidCapture</span>) === <span class="hljs-title class_">NoFlags</span> &amp;&amp; (<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromError</span> === <span class="hljs-string">&#x27;function&#x27;</span> || instance !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidCatch</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; !<span class="hljs-title function_">isAlreadyFailedLegacyErrorBoundary</span>(instance))) {
            workInProgress.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">ShouldCapture</span>;

            <span class="hljs-keyword">var</span> _lane = <span class="hljs-title function_">pickArbitraryLane</span>(rootRenderLanes);

            workInProgress.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(workInProgress.<span class="hljs-property">lanes</span>, _lane); <span class="hljs-comment">// Schedule the error boundary to re-render using updated state</span>

            <span class="hljs-keyword">var</span> _update2 = <span class="hljs-title function_">createClassErrorUpdate</span>(workInProgress, errorInfo, _lane);

            <span class="hljs-title function_">enqueueCapturedUpdate</span>(workInProgress, _update2);
            <span class="hljs-keyword">return</span>;
          }

          <span class="hljs-keyword">break</span>;
      }

      workInProgress = workInProgress.<span class="hljs-property">return</span>;
    } <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>);
  }

  <span class="hljs-keyword">var</span> didWarnAboutUndefinedSnapshotBeforeUpdate = <span class="hljs-literal">null</span>;

  {
    didWarnAboutUndefinedSnapshotBeforeUpdate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">PossiblyWeakSet</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WeakSet</span> === <span class="hljs-string">&#x27;function&#x27;</span> ? <span class="hljs-title class_">WeakSet</span> : <span class="hljs-title class_">Set</span>;

  <span class="hljs-keyword">var</span> callComponentWillUnmountWithTimer = <span class="hljs-keyword">function</span> (<span class="hljs-params">current, instance</span>) {
    instance.<span class="hljs-property">props</span> = current.<span class="hljs-property">memoizedProps</span>;
    instance.<span class="hljs-property">state</span> = current.<span class="hljs-property">memoizedState</span>;

    {
      instance.<span class="hljs-title function_">componentWillUnmount</span>();
    }
  }; <span class="hljs-comment">// Capture errors so they don&#x27;t interrupt unmounting.</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">safelyCallComponentWillUnmount</span>(<span class="hljs-params">current, instance</span>) {
    {
      <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, callComponentWillUnmountWithTimer, <span class="hljs-literal">null</span>, current, instance);

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
        <span class="hljs-keyword">var</span> unmountError = <span class="hljs-title function_">clearCaughtError</span>();
        <span class="hljs-title function_">captureCommitPhaseError</span>(current, unmountError);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">safelyDetachRef</span>(<span class="hljs-params">current</span>) {
    <span class="hljs-keyword">var</span> ref = current.<span class="hljs-property">ref</span>;

    <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">&#x27;function&#x27;</span>) {
        {
          <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, ref, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
            <span class="hljs-keyword">var</span> refError = <span class="hljs-title function_">clearCaughtError</span>();
            <span class="hljs-title function_">captureCommitPhaseError</span>(current, refError);
          }
        }
      } <span class="hljs-keyword">else</span> {
        ref.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">safelyCallDestroy</span>(<span class="hljs-params">current, destroy</span>) {
    {
      <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, destroy, <span class="hljs-literal">null</span>);

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
        <span class="hljs-keyword">var</span> error = <span class="hljs-title function_">clearCaughtError</span>();
        <span class="hljs-title function_">captureCommitPhaseError</span>(current, error);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitBeforeMutationLifeCycles</span>(<span class="hljs-params">current, finishedWork</span>) {
    <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        {
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Snapshot</span>) {
            <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> prevProps = current.<span class="hljs-property">memoizedProps</span>;
              <span class="hljs-keyword">var</span> prevState = current.<span class="hljs-property">memoizedState</span>;
              <span class="hljs-keyword">var</span> instance = finishedWork.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// We could update instance props and state here,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-944">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-944">&#x00a7;</a>
              </div>
              <p>but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              {
                <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">type</span> === finishedWork.<span class="hljs-property">elementType</span> &amp;&amp; !didWarnAboutReassigningProps) {
                  <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">props</span> !== finishedWork.<span class="hljs-property">memoizedProps</span>) {
                    <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s props to match memoized props before &#x27;</span> + <span class="hljs-string">&#x27;getSnapshotBeforeUpdate. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.props`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                  }

                  <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">state</span> !== finishedWork.<span class="hljs-property">memoizedState</span>) {
                    <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s state to match memoized state before &#x27;</span> + <span class="hljs-string">&#x27;getSnapshotBeforeUpdate. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.state`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                  }
                }
              }

              <span class="hljs-keyword">var</span> snapshot = instance.<span class="hljs-title function_">getSnapshotBeforeUpdate</span>(finishedWork.<span class="hljs-property">elementType</span> === finishedWork.<span class="hljs-property">type</span> ? prevProps : <span class="hljs-title function_">resolveDefaultProps</span>(finishedWork.<span class="hljs-property">type</span>, prevProps), prevState);

              {
                <span class="hljs-keyword">var</span> didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

                <span class="hljs-keyword">if</span> (snapshot === <span class="hljs-literal">undefined</span> &amp;&amp; !didWarnSet.<span class="hljs-title function_">has</span>(finishedWork.<span class="hljs-property">type</span>)) {
                  didWarnSet.<span class="hljs-title function_">add</span>(finishedWork.<span class="hljs-property">type</span>);

                  <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s.getSnapshotBeforeUpdate(): A snapshot value (or null) &#x27;</span> + <span class="hljs-string">&#x27;must be returned. You have returned undefined.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>));
                }
              }

              instance.<span class="hljs-property">__reactInternalSnapshotBeforeUpdate</span> = snapshot;
            }
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        {
          {
            <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Snapshot</span>) {
              <span class="hljs-keyword">var</span> root = finishedWork.<span class="hljs-property">stateNode</span>;
              <span class="hljs-title function_">clearContainer</span>(root.<span class="hljs-property">containerInfo</span>);
            }
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IncompleteClassComponent</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-945">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-945">&#x00a7;</a>
              </div>
              <p>Nothing to do for these component types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
    }

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitHookEffectListUnmount</span>(<span class="hljs-params">tag, finishedWork</span>) {
    <span class="hljs-keyword">var</span> updateQueue = finishedWork.<span class="hljs-property">updateQueue</span>;
    <span class="hljs-keyword">var</span> lastEffect = updateQueue !== <span class="hljs-literal">null</span> ? updateQueue.<span class="hljs-property">lastEffect</span> : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> firstEffect = lastEffect.<span class="hljs-property">next</span>;
      <span class="hljs-keyword">var</span> effect = firstEffect;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> ((effect.<span class="hljs-property">tag</span> &amp; tag) === tag) {</pre></div></div>
            
        </li>
        
        
        <li id="section-946">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-946">&#x00a7;</a>
              </div>
              <p>Unmount</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> destroy = effect.<span class="hljs-property">destroy</span>;
          effect.<span class="hljs-property">destroy</span> = <span class="hljs-literal">undefined</span>;

          <span class="hljs-keyword">if</span> (destroy !== <span class="hljs-literal">undefined</span>) {
            <span class="hljs-title function_">destroy</span>();
          }
        }

        effect = effect.<span class="hljs-property">next</span>;
      } <span class="hljs-keyword">while</span> (effect !== firstEffect);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitHookEffectListMount</span>(<span class="hljs-params">tag, finishedWork</span>) {
    <span class="hljs-keyword">var</span> updateQueue = finishedWork.<span class="hljs-property">updateQueue</span>;
    <span class="hljs-keyword">var</span> lastEffect = updateQueue !== <span class="hljs-literal">null</span> ? updateQueue.<span class="hljs-property">lastEffect</span> : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> firstEffect = lastEffect.<span class="hljs-property">next</span>;
      <span class="hljs-keyword">var</span> effect = firstEffect;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">if</span> ((effect.<span class="hljs-property">tag</span> &amp; tag) === tag) {</pre></div></div>
            
        </li>
        
        
        <li id="section-947">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-947">&#x00a7;</a>
              </div>
              <p>Mount</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> create = effect.<span class="hljs-property">create</span>;
          effect.<span class="hljs-property">destroy</span> = <span class="hljs-title function_">create</span>();

          {
            <span class="hljs-keyword">var</span> destroy = effect.<span class="hljs-property">destroy</span>;

            <span class="hljs-keyword">if</span> (destroy !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> destroy !== <span class="hljs-string">&#x27;function&#x27;</span>) {
              <span class="hljs-keyword">var</span> addendum = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

              <span class="hljs-keyword">if</span> (destroy === <span class="hljs-literal">null</span>) {
                addendum = <span class="hljs-string">&#x27; You returned null. If your effect does not require clean &#x27;</span> + <span class="hljs-string">&#x27;up, return undefined (or nothing).&#x27;</span>;
              } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> destroy.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
                addendum = <span class="hljs-string">&#x27;\n\nIt looks like you wrote useEffect(async () =&gt; ...) or returned a Promise. &#x27;</span> + <span class="hljs-string">&#x27;Instead, write the async function inside your effect &#x27;</span> + <span class="hljs-string">&#x27;and call it immediately:\n\n&#x27;</span> + <span class="hljs-string">&#x27;useEffect(() =&gt; {\n&#x27;</span> + <span class="hljs-string">&#x27;  async function fetchData() {\n&#x27;</span> + <span class="hljs-string">&#x27;    // You can await here\n&#x27;</span> + <span class="hljs-string">&#x27;    const response = await MyAPI.getData(someId);\n&#x27;</span> + <span class="hljs-string">&#x27;    // ...\n&#x27;</span> + <span class="hljs-string">&#x27;  }\n&#x27;</span> + <span class="hljs-string">&#x27;  fetchData();\n&#x27;</span> + <span class="hljs-string">&quot;}, [someId]); // Or [] if effect doesn&#x27;t need props or state\n\n&quot;</span> + <span class="hljs-string">&#x27;Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching&#x27;</span>;
              } <span class="hljs-keyword">else</span> {
                addendum = <span class="hljs-string">&#x27; You returned: &#x27;</span> + destroy;
              }

              <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;An effect function must not return anything besides a function, &#x27;</span> + <span class="hljs-string">&#x27;which is used for clean-up.%s&#x27;</span>, addendum);
            }
          }
        }

        effect = effect.<span class="hljs-property">next</span>;
      } <span class="hljs-keyword">while</span> (effect !== firstEffect);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">schedulePassiveEffects</span>(<span class="hljs-params">finishedWork</span>) {
    <span class="hljs-keyword">var</span> updateQueue = finishedWork.<span class="hljs-property">updateQueue</span>;
    <span class="hljs-keyword">var</span> lastEffect = updateQueue !== <span class="hljs-literal">null</span> ? updateQueue.<span class="hljs-property">lastEffect</span> : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> firstEffect = lastEffect.<span class="hljs-property">next</span>;
      <span class="hljs-keyword">var</span> effect = firstEffect;

      <span class="hljs-keyword">do</span> {
        <span class="hljs-keyword">var</span> _effect = effect,
          next = _effect.<span class="hljs-property">next</span>,
          tag = _effect.<span class="hljs-property">tag</span>;

        <span class="hljs-keyword">if</span> ((tag &amp; <span class="hljs-title class_">Passive</span>$<span class="hljs-number">1</span>) !== <span class="hljs-title class_">NoFlags</span>$<span class="hljs-number">1</span> &amp;&amp; (tag &amp; <span class="hljs-title class_">HasEffect</span>) !== <span class="hljs-title class_">NoFlags</span>$<span class="hljs-number">1</span>) {
          <span class="hljs-title function_">enqueuePendingPassiveHookEffectUnmount</span>(finishedWork, effect);
          <span class="hljs-title function_">enqueuePendingPassiveHookEffectMount</span>(finishedWork, effect);
        }

        effect = next;
      } <span class="hljs-keyword">while</span> (effect !== firstEffect);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLifeCycles</span>(<span class="hljs-params">finishedRoot, current, finishedWork, committedLanes</span>) {
    <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-948">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-948">&#x00a7;</a>
              </div>
              <p>At this point layout effects have already been destroyed (during mutation phase).
This is done to prevent sibling component effects from interfering with each other,
e.g. a destroy function in one component should never override a ref set
by a create function in another component during the same commit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          {
            <span class="hljs-title function_">commitHookEffectListMount</span>(<span class="hljs-title class_">Layout</span> | <span class="hljs-title class_">HasEffect</span>, finishedWork);
          }

          <span class="hljs-title function_">schedulePassiveEffects</span>(finishedWork);
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-keyword">var</span> instance = finishedWork.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Update</span>) {
            <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-949">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-949">&#x00a7;</a>
              </div>
              <p>We could update instance props and state here,
but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              {
                <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">type</span> === finishedWork.<span class="hljs-property">elementType</span> &amp;&amp; !didWarnAboutReassigningProps) {
                  <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">props</span> !== finishedWork.<span class="hljs-property">memoizedProps</span>) {
                    <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s props to match memoized props before &#x27;</span> + <span class="hljs-string">&#x27;componentDidMount. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.props`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                  }

                  <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">state</span> !== finishedWork.<span class="hljs-property">memoizedState</span>) {
                    <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s state to match memoized state before &#x27;</span> + <span class="hljs-string">&#x27;componentDidMount. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.state`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                  }
                }
              }

              {
                instance.<span class="hljs-title function_">componentDidMount</span>();
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">var</span> prevProps = finishedWork.<span class="hljs-property">elementType</span> === finishedWork.<span class="hljs-property">type</span> ? current.<span class="hljs-property">memoizedProps</span> : <span class="hljs-title function_">resolveDefaultProps</span>(finishedWork.<span class="hljs-property">type</span>, current.<span class="hljs-property">memoizedProps</span>);
              <span class="hljs-keyword">var</span> prevState = current.<span class="hljs-property">memoizedState</span>; <span class="hljs-comment">// We could update instance props and state here,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-950">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-950">&#x00a7;</a>
              </div>
              <p>but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              {
                <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">type</span> === finishedWork.<span class="hljs-property">elementType</span> &amp;&amp; !didWarnAboutReassigningProps) {
                  <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">props</span> !== finishedWork.<span class="hljs-property">memoizedProps</span>) {
                    <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s props to match memoized props before &#x27;</span> + <span class="hljs-string">&#x27;componentDidUpdate. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.props`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                  }

                  <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">state</span> !== finishedWork.<span class="hljs-property">memoizedState</span>) {
                    <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s state to match memoized state before &#x27;</span> + <span class="hljs-string">&#x27;componentDidUpdate. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.state`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                  }
                }
              }

              {
                instance.<span class="hljs-title function_">componentDidUpdate</span>(prevProps, prevState, instance.<span class="hljs-property">__reactInternalSnapshotBeforeUpdate</span>);
              }
            }
          } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> I think this is now always non-null by the time it reaches the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-951">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-951">&#x00a7;</a>
              </div>
              <p>commit phase. Consider removing the type check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          <span class="hljs-keyword">var</span> updateQueue = finishedWork.<span class="hljs-property">updateQueue</span>;

          <span class="hljs-keyword">if</span> (updateQueue !== <span class="hljs-literal">null</span>) {
            {
              <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">type</span> === finishedWork.<span class="hljs-property">elementType</span> &amp;&amp; !didWarnAboutReassigningProps) {
                <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">props</span> !== finishedWork.<span class="hljs-property">memoizedProps</span>) {
                  <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s props to match memoized props before &#x27;</span> + <span class="hljs-string">&#x27;processing the update queue. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.props`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                }

                <span class="hljs-keyword">if</span> (instance.<span class="hljs-property">state</span> !== finishedWork.<span class="hljs-property">memoizedState</span>) {
                  <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Expected %s state to match memoized state before &#x27;</span> + <span class="hljs-string">&#x27;processing the update queue. &#x27;</span> + <span class="hljs-string">&#x27;This might either be because of a bug in React, or because &#x27;</span> + <span class="hljs-string">&#x27;a component reassigns its own `this.state`. &#x27;</span> + <span class="hljs-string">&#x27;Please file an issue.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;instance&#x27;</span>);
                }
              }
            } <span class="hljs-comment">// We could update instance props and state here,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-952">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-952">&#x00a7;</a>
              </div>
              <p>but instead we rely on them being set during last render.
TODO: revisit this when we implement resuming.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

            <span class="hljs-title function_">commitUpdateQueue</span>(finishedWork, updateQueue, instance);
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-953">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-953">&#x00a7;</a>
              </div>
              <p>TODO: I think this is now always non-null by the time it reaches the
commit phase. Consider removing the type check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> _updateQueue = finishedWork.<span class="hljs-property">updateQueue</span>;

          <span class="hljs-keyword">if</span> (_updateQueue !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> _instance = <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">child</span>.<span class="hljs-property">tag</span>) {
                <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
                  _instance = <span class="hljs-title function_">getPublicInstance</span>(finishedWork.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>);
                  <span class="hljs-keyword">break</span>;

                <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
                  _instance = finishedWork.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>;
                  <span class="hljs-keyword">break</span>;
              }
            }

            <span class="hljs-title function_">commitUpdateQueue</span>(finishedWork, _updateQueue, _instance);
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        {
          <span class="hljs-keyword">var</span> _instance2 = finishedWork.<span class="hljs-property">stateNode</span>; <span class="hljs-comment">// Renderers may schedule work to be done after host components are mounted</span></pre></div></div>
            
        </li>
        
        
        <li id="section-954">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-954">&#x00a7;</a>
              </div>
              <p>(eg DOM renderer may schedule auto-focus for inputs and form controls).
These effects should only be committed when components are first mounted,
aka when there is no current/alternate.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> &amp;&amp; finishedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Update</span>) {
            <span class="hljs-keyword">var</span> type = finishedWork.<span class="hljs-property">type</span>;
            <span class="hljs-keyword">var</span> props = finishedWork.<span class="hljs-property">memoizedProps</span>;
            <span class="hljs-title function_">commitMount</span>(_instance2, type, props);
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-955">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-955">&#x00a7;</a>
              </div>
              <p>We have no life-cycles associated with text.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-956">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-956">&#x00a7;</a>
              </div>
              <p>We have no life-cycles associated with portals.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
        {
          {
            <span class="hljs-keyword">var</span> _finishedWork$memoize2 = finishedWork.<span class="hljs-property">memoizedProps</span>,
              onCommit = _finishedWork$memoize2.<span class="hljs-property">onCommit</span>,
              onRender = _finishedWork$memoize2.<span class="hljs-property">onRender</span>;
            <span class="hljs-keyword">var</span> effectDuration = finishedWork.<span class="hljs-property">stateNode</span>.<span class="hljs-property">effectDuration</span>;
            <span class="hljs-keyword">var</span> commitTime = <span class="hljs-title function_">getCommitTime</span>();

            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> onRender === <span class="hljs-string">&#x27;function&#x27;</span>) {
              {
                <span class="hljs-title function_">onRender</span>(finishedWork.<span class="hljs-property">memoizedProps</span>.<span class="hljs-property">id</span>, current === <span class="hljs-literal">null</span> ? <span class="hljs-string">&#x27;mount&#x27;</span> : <span class="hljs-string">&#x27;update&#x27;</span>, finishedWork.<span class="hljs-property">actualDuration</span>, finishedWork.<span class="hljs-property">treeBaseDuration</span>, finishedWork.<span class="hljs-property">actualStartTime</span>, commitTime, finishedRoot.<span class="hljs-property">memoizedInteractions</span>);
              }
            }
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        {
          <span class="hljs-title function_">commitSuspenseHydrationCallbacks</span>(finishedRoot, finishedWork);
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IncompleteClassComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyHiddenComponent</span>:
        <span class="hljs-keyword">return</span>;
    }

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hideOrUnhideAllChildren</span>(<span class="hljs-params">finishedWork, isHidden</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-957">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-957">&#x00a7;</a>
              </div>
              <p>We only have the top Fiber that was inserted but we need to recurse down its
children to find all the terminal nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> node = finishedWork;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span>) {
          <span class="hljs-keyword">var</span> instance = node.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (isHidden) {
            <span class="hljs-title function_">hideInstance</span>(instance);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">unhideInstance</span>(node.<span class="hljs-property">stateNode</span>, node.<span class="hljs-property">memoizedProps</span>);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span>) {
          <span class="hljs-keyword">var</span> _instance3 = node.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (isHidden) {
            <span class="hljs-title function_">hideTextInstance</span>(_instance3);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">unhideTextInstance</span>(_instance3, node.<span class="hljs-property">memoizedProps</span>);
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">OffscreenComponent</span> || node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">LegacyHiddenComponent</span>) &amp;&amp; node.<span class="hljs-property">memoizedState</span> !== <span class="hljs-literal">null</span> &amp;&amp; node !== finishedWork); <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {
          node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
          node = node.<span class="hljs-property">child</span>;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === finishedWork) {
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">return</span> === finishedWork) {
            <span class="hljs-keyword">return</span>;
          }

          node = node.<span class="hljs-property">return</span>;
        }

        node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
        node = node.<span class="hljs-property">sibling</span>;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitAttachRef</span>(<span class="hljs-params">finishedWork</span>) {
    <span class="hljs-keyword">var</span> ref = finishedWork.<span class="hljs-property">ref</span>;

    <span class="hljs-keyword">if</span> (ref !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> instance = finishedWork.<span class="hljs-property">stateNode</span>;
      <span class="hljs-keyword">var</span> instanceToUse;

      <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
          instanceToUse = <span class="hljs-title function_">getPublicInstance</span>(instance);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-attr">default</span>:
          instanceToUse = instance;
      } <span class="hljs-comment">// Moved outside to ensure DCE works with this flag</span>

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ref === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">ref</span>(instanceToUse);
      } <span class="hljs-keyword">else</span> {
        {
          <span class="hljs-keyword">if</span> (!ref.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;current&#x27;</span>)) {
            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Unexpected ref object provided for %s. &#x27;</span> + <span class="hljs-string">&#x27;Use either a ref-setter function or React.createRef().&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(finishedWork.<span class="hljs-property">type</span>));
          }
        }

        ref.<span class="hljs-property">current</span> = instanceToUse;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDetachRef</span>(<span class="hljs-params">current</span>) {
    <span class="hljs-keyword">var</span> currentRef = current.<span class="hljs-property">ref</span>;

    <span class="hljs-keyword">if</span> (currentRef !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> currentRef === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">currentRef</span>(<span class="hljs-literal">null</span>);
      } <span class="hljs-keyword">else</span> {
        currentRef.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
      }
    }
  } <span class="hljs-comment">// User-originating errors (lifecycles and refs) should not interrupt</span></pre></div></div>
            
        </li>
        
        
        <li id="section-958">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-958">&#x00a7;</a>
              </div>
              <p>deletion, so don’t let them throw. Host-originating errors should
interrupt deletion, so it’s okay</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitUnmount</span>(<span class="hljs-params">finishedRoot, current, renderPriorityLevel</span>) {
    <span class="hljs-title function_">onCommitUnmount</span>(current);

    <span class="hljs-keyword">switch</span> (current.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        {
          <span class="hljs-keyword">var</span> updateQueue = current.<span class="hljs-property">updateQueue</span>;

          <span class="hljs-keyword">if</span> (updateQueue !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">var</span> lastEffect = updateQueue.<span class="hljs-property">lastEffect</span>;

            <span class="hljs-keyword">if</span> (lastEffect !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">var</span> firstEffect = lastEffect.<span class="hljs-property">next</span>;
              <span class="hljs-keyword">var</span> effect = firstEffect;

              <span class="hljs-keyword">do</span> {
                <span class="hljs-keyword">var</span> _effect2 = effect,
                  destroy = _effect2.<span class="hljs-property">destroy</span>,
                  tag = _effect2.<span class="hljs-property">tag</span>;

                <span class="hljs-keyword">if</span> (destroy !== <span class="hljs-literal">undefined</span>) {
                  <span class="hljs-keyword">if</span> ((tag &amp; <span class="hljs-title class_">Passive</span>$<span class="hljs-number">1</span>) !== <span class="hljs-title class_">NoFlags</span>$<span class="hljs-number">1</span>) {
                    <span class="hljs-title function_">enqueuePendingPassiveHookEffectUnmount</span>(current, effect);
                  } <span class="hljs-keyword">else</span> {
                    {
                      <span class="hljs-title function_">safelyCallDestroy</span>(current, destroy);
                    }
                  }
                }

                effect = effect.<span class="hljs-property">next</span>;
              } <span class="hljs-keyword">while</span> (effect !== firstEffect);
            }
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-title function_">safelyDetachRef</span>(current);
          <span class="hljs-keyword">var</span> instance = current.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentWillUnmount</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
            <span class="hljs-title function_">safelyCallComponentWillUnmount</span>(current, instance);
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        {
          <span class="hljs-title function_">safelyDetachRef</span>(current);
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-959">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-959">&#x00a7;</a>
              </div>
              <p>TODO: this is recursive.
We are also not using this parent because
the portal will get pushed immediately.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          {
            <span class="hljs-title function_">unmountHostComponents</span>(finishedRoot, current);
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>:
        {

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">DehydratedFragment</span>:
        {

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>:
        {

          <span class="hljs-keyword">return</span>;
        }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitNestedUnmounts</span>(<span class="hljs-params">finishedRoot, root, renderPriorityLevel</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-960">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-960">&#x00a7;</a>
              </div>
              <p>While we’re inside a removed host node we don’t want to call
removeChild on the inner nodes because they’re removed by the top
call anyway. We also want to call componentWillUnmount on all
composites before this host node is removed from the tree. Therefore
we do an inner loop while we’re still inside the host node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> node = root;

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-title function_">commitUnmount</span>(finishedRoot, node); <span class="hljs-comment">// Visit children because they may contain more composite or host nodes.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-961">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-961">&#x00a7;</a>
              </div>
              <p>Skip portals because commitUnmount() currently visits them recursively.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span> &amp;&amp; ( <span class="hljs-comment">// If we use mutation we drill down into portals using commitUnmount above.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-962">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-962">&#x00a7;</a>
              </div>
              <p>If we don’t use mutation we drill down into portals here instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        node.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostPortal</span>)) {
        node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
        node = node.<span class="hljs-property">child</span>;
        <span class="hljs-keyword">continue</span>;
      }

      <span class="hljs-keyword">if</span> (node === root) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">return</span> === root) {
          <span class="hljs-keyword">return</span>;
        }

        node = node.<span class="hljs-property">return</span>;
      }

      node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
      node = node.<span class="hljs-property">sibling</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">detachFiberMutation</span>(<span class="hljs-params">fiber</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-963">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-963">&#x00a7;</a>
              </div>
              <p>Cut off the return pointers to disconnect it from the tree. Ideally, we
should clear the child pointer of the parent alternate to let this
get GC:ed but we don’t know which for sure which parent is the current
one so we’ll settle for GC:ing the subtree of this child. This child
itself will be GC:ed when the parent updates the next time.
Note: we cannot null out sibling here, otherwise it can cause issues
with findDOMNode and how it requires the sibling field to carry out
traversal in a later effect. See PR #16820. We now clear the sibling
field after effects, see: detachFiberAfterEffects.</p>
<p>Don’t disconnect stateNode now; it will be detached in detachFiberAfterEffects.
It may be required if the current component is an error boundary,
and one of its descendants throws while unmounting a passive effect.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fiber.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">pendingProps</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;

    {
      fiber.<span class="hljs-property">_debugOwner</span> = <span class="hljs-literal">null</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHostParentFiber</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> parent = fiber.<span class="hljs-property">return</span>;

    <span class="hljs-keyword">while</span> (parent !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isHostParent</span>(parent)) {
        <span class="hljs-keyword">return</span> parent;
      }

      parent = parent.<span class="hljs-property">return</span>;
    }

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isHostParent</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">return</span> fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span> || fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span> || fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostPortal</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getHostSibling</span>(<span class="hljs-params">fiber</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-964">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-964">&#x00a7;</a>
              </div>
              <p>We’re going to search forward into the tree until we find a sibling host
node. Unfortunately, if multiple insertions are done in a row we have to
search past them. This leads to exponential search for the next sibling.
TODO: Find a more efficient way to do this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> node = fiber;

    <span class="hljs-attr">siblings</span>: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-965">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-965">&#x00a7;</a>
              </div>
              <p>If we didn’t find anything, let’s try the next sibling.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || <span class="hljs-title function_">isHostParent</span>(node.<span class="hljs-property">return</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-966">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-966">&#x00a7;</a>
              </div>
              <p>If we pop out of the root or hit the parent the fiber we are the
last sibling.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }

        node = node.<span class="hljs-property">return</span>;
      }

      node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
      node = node.<span class="hljs-property">sibling</span>;

      <span class="hljs-keyword">while</span> (node.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostComponent</span> &amp;&amp; node.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">HostText</span> &amp;&amp; node.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">DehydratedFragment</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-967">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-967">&#x00a7;</a>
              </div>
              <p>If it is not host node and, we might have a host node inside it.
Try to search down until we find one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Placement</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-968">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-968">&#x00a7;</a>
              </div>
              <p>If we don’t have a child, try the siblings instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">continue</span> siblings;
        } <span class="hljs-comment">// If we don&#x27;t have a child, try the siblings instead.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-969">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-969">&#x00a7;</a>
              </div>
              <p>We also skip portals because they are not part of this host tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostPortal</span>) {
          <span class="hljs-keyword">continue</span> siblings;
        } <span class="hljs-keyword">else</span> {
          node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
          node = node.<span class="hljs-property">child</span>;
        }
      } <span class="hljs-comment">// Check if this host node is stable or about to be placed.</span>


      <span class="hljs-keyword">if</span> (!(node.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Placement</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-970">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-970">&#x00a7;</a>
              </div>
              <p>Found it!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> node.<span class="hljs-property">stateNode</span>;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitPlacement</span>(<span class="hljs-params">finishedWork</span>) {


    <span class="hljs-keyword">var</span> parentFiber = <span class="hljs-title function_">getHostParentFiber</span>(finishedWork); <span class="hljs-comment">// Note: these two variables *must* always be updated together.</span>

    <span class="hljs-keyword">var</span> parent;
    <span class="hljs-keyword">var</span> isContainer;
    <span class="hljs-keyword">var</span> parentStateNode = parentFiber.<span class="hljs-property">stateNode</span>;

    <span class="hljs-keyword">switch</span> (parentFiber.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        parent = parentStateNode;
        isContainer = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        parent = parentStateNode.<span class="hljs-property">containerInfo</span>;
        isContainer = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
        parent = parentStateNode.<span class="hljs-property">containerInfo</span>;
        isContainer = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-971">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-971">&#x00a7;</a>
              </div>
              <p>eslint-disable-next-line-no-fallthrough</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-attr">default</span>:
        {
          {
            <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
          }
        }

    }

    <span class="hljs-keyword">if</span> (parentFiber.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">ContentReset</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-972">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-972">&#x00a7;</a>
              </div>
              <p>Reset the text content of the parent before doing any insertions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">resetTextContent</span>(parent); <span class="hljs-comment">// Clear ContentReset from the effect tag</span>

      parentFiber.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">ContentReset</span>;
    }

    <span class="hljs-keyword">var</span> before = <span class="hljs-title function_">getHostSibling</span>(finishedWork); <span class="hljs-comment">// We only have the top Fiber that was inserted but we need to recurse down its</span></pre></div></div>
            
        </li>
        
        
        <li id="section-973">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-973">&#x00a7;</a>
              </div>
              <p>children to find all the terminal nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (isContainer) {
      <span class="hljs-title function_">insertOrAppendPlacementNodeIntoContainer</span>(finishedWork, before, parent);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-title function_">insertOrAppendPlacementNode</span>(finishedWork, before, parent);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">insertOrAppendPlacementNodeIntoContainer</span>(<span class="hljs-params">node, before, parent</span>) {
    <span class="hljs-keyword">var</span> tag = node.<span class="hljs-property">tag</span>;
    <span class="hljs-keyword">var</span> isHost = tag === <span class="hljs-title class_">HostComponent</span> || tag === <span class="hljs-title class_">HostText</span>;

    <span class="hljs-keyword">if</span> (isHost || enableFundamentalAPI) {
      <span class="hljs-keyword">var</span> stateNode = isHost ? node.<span class="hljs-property">stateNode</span> : node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">instance</span>;

      <span class="hljs-keyword">if</span> (before) {
        <span class="hljs-title function_">insertInContainerBefore</span>(parent, stateNode, before);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">appendChildToContainer</span>(parent, stateNode);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostPortal</span>); <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> child = node.<span class="hljs-property">child</span>;

      <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">insertOrAppendPlacementNodeIntoContainer</span>(child, before, parent);
        <span class="hljs-keyword">var</span> sibling = child.<span class="hljs-property">sibling</span>;

        <span class="hljs-keyword">while</span> (sibling !== <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">insertOrAppendPlacementNodeIntoContainer</span>(sibling, before, parent);
          sibling = sibling.<span class="hljs-property">sibling</span>;
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">insertOrAppendPlacementNode</span>(<span class="hljs-params">node, before, parent</span>) {
    <span class="hljs-keyword">var</span> tag = node.<span class="hljs-property">tag</span>;
    <span class="hljs-keyword">var</span> isHost = tag === <span class="hljs-title class_">HostComponent</span> || tag === <span class="hljs-title class_">HostText</span>;

    <span class="hljs-keyword">if</span> (isHost || enableFundamentalAPI) {
      <span class="hljs-keyword">var</span> stateNode = isHost ? node.<span class="hljs-property">stateNode</span> : node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">instance</span>;

      <span class="hljs-keyword">if</span> (before) {
        <span class="hljs-title function_">insertBefore</span>(parent, stateNode, before);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">appendChild</span>(parent, stateNode);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostPortal</span>); <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> child = node.<span class="hljs-property">child</span>;

      <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">insertOrAppendPlacementNode</span>(child, before, parent);
        <span class="hljs-keyword">var</span> sibling = child.<span class="hljs-property">sibling</span>;

        <span class="hljs-keyword">while</span> (sibling !== <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">insertOrAppendPlacementNode</span>(sibling, before, parent);
          sibling = sibling.<span class="hljs-property">sibling</span>;
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unmountHostComponents</span>(<span class="hljs-params">finishedRoot, current, renderPriorityLevel</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-974">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-974">&#x00a7;</a>
              </div>
              <p>We only have the top Fiber that was deleted but we need to recurse down its
children to find all the terminal nodes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> node = current; <span class="hljs-comment">// Each iteration, currentParent is populated with node&#x27;s host parent if not</span></pre></div></div>
            
        </li>
        
        
        <li id="section-975">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-975">&#x00a7;</a>
              </div>
              <p>currentParentIsValid.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> currentParentIsValid = <span class="hljs-literal">false</span>; <span class="hljs-comment">// Note: these two variables *must* always be updated together.</span>

    <span class="hljs-keyword">var</span> currentParent;
    <span class="hljs-keyword">var</span> currentParentIsContainer;

    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">if</span> (!currentParentIsValid) {
        <span class="hljs-keyword">var</span> parent = node.<span class="hljs-property">return</span>;

        <span class="hljs-attr">findParent</span>: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
          <span class="hljs-keyword">if</span> (!(parent !== <span class="hljs-literal">null</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
            }
          }

          <span class="hljs-keyword">var</span> parentStateNode = parent.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">switch</span> (parent.<span class="hljs-property">tag</span>) {
            <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
              currentParent = parentStateNode;
              currentParentIsContainer = <span class="hljs-literal">false</span>;
              <span class="hljs-keyword">break</span> findParent;

            <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
              currentParent = parentStateNode.<span class="hljs-property">containerInfo</span>;
              currentParentIsContainer = <span class="hljs-literal">true</span>;
              <span class="hljs-keyword">break</span> findParent;

            <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
              currentParent = parentStateNode.<span class="hljs-property">containerInfo</span>;
              currentParentIsContainer = <span class="hljs-literal">true</span>;
              <span class="hljs-keyword">break</span> findParent;

          }

          parent = parent.<span class="hljs-property">return</span>;
        }

        currentParentIsValid = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span> || node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostText</span>) {
        <span class="hljs-title function_">commitNestedUnmounts</span>(finishedRoot, node); <span class="hljs-comment">// After all the children have unmounted, it is now safe to remove the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-976">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-976">&#x00a7;</a>
              </div>
              <p>node from the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (currentParentIsContainer) {
          <span class="hljs-title function_">removeChildFromContainer</span>(currentParent, node.<span class="hljs-property">stateNode</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">removeChild</span>(currentParent, node.<span class="hljs-property">stateNode</span>);
        } <span class="hljs-comment">// Don&#x27;t visit children because we already visited them.</span>

      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">DehydratedFragment</span>) {


        <span class="hljs-keyword">if</span> (currentParentIsContainer) {
          <span class="hljs-title function_">clearSuspenseBoundaryFromContainer</span>(currentParent, node.<span class="hljs-property">stateNode</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">clearSuspenseBoundary</span>(currentParent, node.<span class="hljs-property">stateNode</span>);
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostPortal</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-977">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-977">&#x00a7;</a>
              </div>
              <p>When we go into a portal, it becomes the parent to remove from.
We will reassign it back when we pop the portal on the way up.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          currentParent = node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>;
          currentParentIsContainer = <span class="hljs-literal">true</span>; <span class="hljs-comment">// Visit children because portals might contain host components.</span>

          node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
          node = node.<span class="hljs-property">child</span>;
          <span class="hljs-keyword">continue</span>;
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">commitUnmount</span>(finishedRoot, node); <span class="hljs-comment">// Visit children because we may find more host components below.</span>

        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {
          node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
          node = node.<span class="hljs-property">child</span>;
          <span class="hljs-keyword">continue</span>;
        }
      }

      <span class="hljs-keyword">if</span> (node === current) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">return</span> === current) {
          <span class="hljs-keyword">return</span>;
        }

        node = node.<span class="hljs-property">return</span>;

        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostPortal</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-978">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-978">&#x00a7;</a>
              </div>
              <p>When we go out of the portal, we need to restore the parent.
Since we don’t keep a stack of them, we will search for it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          currentParentIsValid = <span class="hljs-literal">false</span>;
        }
      }

      node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
      node = node.<span class="hljs-property">sibling</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitDeletion</span>(<span class="hljs-params">finishedRoot, current, renderPriorityLevel</span>) {
    {</pre></div></div>
            
        </li>
        
        
        <li id="section-979">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-979">&#x00a7;</a>
              </div>
              <p>Recursively delete all host nodes from the parent.
Detach refs and call componentWillUnmount() on the whole subtree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">unmountHostComponents</span>(finishedRoot, current);
    }

    <span class="hljs-keyword">var</span> alternate = current.<span class="hljs-property">alternate</span>;
    <span class="hljs-title function_">detachFiberMutation</span>(current);

    <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">detachFiberMutation</span>(alternate);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitWork</span>(<span class="hljs-params">current, finishedWork</span>) {

    <span class="hljs-keyword">switch</span> (finishedWork.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Block</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-980">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-980">&#x00a7;</a>
              </div>
              <p>Layout effects are destroyed during the mutation phase so that all
destroy functions for all fibers are called before any create functions.
This prevents sibling component effects from interfering with each other,
e.g. a destroy function in one component should never override a ref set
by a create function in another component during the same commit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          {
            <span class="hljs-title function_">commitHookEffectListUnmount</span>(<span class="hljs-title class_">Layout</span> | <span class="hljs-title class_">HasEffect</span>, finishedWork);
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
        {
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        {
          <span class="hljs-keyword">var</span> instance = finishedWork.<span class="hljs-property">stateNode</span>;

          <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-981">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-981">&#x00a7;</a>
              </div>
              <p>Commit the work prepared earlier.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> newProps = finishedWork.<span class="hljs-property">memoizedProps</span>; <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span></pre></div></div>
            
        </li>
        
        
        <li id="section-982">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-982">&#x00a7;</a>
              </div>
              <p>as the newProps. The updatePayload will contain the real change in
this case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            <span class="hljs-keyword">var</span> oldProps = current !== <span class="hljs-literal">null</span> ? current.<span class="hljs-property">memoizedProps</span> : newProps;
            <span class="hljs-keyword">var</span> type = finishedWork.<span class="hljs-property">type</span>; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Type the updateQueue to be specific to host components.</span>

            <span class="hljs-keyword">var</span> updatePayload = finishedWork.<span class="hljs-property">updateQueue</span>;
            finishedWork.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;

            <span class="hljs-keyword">if</span> (updatePayload !== <span class="hljs-literal">null</span>) {
              <span class="hljs-title function_">commitUpdate</span>(instance, updatePayload, type, oldProps, newProps);
            }
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostText</span>:
        {
          <span class="hljs-keyword">if</span> (!(finishedWork.<span class="hljs-property">stateNode</span> !== <span class="hljs-literal">null</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
            }
          }

          <span class="hljs-keyword">var</span> textInstance = finishedWork.<span class="hljs-property">stateNode</span>;
          <span class="hljs-keyword">var</span> newText = finishedWork.<span class="hljs-property">memoizedProps</span>; <span class="hljs-comment">// For hydration we reuse the update path but we treat the oldProps</span></pre></div></div>
            
        </li>
        
        
        <li id="section-983">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-983">&#x00a7;</a>
              </div>
              <p>as the newProps. The updatePayload will contain the real change in
this case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">var</span> oldText = current !== <span class="hljs-literal">null</span> ? current.<span class="hljs-property">memoizedProps</span> : newText;
          <span class="hljs-title function_">commitTextUpdate</span>(textInstance, oldText, newText);
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        {
          {
            <span class="hljs-keyword">var</span> _root = finishedWork.<span class="hljs-property">stateNode</span>;

            <span class="hljs-keyword">if</span> (_root.<span class="hljs-property">hydrate</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-984">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-984">&#x00a7;</a>
              </div>
              <p>We’ve just hydrated. No need to hydrate again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              _root.<span class="hljs-property">hydrate</span> = <span class="hljs-literal">false</span>;
              <span class="hljs-title function_">commitHydratedContainer</span>(_root.<span class="hljs-property">containerInfo</span>);
            }
          }

          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">Profiler</span>:
        {
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        {
          <span class="hljs-title function_">commitSuspenseComponent</span>(finishedWork);
          <span class="hljs-title function_">attachSuspenseRetryListeners</span>(finishedWork);
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
        {
          <span class="hljs-title function_">attachSuspenseRetryListeners</span>(finishedWork);
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">IncompleteClassComponent</span>:
        {
          <span class="hljs-keyword">return</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">FundamentalComponent</span>:
        {

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">ScopeComponent</span>:
        {

          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">OffscreenComponent</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyHiddenComponent</span>:
        {
          <span class="hljs-keyword">var</span> newState = finishedWork.<span class="hljs-property">memoizedState</span>;
          <span class="hljs-keyword">var</span> isHidden = newState !== <span class="hljs-literal">null</span>;
          <span class="hljs-title function_">hideOrUnhideAllChildren</span>(finishedWork, isHidden);
          <span class="hljs-keyword">return</span>;
        }
    }

    {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitSuspenseComponent</span>(<span class="hljs-params">finishedWork</span>) {
    <span class="hljs-keyword">var</span> newState = finishedWork.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (newState !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">markCommitTimeOfFallback</span>();

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-985">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-985">&#x00a7;</a>
              </div>
              <p>Hide the Offscreen component that contains the primary children. TODO:
Ideally, this effect would have been scheduled on the Offscreen fiber
itself. That’s how unhiding works: the Offscreen component schedules an
effect on itself. However, in this case, the component didn’t complete,
so the fiber was never added to the effect list in the normal path. We
could have appended it to the effect list in the Suspense component’s
second pass, but doing it this way is less complicated. This would be
simpler if we got rid of the effect list and traversed the tree, like
we’re planning to do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> primaryChildParent = finishedWork.<span class="hljs-property">child</span>;
        <span class="hljs-title function_">hideOrUnhideAllChildren</span>(primaryChildParent, <span class="hljs-literal">true</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitSuspenseHydrationCallbacks</span>(<span class="hljs-params">finishedRoot, finishedWork</span>) {

    <span class="hljs-keyword">var</span> newState = finishedWork.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (newState === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> current = finishedWork.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> prevState = current.<span class="hljs-property">memoizedState</span>;

        <span class="hljs-keyword">if</span> (prevState !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> suspenseInstance = prevState.<span class="hljs-property">dehydrated</span>;

          <span class="hljs-keyword">if</span> (suspenseInstance !== <span class="hljs-literal">null</span>) {
            <span class="hljs-title function_">commitHydratedSuspenseInstance</span>(suspenseInstance);
          }
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attachSuspenseRetryListeners</span>(<span class="hljs-params">finishedWork</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-986">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-986">&#x00a7;</a>
              </div>
              <p>If this boundary just timed out, then it will have a set of wakeables.
For each wakeable, attach a listener so that when it resolves, React
attempts to re-render the boundary in the primary (pre-timeout) state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> wakeables = finishedWork.<span class="hljs-property">updateQueue</span>;

    <span class="hljs-keyword">if</span> (wakeables !== <span class="hljs-literal">null</span>) {
      finishedWork.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">var</span> retryCache = finishedWork.<span class="hljs-property">stateNode</span>;

      <span class="hljs-keyword">if</span> (retryCache === <span class="hljs-literal">null</span>) {
        retryCache = finishedWork.<span class="hljs-property">stateNode</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PossiblyWeakSet</span>();
      }

      wakeables.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">wakeable</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-987">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-987">&#x00a7;</a>
              </div>
              <p>Memoize using the boundary fiber to prevent redundant listeners.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> retry = resolveRetryWakeable.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, finishedWork, wakeable);

        <span class="hljs-keyword">if</span> (!retryCache.<span class="hljs-title function_">has</span>(wakeable)) {
          {
            <span class="hljs-keyword">if</span> (wakeable.<span class="hljs-property">__reactDoNotTraceInteractions</span> !== <span class="hljs-literal">true</span>) {
              retry = <span class="hljs-title function_">unstable_wrap</span>(retry);
            }
          }

          retryCache.<span class="hljs-title function_">add</span>(wakeable);
          wakeable.<span class="hljs-title function_">then</span>(retry, retry);
        }
      });
    }
  } <span class="hljs-comment">// This function detects when a Suspense boundary goes from visible to hidden.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-988">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-988">&#x00a7;</a>
              </div>
              <p>It returns false if the boundary is already hidden.
TODO: Use an effect tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isSuspenseBoundaryBeingHidden</span>(<span class="hljs-params">current, finishedWork</span>) {
    <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> oldState = current.<span class="hljs-property">memoizedState</span>;

      <span class="hljs-keyword">if</span> (oldState === <span class="hljs-literal">null</span> || oldState.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> newState = finishedWork.<span class="hljs-property">memoizedState</span>;
        <span class="hljs-keyword">return</span> newState !== <span class="hljs-literal">null</span> &amp;&amp; newState.<span class="hljs-property">dehydrated</span> === <span class="hljs-literal">null</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitResetTextContent</span>(<span class="hljs-params">current</span>) {

    <span class="hljs-title function_">resetTextContent</span>(current.<span class="hljs-property">stateNode</span>);
  }

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">COMPONENT_TYPE</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">HAS_PSEUDO_CLASS_TYPE</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">ROLE_TYPE</span> = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">TEST_NAME_TYPE</span> = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">TEXT_TYPE</span> = <span class="hljs-number">4</span>;

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Symbol</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">for</span>) {
    <span class="hljs-keyword">var</span> symbolFor$<span class="hljs-number">1</span> = <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">for</span>;
    <span class="hljs-variable constant_">COMPONENT_TYPE</span> = <span class="hljs-title function_">symbolFor$1</span>(<span class="hljs-string">&#x27;selector.component&#x27;</span>);
    <span class="hljs-variable constant_">HAS_PSEUDO_CLASS_TYPE</span> = <span class="hljs-title function_">symbolFor$1</span>(<span class="hljs-string">&#x27;selector.has_pseudo_class&#x27;</span>);
    <span class="hljs-variable constant_">ROLE_TYPE</span> = <span class="hljs-title function_">symbolFor$1</span>(<span class="hljs-string">&#x27;selector.role&#x27;</span>);
    <span class="hljs-variable constant_">TEST_NAME_TYPE</span> = <span class="hljs-title function_">symbolFor$1</span>(<span class="hljs-string">&#x27;selector.test_id&#x27;</span>);
    <span class="hljs-variable constant_">TEXT_TYPE</span> = <span class="hljs-title function_">symbolFor$1</span>(<span class="hljs-string">&#x27;selector.text&#x27;</span>);
  }
  <span class="hljs-keyword">var</span> commitHooks = [];
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onCommitRoot$1</span>(<span class="hljs-params"></span>) {
    {
      commitHooks.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">commitHook</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">commitHook</span>();
      });
    }
  }

  <span class="hljs-keyword">var</span> ceil = <span class="hljs-title class_">Math</span>.<span class="hljs-property">ceil</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">2</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentDispatcher</span>,
    <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">2</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentOwner</span>,
    <span class="hljs-title class_">IsSomeRendererActing</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">IsSomeRendererActing</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">NoContext</span> =
    <span class="hljs-comment">/*             */</span>
    <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">BatchedContext</span> =
    <span class="hljs-comment">/*               */</span>
    <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">EventContext</span> =
    <span class="hljs-comment">/*                 */</span>
    <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">DiscreteEventContext</span> =
    <span class="hljs-comment">/*         */</span>
    <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">LegacyUnbatchedContext</span> =
    <span class="hljs-comment">/*       */</span>
    <span class="hljs-number">8</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RenderContext</span> =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">16</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">CommitContext</span> =
    <span class="hljs-comment">/*                */</span>
    <span class="hljs-number">32</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RetryAfterError</span> =
    <span class="hljs-comment">/*       */</span>
    <span class="hljs-number">64</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RootIncomplete</span> = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RootFatalErrored</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RootErrored</span> = <span class="hljs-number">2</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RootSuspended</span> = <span class="hljs-number">3</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RootSuspendedWithDelay</span> = <span class="hljs-number">4</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-title class_">RootCompleted</span> = <span class="hljs-number">5</span>; <span class="hljs-comment">// Describes where we are in the React execution stack</span>

  <span class="hljs-keyword">var</span> executionContext = <span class="hljs-title class_">NoContext</span>; <span class="hljs-comment">// The root we&#x27;re working on</span>

  <span class="hljs-keyword">var</span> workInProgressRoot = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The fiber we&#x27;re working on</span>

  <span class="hljs-keyword">var</span> workInProgress = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The lanes we&#x27;re rendering</span>

  <span class="hljs-keyword">var</span> workInProgressRootRenderLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// Stack that allows components to change the render lanes for its subtree</span></pre></div></div>
            
        </li>
        
        
        <li id="section-989">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-989">&#x00a7;</a>
              </div>
              <p>This is a superset of the lanes we started working on at the root. The only
case where it’s different from <code>workInProgressRootRenderLanes</code> is when we
enter a subtree that is hidden and needs to be unhidden: Suspense and
Offscreen component.</p>
<p>Most things in the work loop should deal with workInProgressRootRenderLanes.
Most things in begin/complete phases should deal with subtreeRenderLanes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> subtreeRenderLanes = <span class="hljs-title class_">NoLanes</span>;
  <span class="hljs-keyword">var</span> subtreeRenderLanesCursor = <span class="hljs-title function_">createCursor</span>(<span class="hljs-title class_">NoLanes</span>); <span class="hljs-comment">// Whether to root completed, errored, suspended, etc.</span>

  <span class="hljs-keyword">var</span> workInProgressRootExitStatus = <span class="hljs-title class_">RootIncomplete</span>; <span class="hljs-comment">// A fatal error, if one is thrown</span>

  <span class="hljs-keyword">var</span> workInProgressRootFatalError = <span class="hljs-literal">null</span>; <span class="hljs-comment">// &quot;Included&quot; lanes refer to lanes that were worked on during this render. It&#x27;s</span></pre></div></div>
            
        </li>
        
        
        <li id="section-990">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-990">&#x00a7;</a>
              </div>
              <p>slightly different than <code>renderLanes</code> because <code>renderLanes</code> can change as you
enter and exit an Offscreen tree. This value is the combination of all render
lanes for the entire render phase.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> workInProgressRootIncludedLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// The work left over by components that were visited during this render. Only</span></pre></div></div>
            
        </li>
        
        
        <li id="section-991">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-991">&#x00a7;</a>
              </div>
              <p>includes unprocessed updates, not work in bailed out children.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> workInProgressRootSkippedLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// Lanes that were updated (in an interleaved event) during this render.</span>

  <span class="hljs-keyword">var</span> workInProgressRootUpdatedLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// Lanes that were pinged (in an interleaved event) during this render.</span>

  <span class="hljs-keyword">var</span> workInProgressRootPingedLanes = <span class="hljs-title class_">NoLanes</span>;
  <span class="hljs-keyword">var</span> mostRecentlyUpdatedRoot = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The most recent time we committed a fallback. This lets us ensure a train</span></pre></div></div>
            
        </li>
        
        
        <li id="section-992">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-992">&#x00a7;</a>
              </div>
              <p>model where we don’t commit new loading states in too quick succession.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> globalMostRecentFallbackTime = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">FALLBACK_THROTTLE_MS</span> = <span class="hljs-number">500</span>; <span class="hljs-comment">// The absolute time for when we should start giving up on rendering</span></pre></div></div>
            
        </li>
        
        
        <li id="section-993">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-993">&#x00a7;</a>
              </div>
              <p>more and prefer CPU suspense heuristics instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> workInProgressRootRenderTargetTime = <span class="hljs-title class_">Infinity</span>; <span class="hljs-comment">// How long a render is supposed to take before we start following CPU</span></pre></div></div>
            
        </li>
        
        
        <li id="section-994">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-994">&#x00a7;</a>
              </div>
              <p>suspense heuristics and opt out of rendering more content.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">RENDER_TIMEOUT_MS</span> = <span class="hljs-number">500</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetRenderTimer</span>(<span class="hljs-params"></span>) {
    workInProgressRootRenderTargetTime = <span class="hljs-title function_">now</span>() + <span class="hljs-variable constant_">RENDER_TIMEOUT_MS</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getRenderTargetTime</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> workInProgressRootRenderTargetTime;
  }
  <span class="hljs-keyword">var</span> nextEffect = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> hasUncaughtError = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> firstUncaughtError = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> legacyErrorBoundariesThatAlreadyFailed = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> rootDoesHavePassiveEffects = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> rootWithPendingPassiveEffects = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> pendingPassiveEffectsRenderPriority = <span class="hljs-title class_">NoPriority</span>$<span class="hljs-number">1</span>;
  <span class="hljs-keyword">var</span> pendingPassiveEffectsLanes = <span class="hljs-title class_">NoLanes</span>;
  <span class="hljs-keyword">var</span> pendingPassiveHookEffectsMount = [];
  <span class="hljs-keyword">var</span> pendingPassiveHookEffectsUnmount = [];
  <span class="hljs-keyword">var</span> rootsWithPendingDiscreteUpdates = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Use these to prevent an infinite loop of nested updates</span>

  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NESTED_UPDATE_LIMIT</span> = <span class="hljs-number">50</span>;
  <span class="hljs-keyword">var</span> nestedUpdateCount = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">var</span> rootWithNestedUpdates = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> <span class="hljs-variable constant_">NESTED_PASSIVE_UPDATE_LIMIT</span> = <span class="hljs-number">50</span>;
  <span class="hljs-keyword">var</span> nestedPassiveUpdateCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// Marks the need to reschedule pending interactions at these lanes</span></pre></div></div>
            
        </li>
        
        
        <li id="section-995">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-995">&#x00a7;</a>
              </div>
              <p>during the commit phase. This enables them to be traced across components
that spawn new work during render. E.g. hidden boundaries, suspended SSR
hydration or SuspenseList.
TODO: Can use a bitmask instead of an array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> spawnedWorkDuringRender = <span class="hljs-literal">null</span>; <span class="hljs-comment">// If two updates are scheduled within the same event, we should treat their</span></pre></div></div>
            
        </li>
        
        
        <li id="section-996">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-996">&#x00a7;</a>
              </div>
              <p>event times as simultaneous, even if the actual clock time has advanced
between the first and second call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> currentEventTime = <span class="hljs-title class_">NoTimestamp</span>;
  <span class="hljs-keyword">var</span> currentEventWipLanes = <span class="hljs-title class_">NoLanes</span>;
  <span class="hljs-keyword">var</span> currentEventPendingLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// Dev only flag that tracks if passive effects are currently being flushed.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-997">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-997">&#x00a7;</a>
              </div>
              <p>We warn about state updates for unmounted components differently in this case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">var</span> isFlushingPassiveEffects = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> focusedInstanceHandle = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> shouldFireAfterActiveInstanceBlur = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getWorkInProgressRoot</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> workInProgressRoot;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">requestEventTime</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> ((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) !== <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-998">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-998">&#x00a7;</a>
              </div>
              <p>We’re inside React, so it’s fine to read the actual time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">now</span>();
    } <span class="hljs-comment">// We&#x27;re not inside React, so we may be in the middle of a browser event.</span>


    <span class="hljs-keyword">if</span> (currentEventTime !== <span class="hljs-title class_">NoTimestamp</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-999">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-999">&#x00a7;</a>
              </div>
              <p>Use the same start time for all updates until we enter React again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> currentEventTime;
    } <span class="hljs-comment">// This is the first update since React yielded. Compute a new start time.</span>


    currentEventTime = <span class="hljs-title function_">now</span>();
    <span class="hljs-keyword">return</span> currentEventTime;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">requestUpdateLane</span>(<span class="hljs-params">fiber</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1000">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1000">&#x00a7;</a>
              </div>
              <p>Special cases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> mode = fiber.<span class="hljs-property">mode</span>;

    <span class="hljs-keyword">if</span> ((mode &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLane</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode &amp; <span class="hljs-title class_">ConcurrentMode</span>) === <span class="hljs-title class_">NoMode</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getCurrentPriorityLevel</span>() === <span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span> ? <span class="hljs-title class_">SyncLane</span> : <span class="hljs-title class_">SyncBatchedLane</span>;
    } <span class="hljs-comment">// The algorithm for assigning an update to a lane should be stable for all</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1001">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1001">&#x00a7;</a>
              </div>
              <p>updates at the same priority within the same event. To do this, the inputs
to the algorithm must be the same. For example, we use the <code>renderLanes</code>
to avoid choosing a lane that is already in the middle of rendering.</p>
<p>However, the “included” lanes could be mutated in between updates in the
same event, like if you perform an update inside <code>flushSync</code>. Or any other
code path that might call <code>prepareFreshStack</code>.</p>
<p>The trick we use is to cache the first of each of these inputs within an
event. Then reset the cached values once we can be sure the event is over.
Our heuristic for that is whenever we enter a concurrent work loop.</p>
<p>We’ll do the same for <code>currentEventPendingLanes</code> below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (currentEventWipLanes === <span class="hljs-title class_">NoLanes</span>) {
      currentEventWipLanes = workInProgressRootIncludedLanes;
    }

    <span class="hljs-keyword">var</span> isTransition = <span class="hljs-title function_">requestCurrentTransition</span>() !== <span class="hljs-title class_">NoTransition</span>;

    <span class="hljs-keyword">if</span> (isTransition) {
      <span class="hljs-keyword">if</span> (currentEventPendingLanes !== <span class="hljs-title class_">NoLanes</span>) {
        currentEventPendingLanes = mostRecentlyUpdatedRoot !== <span class="hljs-literal">null</span> ? mostRecentlyUpdatedRoot.<span class="hljs-property">pendingLanes</span> : <span class="hljs-title class_">NoLanes</span>;
      }

      <span class="hljs-keyword">return</span> <span class="hljs-title function_">findTransitionLane</span>(currentEventWipLanes, currentEventPendingLanes);
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Remove this dependency on the Scheduler priority.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1002">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1002">&#x00a7;</a>
              </div>
              <p>To do that, we’re replacing it with an update lane priority.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> schedulerPriority = <span class="hljs-title function_">getCurrentPriorityLevel</span>(); <span class="hljs-comment">// The old behavior was using the priority level of the Scheduler.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1003">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1003">&#x00a7;</a>
              </div>
              <p>This couples React to the Scheduler internals, so we’re replacing it
with the currentUpdateLanePriority above. As an example of how this
could be problematic, if we’re not inside <code>Scheduler.runWithPriority</code>,
then we’ll get the priority of the current running Scheduler task,
which is probably not what we want.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> lane;

    <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Temporary. We&#x27;re removing the concept of discrete updates.</span>
      (executionContext &amp; <span class="hljs-title class_">DiscreteEventContext</span>) !== <span class="hljs-title class_">NoContext</span> &amp;&amp; schedulerPriority === <span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">2</span>) {
      lane = <span class="hljs-title function_">findUpdateLane</span>(<span class="hljs-title class_">InputDiscreteLanePriority</span>, currentEventWipLanes);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> schedulerLanePriority = <span class="hljs-title function_">schedulerPriorityToLanePriority</span>(schedulerPriority);

      lane = <span class="hljs-title function_">findUpdateLane</span>(schedulerLanePriority, currentEventWipLanes);
    }

    <span class="hljs-keyword">return</span> lane;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">requestRetryLane</span>(<span class="hljs-params">fiber</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1004">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1004">&#x00a7;</a>
              </div>
              <p>This is a fork of <code>requestUpdateLane</code> designed specifically for Suspense
“retries” — a special update that attempts to flip a Suspense boundary
from its placeholder state to its primary/resolved state.
Special cases</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> mode = fiber.<span class="hljs-property">mode</span>;

    <span class="hljs-keyword">if</span> ((mode &amp; <span class="hljs-title class_">BlockingMode</span>) === <span class="hljs-title class_">NoMode</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">SyncLane</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mode &amp; <span class="hljs-title class_">ConcurrentMode</span>) === <span class="hljs-title class_">NoMode</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">getCurrentPriorityLevel</span>() === <span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span> ? <span class="hljs-title class_">SyncLane</span> : <span class="hljs-title class_">SyncBatchedLane</span>;
    } <span class="hljs-comment">// See `requestUpdateLane` for explanation of `currentEventWipLanes`</span>


    <span class="hljs-keyword">if</span> (currentEventWipLanes === <span class="hljs-title class_">NoLanes</span>) {
      currentEventWipLanes = workInProgressRootIncludedLanes;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">findRetryLane</span>(currentEventWipLanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(<span class="hljs-params">fiber, lane, eventTime</span>) {
    <span class="hljs-title function_">checkForNestedUpdates</span>();
    <span class="hljs-title function_">warnAboutRenderPhaseUpdatesInDEV</span>(fiber);
    <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">markUpdateLaneFromFiberToRoot</span>(fiber, lane);

    <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">warnAboutUpdateOnUnmountedFiberInDEV</span>(fiber);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// Mark that the root has a pending update.</span>


    <span class="hljs-title function_">markRootUpdated</span>(root, lane, eventTime);

    <span class="hljs-keyword">if</span> (root === workInProgressRoot) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1005">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1005">&#x00a7;</a>
              </div>
              <p>Received an update to a tree that’s in the middle of rendering. Mark
that there was an interleaved update work on this root. Unless the
<code>deferRenderPhaseUpdateToNextBatch</code> flag is off and this is a render
phase update. In that case, we don’t treat render phase updates as if
they were interleaved, for backwards compat reasons.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        workInProgressRootUpdatedLanes = <span class="hljs-title function_">mergeLanes</span>(workInProgressRootUpdatedLanes, lane);
      }

      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootSuspendedWithDelay</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1006">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1006">&#x00a7;</a>
              </div>
              <p>The root already suspended with a delay, which means this render
definitely won’t finish. Since we have a new update, let’s mark it as
suspended now, right before marking the incoming update. This has the
effect of interrupting the current render and switching to the update.
TODO: Make sure this doesn’t override pings that happen while we’ve
already started rendering.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">markRootSuspended$1</span>(root, workInProgressRootRenderLanes);
      }
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> requestUpdateLanePriority also reads the priority. Pass the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1007">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1007">&#x00a7;</a>
              </div>
              <p>priority as an argument to that function and this one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> priorityLevel = <span class="hljs-title function_">getCurrentPriorityLevel</span>();

    <span class="hljs-keyword">if</span> (lane === <span class="hljs-title class_">SyncLane</span>) {
      <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// Check if we&#x27;re inside unbatchedUpdates</span>
        (executionContext &amp; <span class="hljs-title class_">LegacyUnbatchedContext</span>) !== <span class="hljs-title class_">NoContext</span> &amp;&amp; <span class="hljs-comment">// Check if we&#x27;re not already rendering</span>
        (executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1008">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1008">&#x00a7;</a>
              </div>
              <p>Register pending interactions on the root to avoid losing traced interaction data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">schedulePendingInteractions</span>(root, lane); <span class="hljs-comment">// This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1009">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1009">&#x00a7;</a>
              </div>
              <p>root inside of batchedUpdates should be synchronous, but layout updates
should be deferred until the end of the batch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">performSyncWorkOnRoot</span>(root);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);
        <span class="hljs-title function_">schedulePendingInteractions</span>(root, lane);

        <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1010">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1010">&#x00a7;</a>
              </div>
              <p>Flush the synchronous work now, unless we’re already working or inside
a batch. This is intentionally inside scheduleUpdateOnFiber instead of
scheduleCallbackForFiber to preserve the ability to schedule a callback
without immediately flushing it. We only do this for user-initiated
updates, to preserve historical behavior of legacy mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">resetRenderTimer</span>();
          <span class="hljs-title function_">flushSyncCallbackQueue</span>();
        }
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1011">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1011">&#x00a7;</a>
              </div>
              <p>Schedule a discrete update but only if it’s not Sync.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> ((executionContext &amp; <span class="hljs-title class_">DiscreteEventContext</span>) !== <span class="hljs-title class_">NoContext</span> &amp;&amp; ( <span class="hljs-comment">// Only updates at user-blocking priority or greater are considered</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1012">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1012">&#x00a7;</a>
              </div>
              <p>discrete, even inside a discrete event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        priorityLevel === <span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">2</span> || priorityLevel === <span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1013">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1013">&#x00a7;</a>
              </div>
              <p>This is the result of a discrete event. Track the lowest priority
discrete update per root so we can flush them early, if needed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (rootsWithPendingDiscreteUpdates === <span class="hljs-literal">null</span>) {
          rootsWithPendingDiscreteUpdates = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([root]);
        } <span class="hljs-keyword">else</span> {
          rootsWithPendingDiscreteUpdates.<span class="hljs-title function_">add</span>(root);
        }
      } <span class="hljs-comment">// Schedule other updates after in case the callback is sync.</span>


      <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);
      <span class="hljs-title function_">schedulePendingInteractions</span>(root, lane);
    } <span class="hljs-comment">// We use this when assigning a lane for a transition inside</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1014">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1014">&#x00a7;</a>
              </div>
              <p><code>requestUpdateLane</code>. We assume it’s the same as the root being updated,
since in the common case of a single root app it probably is. If it’s not
the same root, then it’s not a huge deal, we just might batch more stuff
together more than necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    mostRecentlyUpdatedRoot = root;
  } <span class="hljs-comment">// This is split into a separate function so we can mark a fiber with pending</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1015">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1015">&#x00a7;</a>
              </div>
              <p>work without treating it as a typical update that originates from an event;
e.g. retrying a Suspense boundary isn’t an update, but it does schedule work
on a fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markUpdateLaneFromFiberToRoot</span>(<span class="hljs-params">sourceFiber, lane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1016">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1016">&#x00a7;</a>
              </div>
              <p>Update the source fiber’s lanes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sourceFiber.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(sourceFiber.<span class="hljs-property">lanes</span>, lane);
    <span class="hljs-keyword">var</span> alternate = sourceFiber.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
      alternate.<span class="hljs-property">lanes</span> = <span class="hljs-title function_">mergeLanes</span>(alternate.<span class="hljs-property">lanes</span>, lane);
    }

    {
      <span class="hljs-keyword">if</span> (alternate === <span class="hljs-literal">null</span> &amp;&amp; (sourceFiber.<span class="hljs-property">flags</span> &amp; (<span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">Hydrating</span>)) !== <span class="hljs-title class_">NoFlags</span>) {
        <span class="hljs-title function_">warnAboutUpdateOnNotYetMountedFiberInDEV</span>(sourceFiber);
      }
    } <span class="hljs-comment">// Walk the parent path to the root and update the child expiration time.</span>


    <span class="hljs-keyword">var</span> node = sourceFiber;
    <span class="hljs-keyword">var</span> parent = sourceFiber.<span class="hljs-property">return</span>;

    <span class="hljs-keyword">while</span> (parent !== <span class="hljs-literal">null</span>) {
      parent.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">mergeLanes</span>(parent.<span class="hljs-property">childLanes</span>, lane);
      alternate = parent.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
        alternate.<span class="hljs-property">childLanes</span> = <span class="hljs-title function_">mergeLanes</span>(alternate.<span class="hljs-property">childLanes</span>, lane);
      } <span class="hljs-keyword">else</span> {
        {
          <span class="hljs-keyword">if</span> ((parent.<span class="hljs-property">flags</span> &amp; (<span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">Hydrating</span>)) !== <span class="hljs-title class_">NoFlags</span>) {
            <span class="hljs-title function_">warnAboutUpdateOnNotYetMountedFiberInDEV</span>(sourceFiber);
          }
        }
      }

      node = parent;
      parent = parent.<span class="hljs-property">return</span>;
    }

    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>) {
      <span class="hljs-keyword">var</span> root = node.<span class="hljs-property">stateNode</span>;
      <span class="hljs-keyword">return</span> root;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  } <span class="hljs-comment">// Use this function to schedule a task for a root. There&#x27;s only one task per</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1017">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1017">&#x00a7;</a>
              </div>
              <p>root; if a task was already scheduled, we’ll check to make sure the priority
of the existing task is the same as the priority of the next level that the
root has work on. This function is called on every update, and right before
exiting a task.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureRootIsScheduled</span>(<span class="hljs-params">root, currentTime</span>) {
    <span class="hljs-keyword">var</span> existingCallbackNode = root.<span class="hljs-property">callbackNode</span>; <span class="hljs-comment">// Check if any lanes are being starved by other work. If so, mark them as</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1018">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1018">&#x00a7;</a>
              </div>
              <p>expired so we know to work on those next.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title function_">markStarvedLanesAsExpired</span>(root, currentTime); <span class="hljs-comment">// Determine the next lanes to work on, and their priority.</span>

    <span class="hljs-keyword">var</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(root, root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="hljs-title class_">NoLanes</span>); <span class="hljs-comment">// This returns the priority level computed during the `getNextLanes` call.</span>

    <span class="hljs-keyword">var</span> newCallbackPriority = <span class="hljs-title function_">returnNextLanesPriority</span>();

    <span class="hljs-keyword">if</span> (nextLanes === <span class="hljs-title class_">NoLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1019">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1019">&#x00a7;</a>
              </div>
              <p>Special case: There’s nothing to work on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);
        root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;
        root.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoLanePriority</span>;
      }

      <span class="hljs-keyword">return</span>;
    } <span class="hljs-comment">// Check if there&#x27;s an existing task. We may be able to reuse it.</span>


    <span class="hljs-keyword">if</span> (existingCallbackNode !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> existingCallbackPriority = root.<span class="hljs-property">callbackPriority</span>;

      <span class="hljs-keyword">if</span> (existingCallbackPriority === newCallbackPriority) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1020">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1020">&#x00a7;</a>
              </div>
              <p>The priority hasn’t changed. We can reuse the existing task. Exit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// The priority changed. Cancel the existing callback. We&#x27;ll schedule a new</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1021">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1021">&#x00a7;</a>
              </div>
              <p>one below.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-title function_">cancelCallback</span>(existingCallbackNode);
    } <span class="hljs-comment">// Schedule a new callback.</span>


    <span class="hljs-keyword">var</span> newCallbackNode;

    <span class="hljs-keyword">if</span> (newCallbackPriority === <span class="hljs-title class_">SyncLanePriority</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1022">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1022">&#x00a7;</a>
              </div>
              <p>Special case: Sync React callbacks are scheduled on a special
internal queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      newCallbackNode = <span class="hljs-title function_">scheduleSyncCallback</span>(performSyncWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root));
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newCallbackPriority === <span class="hljs-title class_">SyncBatchedLanePriority</span>) {
      newCallbackNode = <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, performSyncWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root));
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> schedulerPriorityLevel = <span class="hljs-title function_">lanePriorityToSchedulerPriority</span>(newCallbackPriority);
      newCallbackNode = <span class="hljs-title function_">scheduleCallback</span>(schedulerPriorityLevel, performConcurrentWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root));
    }

    root.<span class="hljs-property">callbackPriority</span> = newCallbackPriority;
    root.<span class="hljs-property">callbackNode</span> = newCallbackNode;
  } <span class="hljs-comment">// This is the entry point for every concurrent task, i.e. anything that</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1023">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1023">&#x00a7;</a>
              </div>
              <p>goes through Scheduler.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">performConcurrentWorkOnRoot</span>(<span class="hljs-params">root</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1024">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1024">&#x00a7;</a>
              </div>
              <p>Since we know we’re in a React event, we can clear the current
event time. The next update will compute a new event time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    currentEventTime = <span class="hljs-title class_">NoTimestamp</span>;
    currentEventWipLanes = <span class="hljs-title class_">NoLanes</span>;
    currentEventPendingLanes = <span class="hljs-title class_">NoLanes</span>;

    <span class="hljs-keyword">if</span> (!((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should not already be working.&quot;</span>);
      }
    } <span class="hljs-comment">// Flush any pending passive effects before deciding which lanes to work on,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1025">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1025">&#x00a7;</a>
              </div>
              <p>in case they schedule additional work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> originalCallbackNode = root.<span class="hljs-property">callbackNode</span>;
    <span class="hljs-keyword">var</span> didFlushPassiveEffects = <span class="hljs-title function_">flushPassiveEffects</span>();

    <span class="hljs-keyword">if</span> (didFlushPassiveEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1026">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1026">&#x00a7;</a>
              </div>
              <p>Something in the passive effect phase may have canceled the current task.
Check if the task node for this root was changed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (root.<span class="hljs-property">callbackNode</span> !== originalCallbackNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1027">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1027">&#x00a7;</a>
              </div>
              <p>The current task was canceled. Exit. We don’t need to call
<code>ensureRootIsScheduled</code> because the check above implies either that
there’s a new task, or that there’s no remaining work on this root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    } <span class="hljs-comment">// Determine the next expiration time to work on, using the fields stored</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1028">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1028">&#x00a7;</a>
              </div>
              <p>on the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> lanes = <span class="hljs-title function_">getNextLanes</span>(root, root === workInProgressRoot ? workInProgressRootRenderLanes : <span class="hljs-title class_">NoLanes</span>);

    <span class="hljs-keyword">if</span> (lanes === <span class="hljs-title class_">NoLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1029">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1029">&#x00a7;</a>
              </div>
              <p>Defensive coding. This is never expected to happen.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">var</span> exitStatus = <span class="hljs-title function_">renderRootConcurrent</span>(root, lanes);

    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesSomeLane</span>(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1030">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1030">&#x00a7;</a>
              </div>
              <p>The render included lanes that were updated during the render phase.
For example, when unhiding a hidden tree, we include all the lanes
that were previously skipped when the tree was hidden. That set of
lanes is a superset of the lanes we started rendering with.</p>
<p>So we’ll throw out the current work and restart.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">prepareFreshStack</span>(root, <span class="hljs-title class_">NoLanes</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exitStatus !== <span class="hljs-title class_">RootIncomplete</span>) {
      <span class="hljs-keyword">if</span> (exitStatus === <span class="hljs-title class_">RootErrored</span>) {
        executionContext |= <span class="hljs-title class_">RetryAfterError</span>; <span class="hljs-comment">// If an error occurred during hydration,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1031">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1031">&#x00a7;</a>
              </div>
              <p>discard server response and fall back to client side render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">if</span> (root.<span class="hljs-property">hydrate</span>) {
          root.<span class="hljs-property">hydrate</span> = <span class="hljs-literal">false</span>;
          <span class="hljs-title function_">clearContainer</span>(root.<span class="hljs-property">containerInfo</span>);
        } <span class="hljs-comment">// If something threw an error, try rendering one more time. We&#x27;ll render</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1032">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1032">&#x00a7;</a>
              </div>
              <p>synchronously to block concurrent data mutations, and we’ll includes
all pending updates are included. If it still fails after the second
attempt, we’ll give up and commit the resulting tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        lanes = <span class="hljs-title function_">getLanesToRetrySynchronouslyOnError</span>(root);

        <span class="hljs-keyword">if</span> (lanes !== <span class="hljs-title class_">NoLanes</span>) {
          exitStatus = <span class="hljs-title function_">renderRootSync</span>(root, lanes);
        }
      }

      <span class="hljs-keyword">if</span> (exitStatus === <span class="hljs-title class_">RootFatalErrored</span>) {
        <span class="hljs-keyword">var</span> fatalError = workInProgressRootFatalError;
        <span class="hljs-title function_">prepareFreshStack</span>(root, <span class="hljs-title class_">NoLanes</span>);
        <span class="hljs-title function_">markRootSuspended$1</span>(root, lanes);
        <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());
        <span class="hljs-keyword">throw</span> fatalError;
      } <span class="hljs-comment">// We now have a consistent tree. The next step is either to commit it,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1033">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1033">&#x00a7;</a>
              </div>
              <p>or, if something suspended, wait to commit it after a timeout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> finishedWork = root.<span class="hljs-property">current</span>.<span class="hljs-property">alternate</span>;
      root.<span class="hljs-property">finishedWork</span> = finishedWork;
      root.<span class="hljs-property">finishedLanes</span> = lanes;
      <span class="hljs-title function_">finishConcurrentRender</span>(root, exitStatus, lanes);
    }

    <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());

    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">callbackNode</span> === originalCallbackNode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1034">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1034">&#x00a7;</a>
              </div>
              <p>The task node scheduled for this root is the same one that’s
currently executed. Need to return a continuation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> performConcurrentWorkOnRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">finishConcurrentRender</span>(<span class="hljs-params">root, exitStatus, lanes</span>) {
    <span class="hljs-keyword">switch</span> (exitStatus) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RootIncomplete</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RootFatalErrored</span>:
        {
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Root did not complete. This is a bug in React.&quot;</span>);
            }
          }
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-1035">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1035">&#x00a7;</a>
              </div>
              <p>Flow knows about invariant, so it complains if I add a break
statement, but eslint doesn’t know about invariant, so it complains
if I do. eslint-disable-next-line no-fallthrough</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RootErrored</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-1036">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1036">&#x00a7;</a>
              </div>
              <p>We should have already attempted to retry this tree. If we reached
this point, it errored again. Commit it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">commitRoot</span>(root);
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RootSuspended</span>:
        {
          <span class="hljs-title function_">markRootSuspended$1</span>(root, lanes); <span class="hljs-comment">// We have an acceptable loading state. We need to figure out if we</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1037">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1037">&#x00a7;</a>
              </div>
              <p>should immediately commit it or wait a bit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesOnlyRetries</span>(lanes) &amp;&amp; <span class="hljs-comment">// do not delay if we&#x27;re inside an act() scope</span>
            !<span class="hljs-title function_">shouldForceFlushFallbacksInDEV</span>()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1038">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1038">&#x00a7;</a>
              </div>
              <p>This render only included retries, no updates. Throttle committing
retries so that we don’t show too many loading states too quickly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> msUntilTimeout = globalMostRecentFallbackTime + <span class="hljs-variable constant_">FALLBACK_THROTTLE_MS</span> - <span class="hljs-title function_">now</span>(); <span class="hljs-comment">// Don&#x27;t bother with a very short suspense time.</span>

            <span class="hljs-keyword">if</span> (msUntilTimeout &gt; <span class="hljs-number">10</span>) {
              <span class="hljs-keyword">var</span> nextLanes = <span class="hljs-title function_">getNextLanes</span>(root, <span class="hljs-title class_">NoLanes</span>);

              <span class="hljs-keyword">if</span> (nextLanes !== <span class="hljs-title class_">NoLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1039">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1039">&#x00a7;</a>
              </div>
              <p>There’s additional work on this root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">break</span>;
              }

              <span class="hljs-keyword">var</span> suspendedLanes = root.<span class="hljs-property">suspendedLanes</span>;

              <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isSubsetOfLanes</span>(suspendedLanes, lanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1040">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1040">&#x00a7;</a>
              </div>
              <p>We should prefer to render the fallback of at the last
suspended level. Ping the last suspended level to try
rendering it again.
FIXME: What if the suspended lanes are Idle? Should not restart.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
                <span class="hljs-title function_">markRootPinged</span>(root, suspendedLanes);
                <span class="hljs-keyword">break</span>;
              } <span class="hljs-comment">// The render is suspended, it hasn&#x27;t timed out, and there&#x27;s no</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1041">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1041">&#x00a7;</a>
              </div>
              <p>lower priority work to do. Instead of committing the fallback
immediately, wait for more data to arrive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

              root.<span class="hljs-property">timeoutHandle</span> = <span class="hljs-title function_">scheduleTimeout</span>(commitRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root), msUntilTimeout);
              <span class="hljs-keyword">break</span>;
            }
          } <span class="hljs-comment">// The work expired. Commit immediately.</span>


          <span class="hljs-title function_">commitRoot</span>(root);
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RootSuspendedWithDelay</span>:
        {
          <span class="hljs-title function_">markRootSuspended$1</span>(root, lanes);

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesOnlyTransitions</span>(lanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1042">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1042">&#x00a7;</a>
              </div>
              <p>This is a transition, so we should exit without committing a
placeholder and without scheduling a timeout. Delay indefinitely
until we receive more data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">break</span>;
          }

          <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">shouldForceFlushFallbacksInDEV</span>()) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1043">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1043">&#x00a7;</a>
              </div>
              <p>This is not a transition, but we did trigger an avoided state.
Schedule a placeholder to display after a short delay, using the Just
Noticeable Difference.
TODO: Is the JND optimization worth the added complexity? If this is
the only reason we track the event time, then probably not.
Consider removing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> mostRecentEventTime = <span class="hljs-title function_">getMostRecentEventTime</span>(root, lanes);
            <span class="hljs-keyword">var</span> eventTimeMs = mostRecentEventTime;
            <span class="hljs-keyword">var</span> timeElapsedMs = <span class="hljs-title function_">now</span>() - eventTimeMs;

            <span class="hljs-keyword">var</span> _msUntilTimeout = <span class="hljs-title function_">jnd</span>(timeElapsedMs) - timeElapsedMs; <span class="hljs-comment">// Don&#x27;t bother with a very short suspense time.</span>


            <span class="hljs-keyword">if</span> (_msUntilTimeout &gt; <span class="hljs-number">10</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1044">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1044">&#x00a7;</a>
              </div>
              <p>Instead of committing the fallback immediately, wait for more data
to arrive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              root.<span class="hljs-property">timeoutHandle</span> = <span class="hljs-title function_">scheduleTimeout</span>(commitRoot.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root), _msUntilTimeout);
              <span class="hljs-keyword">break</span>;
            }
          } <span class="hljs-comment">// Commit the placeholder.</span>


          <span class="hljs-title function_">commitRoot</span>(root);
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">RootCompleted</span>:
        {</pre></div></div>
            
        </li>
        
        
        <li id="section-1045">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1045">&#x00a7;</a>
              </div>
              <p>The work completed. Ready to commit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">commitRoot</span>(root);
          <span class="hljs-keyword">break</span>;
        }

      <span class="hljs-attr">default</span>:
        {
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unknown root exit status.&quot;</span>);
            }
          }
        }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRootSuspended$1</span>(<span class="hljs-params">root, suspendedLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1046">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1046">&#x00a7;</a>
              </div>
              <p>When suspending, we should always exclude lanes that were pinged or (more
rarely, since we try to avoid it) updated during the render phase.
TODO: Lol maybe there’s a better way to factor this besides this
obnoxiously named function :)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    suspendedLanes = <span class="hljs-title function_">removeLanes</span>(suspendedLanes, workInProgressRootPingedLanes);
    suspendedLanes = <span class="hljs-title function_">removeLanes</span>(suspendedLanes, workInProgressRootUpdatedLanes);
    <span class="hljs-title function_">markRootSuspended</span>(root, suspendedLanes);
  } <span class="hljs-comment">// This is the entry point for synchronous tasks that don&#x27;t go</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1047">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1047">&#x00a7;</a>
              </div>
              <p>through Scheduler</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">performSyncWorkOnRoot</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">if</span> (!((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should not already be working.&quot;</span>);
      }
    }

    <span class="hljs-title function_">flushPassiveEffects</span>();
    <span class="hljs-keyword">var</span> lanes;
    <span class="hljs-keyword">var</span> exitStatus;

    <span class="hljs-keyword">if</span> (root === workInProgressRoot &amp;&amp; <span class="hljs-title function_">includesSomeLane</span>(root.<span class="hljs-property">expiredLanes</span>, workInProgressRootRenderLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1048">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1048">&#x00a7;</a>
              </div>
              <p>There’s a partial tree, and at least one of its lanes has expired. Finish
rendering it before rendering the rest of the expired work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      lanes = workInProgressRootRenderLanes;
      exitStatus = <span class="hljs-title function_">renderRootSync</span>(root, lanes);

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesSomeLane</span>(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1049">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1049">&#x00a7;</a>
              </div>
              <p>The render included lanes that were updated during the render phase.
For example, when unhiding a hidden tree, we include all the lanes
that were previously skipped when the tree was hidden. That set of
lanes is a superset of the lanes we started rendering with.</p>
<p>Note that this only happens when part of the tree is rendered
concurrently. If the whole tree is rendered synchronously, then there
are no interleaved events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        lanes = <span class="hljs-title function_">getNextLanes</span>(root, lanes);
        exitStatus = <span class="hljs-title function_">renderRootSync</span>(root, lanes);
      }
    } <span class="hljs-keyword">else</span> {
      lanes = <span class="hljs-title function_">getNextLanes</span>(root, <span class="hljs-title class_">NoLanes</span>);
      exitStatus = <span class="hljs-title function_">renderRootSync</span>(root, lanes);
    }

    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">LegacyRoot</span> &amp;&amp; exitStatus === <span class="hljs-title class_">RootErrored</span>) {
      executionContext |= <span class="hljs-title class_">RetryAfterError</span>; <span class="hljs-comment">// If an error occurred during hydration,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1050">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1050">&#x00a7;</a>
              </div>
              <p>discard server response and fall back to client side render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (root.<span class="hljs-property">hydrate</span>) {
        root.<span class="hljs-property">hydrate</span> = <span class="hljs-literal">false</span>;
        <span class="hljs-title function_">clearContainer</span>(root.<span class="hljs-property">containerInfo</span>);
      } <span class="hljs-comment">// If something threw an error, try rendering one more time. We&#x27;ll render</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1051">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1051">&#x00a7;</a>
              </div>
              <p>synchronously to block concurrent data mutations, and we’ll includes
all pending updates are included. If it still fails after the second
attempt, we’ll give up and commit the resulting tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      lanes = <span class="hljs-title function_">getLanesToRetrySynchronouslyOnError</span>(root);

      <span class="hljs-keyword">if</span> (lanes !== <span class="hljs-title class_">NoLanes</span>) {
        exitStatus = <span class="hljs-title function_">renderRootSync</span>(root, lanes);
      }
    }

    <span class="hljs-keyword">if</span> (exitStatus === <span class="hljs-title class_">RootFatalErrored</span>) {
      <span class="hljs-keyword">var</span> fatalError = workInProgressRootFatalError;
      <span class="hljs-title function_">prepareFreshStack</span>(root, <span class="hljs-title class_">NoLanes</span>);
      <span class="hljs-title function_">markRootSuspended$1</span>(root, lanes);
      <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());
      <span class="hljs-keyword">throw</span> fatalError;
    } <span class="hljs-comment">// We now have a consistent tree. Because this is a sync render, we</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1052">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1052">&#x00a7;</a>
              </div>
              <p>will commit it even if something suspended.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> finishedWork = root.<span class="hljs-property">current</span>.<span class="hljs-property">alternate</span>;
    root.<span class="hljs-property">finishedWork</span> = finishedWork;
    root.<span class="hljs-property">finishedLanes</span> = lanes;
    <span class="hljs-title function_">commitRoot</span>(root); <span class="hljs-comment">// Before exiting, make sure there&#x27;s a callback scheduled for the next</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1053">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1053">&#x00a7;</a>
              </div>
              <p>pending level.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushRoot</span>(<span class="hljs-params">root, lanes</span>) {
    <span class="hljs-title function_">markRootExpired</span>(root, lanes);
    <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());

    <span class="hljs-keyword">if</span> ((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>) {
      <span class="hljs-title function_">resetRenderTimer</span>();
      <span class="hljs-title function_">flushSyncCallbackQueue</span>();
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getExecutionContext</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> executionContext;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushDiscreteUpdates</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1054">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1054">&#x00a7;</a>
              </div>
              <p>TODO: Should be able to flush inside batchedUpdates, but not inside <code>act</code>.
However, <code>act</code> uses <code>batchedUpdates</code>, so there’s no way to distinguish
those two cases. Need to fix this before exposing flushDiscreteUpdates
as a public API.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> ((executionContext &amp; (<span class="hljs-title class_">BatchedContext</span> | <span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) !== <span class="hljs-title class_">NoContext</span>) {
      {
        <span class="hljs-keyword">if</span> ((executionContext &amp; <span class="hljs-title class_">RenderContext</span>) !== <span class="hljs-title class_">NoContext</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;unstable_flushDiscreteUpdates: Cannot flush updates when React is &#x27;</span> + <span class="hljs-string">&#x27;already rendering.&#x27;</span>);
        }
      } <span class="hljs-comment">// We&#x27;re already rendering, so we can&#x27;t synchronously flush pending work.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1055">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1055">&#x00a7;</a>
              </div>
              <p>This is probably a nested event dispatch triggered by a lifecycle/effect,
like <code>el.focus()</code>. Exit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-title function_">flushPendingDiscreteUpdates</span>(); <span class="hljs-comment">// If the discrete updates scheduled passive effects, flush them now so that</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1056">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1056">&#x00a7;</a>
              </div>
              <p>they fire before the next serial event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-title function_">flushPassiveEffects</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushPendingDiscreteUpdates</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (rootsWithPendingDiscreteUpdates !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1057">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1057">&#x00a7;</a>
              </div>
              <p>For each root with pending discrete updates, schedule a callback to
immediately flush them.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> roots = rootsWithPendingDiscreteUpdates;
      rootsWithPendingDiscreteUpdates = <span class="hljs-literal">null</span>;
      roots.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">root</span>) {
        <span class="hljs-title function_">markDiscreteUpdatesExpired</span>(root);
        <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());
      });
    } <span class="hljs-comment">// Now flush the immediate queue.</span>


    <span class="hljs-title function_">flushSyncCallbackQueue</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedUpdates$1</span>(<span class="hljs-params">fn, a</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">BatchedContext</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a);
    } <span class="hljs-keyword">finally</span> {
      executionContext = prevExecutionContext;

      <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1058">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1058">&#x00a7;</a>
              </div>
              <p>Flush the immediate callbacks that were scheduled during this batch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">resetRenderTimer</span>();
        <span class="hljs-title function_">flushSyncCallbackQueue</span>();
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedEventUpdates$1</span>(<span class="hljs-params">fn, a</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">EventContext</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a);
    } <span class="hljs-keyword">finally</span> {
      executionContext = prevExecutionContext;

      <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1059">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1059">&#x00a7;</a>
              </div>
              <p>Flush the immediate callbacks that were scheduled during this batch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">resetRenderTimer</span>();
        <span class="hljs-title function_">flushSyncCallbackQueue</span>();
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">discreteUpdates$1</span>(<span class="hljs-params">fn, a, b, c, d</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">DiscreteEventContext</span>;

    {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">runWithPriority$1</span>(<span class="hljs-title class_">UserBlockingPriority</span>$<span class="hljs-number">2</span>, fn.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, a, b, c, d));
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext;

        <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1060">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1060">&#x00a7;</a>
              </div>
              <p>Flush the immediate callbacks that were scheduled during this batch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">resetRenderTimer</span>();
          <span class="hljs-title function_">flushSyncCallbackQueue</span>();
        }
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unbatchedUpdates</span>(<span class="hljs-params">fn, a</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext &amp;= ~<span class="hljs-title class_">BatchedContext</span>;
    executionContext |= <span class="hljs-title class_">LegacyUnbatchedContext</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a);
    } <span class="hljs-keyword">finally</span> {
      executionContext = prevExecutionContext;

      <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1061">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1061">&#x00a7;</a>
              </div>
              <p>Flush the immediate callbacks that were scheduled during this batch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">resetRenderTimer</span>();
        <span class="hljs-title function_">flushSyncCallbackQueue</span>();
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushSync</span>(<span class="hljs-params">fn, a</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;

    <span class="hljs-keyword">if</span> ((prevExecutionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) !== <span class="hljs-title class_">NoContext</span>) {
      {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;flushSync was called from inside a lifecycle method. React cannot &#x27;</span> + <span class="hljs-string">&#x27;flush when React is already rendering. Consider moving this call to &#x27;</span> + <span class="hljs-string">&#x27;a scheduler task or micro task.&#x27;</span>);
      }

      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a);
    }

    executionContext |= <span class="hljs-title class_">BatchedContext</span>;

    {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (fn) {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">runWithPriority$1</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, fn.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, a));
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
        }
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext; <span class="hljs-comment">// Flush the immediate callbacks that were scheduled during this batch.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1062">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1062">&#x00a7;</a>
              </div>
              <p>Note that this will happen even if batchedUpdates is higher up
the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">flushSyncCallbackQueue</span>();
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushControlled</span>(<span class="hljs-params">fn</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">BatchedContext</span>;

    {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">runWithPriority$1</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, fn);
      } <span class="hljs-keyword">finally</span> {
        executionContext = prevExecutionContext;

        <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1063">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1063">&#x00a7;</a>
              </div>
              <p>Flush the immediate callbacks that were scheduled during this batch</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">resetRenderTimer</span>();
          <span class="hljs-title function_">flushSyncCallbackQueue</span>();
        }
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushRenderLanes</span>(<span class="hljs-params">fiber, lanes</span>) {
    <span class="hljs-title function_">push</span>(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
    subtreeRenderLanes = <span class="hljs-title function_">mergeLanes</span>(subtreeRenderLanes, lanes);
    workInProgressRootIncludedLanes = <span class="hljs-title function_">mergeLanes</span>(workInProgressRootIncludedLanes, lanes);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popRenderLanes</span>(<span class="hljs-params">fiber</span>) {
    subtreeRenderLanes = subtreeRenderLanesCursor.<span class="hljs-property">current</span>;
    <span class="hljs-title function_">pop</span>(subtreeRenderLanesCursor, fiber);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareFreshStack</span>(<span class="hljs-params">root, lanes</span>) {
    root.<span class="hljs-property">finishedWork</span> = <span class="hljs-literal">null</span>;
    root.<span class="hljs-property">finishedLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-keyword">var</span> timeoutHandle = root.<span class="hljs-property">timeoutHandle</span>;

    <span class="hljs-keyword">if</span> (timeoutHandle !== noTimeout) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1064">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1064">&#x00a7;</a>
              </div>
              <p>The root previous suspended and scheduled a timeout to commit a fallback
state. Now that we have additional work, cancel the timeout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      root.<span class="hljs-property">timeoutHandle</span> = noTimeout; <span class="hljs-comment">// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span>

      <span class="hljs-title function_">cancelTimeout</span>(timeoutHandle);
    }

    <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> interruptedWork = workInProgress.<span class="hljs-property">return</span>;

      <span class="hljs-keyword">while</span> (interruptedWork !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">unwindInterruptedWork</span>(interruptedWork);
        interruptedWork = interruptedWork.<span class="hljs-property">return</span>;
      }
    }

    workInProgressRoot = root;
    workInProgress = <span class="hljs-title function_">createWorkInProgress</span>(root.<span class="hljs-property">current</span>, <span class="hljs-literal">null</span>);
    workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
    workInProgressRootExitStatus = <span class="hljs-title class_">RootIncomplete</span>;
    workInProgressRootFatalError = <span class="hljs-literal">null</span>;
    workInProgressRootSkippedLanes = <span class="hljs-title class_">NoLanes</span>;
    workInProgressRootUpdatedLanes = <span class="hljs-title class_">NoLanes</span>;
    workInProgressRootPingedLanes = <span class="hljs-title class_">NoLanes</span>;

    {
      spawnedWorkDuringRender = <span class="hljs-literal">null</span>;
    }

    {
      <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-title function_">discardPendingWarnings</span>();
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleError</span>(<span class="hljs-params">root, thrownValue</span>) {
    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">var</span> erroredWork = workInProgress;

      <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1065">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1065">&#x00a7;</a>
              </div>
              <p>Reset module-level state that was set during the render phase.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">resetContextDependencies</span>();
        <span class="hljs-title function_">resetHooksAfterThrow</span>();
        <span class="hljs-title function_">resetCurrentFiber</span>(); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> I found and added this missing line while investigating a</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1066">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1066">&#x00a7;</a>
              </div>
              <p>separate issue. Write a regression test using string refs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">2.</span>current = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (erroredWork === <span class="hljs-literal">null</span> || erroredWork.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1067">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1067">&#x00a7;</a>
              </div>
              <p>Expected to be working on a non-root fiber. This is a fatal error
because there’s no ancestor that can handle it; the root is
supposed to capture all errors that weren’t caught by an error
boundary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          workInProgressRootExitStatus = <span class="hljs-title class_">RootFatalErrored</span>;
          workInProgressRootFatalError = thrownValue; <span class="hljs-comment">// Set `workInProgress` to null. This represents advancing to the next</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1068">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1068">&#x00a7;</a>
              </div>
              <p>sibling, or the parent if there are no siblings. But since the root
has no siblings nor a parent, we set it to null. Usually this is
handled by <code>completeUnitOfWork</code> or <code>unwindWork</code>, but since we’re
intentionally not calling those, we need set it here.
TODO: Consider calling <code>unwindWork</code> to pop the contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          workInProgress = <span class="hljs-literal">null</span>;
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (enableProfilerTimer &amp;&amp; erroredWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1069">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1069">&#x00a7;</a>
              </div>
              <p>Record the time spent rendering before an error was thrown. This
avoids inaccurate Profiler durations in the case of a
suspended render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(erroredWork, <span class="hljs-literal">true</span>);
        }

        <span class="hljs-title function_">throwException</span>(root, erroredWork.<span class="hljs-property">return</span>, erroredWork, thrownValue, workInProgressRootRenderLanes);
        <span class="hljs-title function_">completeUnitOfWork</span>(erroredWork);
      } <span class="hljs-keyword">catch</span> (yetAnotherThrownValue) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1070">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1070">&#x00a7;</a>
              </div>
              <p>Something in the return path also threw.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        thrownValue = yetAnotherThrownValue;

        <span class="hljs-keyword">if</span> (workInProgress === erroredWork &amp;&amp; erroredWork !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1071">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1071">&#x00a7;</a>
              </div>
              <p>If this boundary has already errored, then we had trouble processing
the error. Bubble it to the next boundary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          erroredWork = erroredWork.<span class="hljs-property">return</span>;
          workInProgress = erroredWork;
        } <span class="hljs-keyword">else</span> {
          erroredWork = workInProgress;
        }

        <span class="hljs-keyword">continue</span>;
      } <span class="hljs-comment">// Return to the normal work loop.</span>


      <span class="hljs-keyword">return</span>;
    } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushDispatcher</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">2.</span>current;
    <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">2.</span>current = <span class="hljs-title class_">ContextOnlyDispatcher</span>;

    <span class="hljs-keyword">if</span> (prevDispatcher === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1072">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1072">&#x00a7;</a>
              </div>
              <p>The React isomorphic package does not include a default dispatcher.
Instead the first renderer will lazily attach one, in order to give
nicer error messages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">ContextOnlyDispatcher</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> prevDispatcher;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popDispatcher</span>(<span class="hljs-params">prevDispatcher</span>) {
    <span class="hljs-title class_">ReactCurrentDispatcher</span>$<span class="hljs-number">2.</span>current = prevDispatcher;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pushInteractions</span>(<span class="hljs-params">root</span>) {
    {
      <span class="hljs-keyword">var</span> prevInteractions = __interactionsRef.<span class="hljs-property">current</span>;
      __interactionsRef.<span class="hljs-property">current</span> = root.<span class="hljs-property">memoizedInteractions</span>;
      <span class="hljs-keyword">return</span> prevInteractions;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">popInteractions</span>(<span class="hljs-params">prevInteractions</span>) {
    {
      __interactionsRef.<span class="hljs-property">current</span> = prevInteractions;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markCommitTimeOfFallback</span>(<span class="hljs-params"></span>) {
    globalMostRecentFallbackTime = <span class="hljs-title function_">now</span>();
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markSkippedUpdateLanes</span>(<span class="hljs-params">lane</span>) {
    workInProgressRootSkippedLanes = <span class="hljs-title function_">mergeLanes</span>(lane, workInProgressRootSkippedLanes);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderDidSuspend</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootIncomplete</span>) {
      workInProgressRootExitStatus = <span class="hljs-title class_">RootSuspended</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderDidSuspendDelayIfPossible</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootIncomplete</span> || workInProgressRootExitStatus === <span class="hljs-title class_">RootSuspended</span>) {
      workInProgressRootExitStatus = <span class="hljs-title class_">RootSuspendedWithDelay</span>;
    } <span class="hljs-comment">// Check if there are updates that we skipped tree that might have unblocked</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1073">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1073">&#x00a7;</a>
              </div>
              <p>this render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">if</span> (workInProgressRoot !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-title function_">includesNonIdleWork</span>(workInProgressRootSkippedLanes) || <span class="hljs-title function_">includesNonIdleWork</span>(workInProgressRootUpdatedLanes))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1074">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1074">&#x00a7;</a>
              </div>
              <p>Mark the current render as suspended so that we switch to working on
the updates that were skipped. Usually we only suspend at the end of
the render phase.
TODO: We should probably always mark the root as suspended immediately
(inside this function), since by suspending at the end of the render
phase introduces a potential mistake where we suspend lanes that were
pinged or updated while we were rendering.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">markRootSuspended$1</span>(workInProgressRoot, workInProgressRootRenderLanes);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderDidError</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (workInProgressRootExitStatus !== <span class="hljs-title class_">RootCompleted</span>) {
      workInProgressRootExitStatus = <span class="hljs-title class_">RootErrored</span>;
    }
  } <span class="hljs-comment">// Called during render to determine if anything has suspended.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1075">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1075">&#x00a7;</a>
              </div>
              <p>Returns false if we’re not sure.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderHasNotSuspendedYet</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1076">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1076">&#x00a7;</a>
              </div>
              <p>If something errored or completed, we can’t really be sure,
so those are false.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> workInProgressRootExitStatus === <span class="hljs-title class_">RootIncomplete</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderRootSync</span>(<span class="hljs-params">root, lanes</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">RenderContext</span>;
    <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title function_">pushDispatcher</span>(); <span class="hljs-comment">// If the root or lanes have changed, throw out the existing stack</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1077">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1077">&#x00a7;</a>
              </div>
              <p>and prepare a fresh one. Otherwise we’ll continue where we left off.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
      <span class="hljs-title function_">prepareFreshStack</span>(root, lanes);
      <span class="hljs-title function_">startWorkOnPendingInteractions</span>(root, lanes);
    }

    <span class="hljs-keyword">var</span> prevInteractions = <span class="hljs-title function_">pushInteractions</span>(root);

    {
      <span class="hljs-title function_">markRenderStarted</span>(lanes);
    }

    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">workLoopSync</span>();
        <span class="hljs-keyword">break</span>;
      } <span class="hljs-keyword">catch</span> (thrownValue) {
        <span class="hljs-title function_">handleError</span>(root, thrownValue);
      }
    } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);

    <span class="hljs-title function_">resetContextDependencies</span>();

    {
      <span class="hljs-title function_">popInteractions</span>(prevInteractions);
    }

    executionContext = prevExecutionContext;
    <span class="hljs-title function_">popDispatcher</span>(prevDispatcher);

    <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1078">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1078">&#x00a7;</a>
              </div>
              <p>This is a sync render, so we should have finished the whole tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
        }
      }
    }

    {
      <span class="hljs-title function_">markRenderStopped</span>();
    } <span class="hljs-comment">// Set this to null to indicate there&#x27;s no in-progress render.</span>


    workInProgressRoot = <span class="hljs-literal">null</span>;
    workInProgressRootRenderLanes = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-keyword">return</span> workInProgressRootExitStatus;
  } <span class="hljs-comment">// The work loop is an extremely hot path. Tell Closure not to inline it.</span>

  <span class="hljs-comment">/** <span class="hljs-doctag">@noinline</span> */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopSync</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1079">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1079">&#x00a7;</a>
              </div>
              <p>Already timed out, so perform work without checking if we need to yield.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderRootConcurrent</span>(<span class="hljs-params">root, lanes</span>) {
    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">RenderContext</span>;
    <span class="hljs-keyword">var</span> prevDispatcher = <span class="hljs-title function_">pushDispatcher</span>(); <span class="hljs-comment">// If the root or lanes have changed, throw out the existing stack</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1080">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1080">&#x00a7;</a>
              </div>
              <p>and prepare a fresh one. Otherwise we’ll continue where we left off.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
      <span class="hljs-title function_">resetRenderTimer</span>();
      <span class="hljs-title function_">prepareFreshStack</span>(root, lanes);
      <span class="hljs-title function_">startWorkOnPendingInteractions</span>(root, lanes);
    }

    <span class="hljs-keyword">var</span> prevInteractions = <span class="hljs-title function_">pushInteractions</span>(root);

    {
      <span class="hljs-title function_">markRenderStarted</span>(lanes);
    }

    <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">workLoopConcurrent</span>();
        <span class="hljs-keyword">break</span>;
      } <span class="hljs-keyword">catch</span> (thrownValue) {
        <span class="hljs-title function_">handleError</span>(root, thrownValue);
      }
    } <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);

    <span class="hljs-title function_">resetContextDependencies</span>();

    {
      <span class="hljs-title function_">popInteractions</span>(prevInteractions);
    }

    <span class="hljs-title function_">popDispatcher</span>(prevDispatcher);
    executionContext = prevExecutionContext;


    <span class="hljs-keyword">if</span> (workInProgress !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1081">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1081">&#x00a7;</a>
              </div>
              <p>Still work remaining.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        <span class="hljs-title function_">markRenderYielded</span>();
      }

      <span class="hljs-keyword">return</span> <span class="hljs-title class_">RootIncomplete</span>;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1082">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1082">&#x00a7;</a>
              </div>
              <p>Completed the tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      {
        <span class="hljs-title function_">markRenderStopped</span>();
      } <span class="hljs-comment">// Set this to null to indicate there&#x27;s no in-progress render.</span>


      workInProgressRoot = <span class="hljs-literal">null</span>;
      workInProgressRootRenderLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// Return the final exit status.</span>

      <span class="hljs-keyword">return</span> workInProgressRootExitStatus;
    }
  }
  <span class="hljs-comment">/** <span class="hljs-doctag">@noinline</span> */</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">workLoopConcurrent</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1083">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1083">&#x00a7;</a>
              </div>
              <p>Perform work until Scheduler asks us to yield</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">while</span> (workInProgress !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">shouldYield</span>()) {
      <span class="hljs-title function_">performUnitOfWork</span>(workInProgress);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">performUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1084">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1084">&#x00a7;</a>
              </div>
              <p>The current, flushed, state of this fiber is the alternate. Ideally
nothing should rely on this, but relying on it here means that we don’t
need an additional field on the work in progress.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> current = unitOfWork.<span class="hljs-property">alternate</span>;
    <span class="hljs-title function_">setCurrentFiber</span>(unitOfWork);
    <span class="hljs-keyword">var</span> next;

    <span class="hljs-keyword">if</span> ((unitOfWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) {
      <span class="hljs-title function_">startProfilerTimer</span>(unitOfWork);
      next = <span class="hljs-title function_">beginWork$1</span>(current, unitOfWork, subtreeRenderLanes);
      <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(unitOfWork, <span class="hljs-literal">true</span>);
    } <span class="hljs-keyword">else</span> {
      next = <span class="hljs-title function_">beginWork$1</span>(current, unitOfWork, subtreeRenderLanes);
    }

    <span class="hljs-title function_">resetCurrentFiber</span>();
    unitOfWork.<span class="hljs-property">memoizedProps</span> = unitOfWork.<span class="hljs-property">pendingProps</span>;

    <span class="hljs-keyword">if</span> (next === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1085">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1085">&#x00a7;</a>
              </div>
              <p>If this doesn’t spawn new work, complete the current work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">completeUnitOfWork</span>(unitOfWork);
    } <span class="hljs-keyword">else</span> {
      workInProgress = next;
    }

    <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">2.</span>current = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">completeUnitOfWork</span>(<span class="hljs-params">unitOfWork</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1086">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1086">&#x00a7;</a>
              </div>
              <p>Attempt to complete the current unit of work, then move to the next
sibling. If there are no more siblings, return to the parent fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> completedWork = unitOfWork;

    <span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1087">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1087">&#x00a7;</a>
              </div>
              <p>The current, flushed, state of this fiber is the alternate. Ideally
nothing should rely on this, but relying on it here means that we don’t
need an additional field on the work in progress.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> current = completedWork.<span class="hljs-property">alternate</span>;
      <span class="hljs-keyword">var</span> returnFiber = completedWork.<span class="hljs-property">return</span>; <span class="hljs-comment">// Check if the work completed or if something threw.</span>

      <span class="hljs-keyword">if</span> ((completedWork.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Incomplete</span>) === <span class="hljs-title class_">NoFlags</span>) {
        <span class="hljs-title function_">setCurrentFiber</span>(completedWork);
        <span class="hljs-keyword">var</span> next = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">if</span> ((completedWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) === <span class="hljs-title class_">NoMode</span>) {
          next = <span class="hljs-title function_">completeWork</span>(current, completedWork, subtreeRenderLanes);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">startProfilerTimer</span>(completedWork);
          next = <span class="hljs-title function_">completeWork</span>(current, completedWork, subtreeRenderLanes); <span class="hljs-comment">// Update render duration assuming we didn&#x27;t error.</span>

          <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(completedWork, <span class="hljs-literal">false</span>);
        }

        <span class="hljs-title function_">resetCurrentFiber</span>();

        <span class="hljs-keyword">if</span> (next !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1088">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1088">&#x00a7;</a>
              </div>
              <p>Completing this fiber spawned new work. Work on that next.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          workInProgress = next;
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-title function_">resetChildLanes</span>(completedWork);

        <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-comment">// Do not append effects to parents if a sibling failed to complete</span>
          (returnFiber.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Incomplete</span>) === <span class="hljs-title class_">NoFlags</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1089">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1089">&#x00a7;</a>
              </div>
              <p>Append all the effects of the subtree and this fiber onto the effect
list of the parent. The completion order of the children affects the
side-effect order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">firstEffect</span> === <span class="hljs-literal">null</span>) {
            returnFiber.<span class="hljs-property">firstEffect</span> = completedWork.<span class="hljs-property">firstEffect</span>;
          }

          <span class="hljs-keyword">if</span> (completedWork.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
              returnFiber.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = completedWork.<span class="hljs-property">firstEffect</span>;
            }

            returnFiber.<span class="hljs-property">lastEffect</span> = completedWork.<span class="hljs-property">lastEffect</span>;
          } <span class="hljs-comment">// If this fiber had side-effects, we append it AFTER the children&#x27;s</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1090">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1090">&#x00a7;</a>
              </div>
              <p>side-effects. We can perform certain side-effects earlier if needed,
by doing multiple passes over the effect list. We don’t want to
schedule our own side-effect on our own list because if end up
reusing children we’ll schedule this effect onto itself since we’re
at the end.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

          <span class="hljs-keyword">var</span> flags = completedWork.<span class="hljs-property">flags</span>; <span class="hljs-comment">// Skip both NoWork and PerformedWork tags when creating the effect</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1091">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1091">&#x00a7;</a>
              </div>
              <p>list. PerformedWork effect is read by React DevTools but shouldn’t be
committed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (flags &gt; <span class="hljs-title class_">PerformedWork</span>) {
            <span class="hljs-keyword">if</span> (returnFiber.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
              returnFiber.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = completedWork;
            } <span class="hljs-keyword">else</span> {
              returnFiber.<span class="hljs-property">firstEffect</span> = completedWork;
            }

            returnFiber.<span class="hljs-property">lastEffect</span> = completedWork;
          }
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1092">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1092">&#x00a7;</a>
              </div>
              <p>This fiber did not complete because something threw. Pop values off
the stack without entering the complete phase. If this is a boundary,
capture values if possible.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> _next = <span class="hljs-title function_">unwindWork</span>(completedWork); <span class="hljs-comment">// Because this fiber did not complete, don&#x27;t reset its expiration time.</span>


        <span class="hljs-keyword">if</span> (_next !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1093">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1093">&#x00a7;</a>
              </div>
              <p>If completing this work spawned new work, do that next. We’ll come
back here again.
Since we’re restarting, remove anything that is not a host effect
from the effect tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          _next.<span class="hljs-property">flags</span> &amp;= <span class="hljs-title class_">HostEffectMask</span>;
          workInProgress = _next;
          <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> ((completedWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1094">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1094">&#x00a7;</a>
              </div>
              <p>Record the render duration for the fiber that errored.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">stopProfilerTimerIfRunningAndRecordDelta</span>(completedWork, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Include the time spent working on failed children before continuing.</span>

          <span class="hljs-keyword">var</span> actualDuration = completedWork.<span class="hljs-property">actualDuration</span>;
          <span class="hljs-keyword">var</span> child = completedWork.<span class="hljs-property">child</span>;

          <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
            actualDuration += child.<span class="hljs-property">actualDuration</span>;
            child = child.<span class="hljs-property">sibling</span>;
          }

          completedWork.<span class="hljs-property">actualDuration</span> = actualDuration;
        }

        <span class="hljs-keyword">if</span> (returnFiber !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1095">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1095">&#x00a7;</a>
              </div>
              <p>Mark the parent fiber as incomplete and clear its effect list.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          returnFiber.<span class="hljs-property">firstEffect</span> = returnFiber.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
          returnFiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">Incomplete</span>;
        }
      }

      <span class="hljs-keyword">var</span> siblingFiber = completedWork.<span class="hljs-property">sibling</span>;

      <span class="hljs-keyword">if</span> (siblingFiber !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1096">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1096">&#x00a7;</a>
              </div>
              <p>If there is more work to do in this returnFiber, do that next.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgress = siblingFiber;
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// Otherwise, return to the parent</span>


      completedWork = returnFiber; <span class="hljs-comment">// Update the next thing we&#x27;re working on in case something throws.</span>

      workInProgress = completedWork;
    } <span class="hljs-keyword">while</span> (completedWork !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// We&#x27;ve reached the root.</span>


    <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootIncomplete</span>) {
      workInProgressRootExitStatus = <span class="hljs-title class_">RootCompleted</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetChildLanes</span>(<span class="hljs-params">completedWork</span>) {
    <span class="hljs-keyword">if</span> ( <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Move this check out of the hot path by moving `resetChildLanes`</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1097">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1097">&#x00a7;</a>
              </div>
              <p>to switch statement in <code>completeWork</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      (completedWork.<span class="hljs-property">tag</span> === <span class="hljs-title class_">LegacyHiddenComponent</span> || completedWork.<span class="hljs-property">tag</span> === <span class="hljs-title class_">OffscreenComponent</span>) &amp;&amp; completedWork.<span class="hljs-property">memoizedState</span> !== <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-title function_">includesSomeLane</span>(subtreeRenderLanes, <span class="hljs-title class_">OffscreenLane</span>) &amp;&amp; (completedWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ConcurrentMode</span>) !== <span class="hljs-title class_">NoLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1098">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1098">&#x00a7;</a>
              </div>
              <p>The children of this component are hidden. Don’t bubble their
expiration times.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> newChildLanes = <span class="hljs-title class_">NoLanes</span>; <span class="hljs-comment">// Bubble up the earliest expiration time.</span>

    <span class="hljs-keyword">if</span> ((completedWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) !== <span class="hljs-title class_">NoMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1099">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1099">&#x00a7;</a>
              </div>
              <p>In profiling mode, resetChildExpirationTime is also used to reset
profiler durations.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> actualDuration = completedWork.<span class="hljs-property">actualDuration</span>;
      <span class="hljs-keyword">var</span> treeBaseDuration = completedWork.<span class="hljs-property">selfBaseDuration</span>; <span class="hljs-comment">// When a fiber is cloned, its actualDuration is reset to 0. This value will</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1100">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1100">&#x00a7;</a>
              </div>
              <p>only be updated if work is done on the fiber (i.e. it doesn’t bailout).
When work is done, it should bubble to the parent’s actualDuration. If
the fiber has not been cloned though, (meaning no work was done), then
this value will reflect the amount of time spent working on a previous
render. In that case it should not bubble. We determine whether it was
cloned by comparing the child pointer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> shouldBubbleActualDurations = completedWork.<span class="hljs-property">alternate</span> === <span class="hljs-literal">null</span> || completedWork.<span class="hljs-property">child</span> !== completedWork.<span class="hljs-property">alternate</span>.<span class="hljs-property">child</span>;
      <span class="hljs-keyword">var</span> child = completedWork.<span class="hljs-property">child</span>;

      <span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) {
        newChildLanes = <span class="hljs-title function_">mergeLanes</span>(newChildLanes, <span class="hljs-title function_">mergeLanes</span>(child.<span class="hljs-property">lanes</span>, child.<span class="hljs-property">childLanes</span>));

        <span class="hljs-keyword">if</span> (shouldBubbleActualDurations) {
          actualDuration += child.<span class="hljs-property">actualDuration</span>;
        }

        treeBaseDuration += child.<span class="hljs-property">treeBaseDuration</span>;
        child = child.<span class="hljs-property">sibling</span>;
      }

      <span class="hljs-keyword">var</span> isTimedOutSuspense = completedWork.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span> &amp;&amp; completedWork.<span class="hljs-property">memoizedState</span> !== <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (isTimedOutSuspense) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1101">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1101">&#x00a7;</a>
              </div>
              <p>Don’t count time spent in a timed out Suspense subtree as part of the base duration.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> primaryChildFragment = completedWork.<span class="hljs-property">child</span>;

        <span class="hljs-keyword">if</span> (primaryChildFragment !== <span class="hljs-literal">null</span>) {
          treeBaseDuration -= primaryChildFragment.<span class="hljs-property">treeBaseDuration</span>;
        }
      }

      completedWork.<span class="hljs-property">actualDuration</span> = actualDuration;
      completedWork.<span class="hljs-property">treeBaseDuration</span> = treeBaseDuration;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> _child = completedWork.<span class="hljs-property">child</span>;

      <span class="hljs-keyword">while</span> (_child !== <span class="hljs-literal">null</span>) {
        newChildLanes = <span class="hljs-title function_">mergeLanes</span>(newChildLanes, <span class="hljs-title function_">mergeLanes</span>(_child.<span class="hljs-property">lanes</span>, _child.<span class="hljs-property">childLanes</span>));
        _child = _child.<span class="hljs-property">sibling</span>;
      }
    }

    completedWork.<span class="hljs-property">childLanes</span> = newChildLanes;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRoot</span>(<span class="hljs-params">root</span>) {
    <span class="hljs-keyword">var</span> renderPriorityLevel = <span class="hljs-title function_">getCurrentPriorityLevel</span>();
    <span class="hljs-title function_">runWithPriority$1</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, commitRootImpl.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, root, renderPriorityLevel));
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitRootImpl</span>(<span class="hljs-params">root, renderPriorityLevel</span>) {
    <span class="hljs-keyword">do</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1102">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1102">&#x00a7;</a>
              </div>
              <p><code>flushPassiveEffects</code> will call <code>flushSyncUpdateQueue</code> at the end, which
means <code>flushPassiveEffects</code> will sometimes result in additional
passive effects. So we need to keep flushing in a loop until there are
no more pending effects.
TODO: Might be better if <code>flushPassiveEffects</code> did not automatically
flush synchronous work at the end, to avoid factoring hazards like this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">flushPassiveEffects</span>();
    } <span class="hljs-keyword">while</span> (rootWithPendingPassiveEffects !== <span class="hljs-literal">null</span>);

    <span class="hljs-title function_">flushRenderPhaseStrictModeWarningsInDEV</span>();

    <span class="hljs-keyword">if</span> (!((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should not already be working.&quot;</span>);
      }
    }

    <span class="hljs-keyword">var</span> finishedWork = root.<span class="hljs-property">finishedWork</span>;
    <span class="hljs-keyword">var</span> lanes = root.<span class="hljs-property">finishedLanes</span>;

    {
      <span class="hljs-title function_">markCommitStarted</span>(lanes);
    }

    <span class="hljs-keyword">if</span> (finishedWork === <span class="hljs-literal">null</span>) {

      {
        <span class="hljs-title function_">markCommitStopped</span>();
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    root.<span class="hljs-property">finishedWork</span> = <span class="hljs-literal">null</span>;
    root.<span class="hljs-property">finishedLanes</span> = <span class="hljs-title class_">NoLanes</span>;

    <span class="hljs-keyword">if</span> (!(finishedWork !== root.<span class="hljs-property">current</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.&quot;</span>);
      }
    } <span class="hljs-comment">// commitRoot never returns a continuation; it always finishes synchronously.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1103">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1103">&#x00a7;</a>
              </div>
              <p>So we can clear these now to allow a new callback to be scheduled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    root.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Update the first and last pending times on this root. The new first</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1104">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1104">&#x00a7;</a>
              </div>
              <p>pending time is whatever is left on the root fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> remainingLanes = <span class="hljs-title function_">mergeLanes</span>(finishedWork.<span class="hljs-property">lanes</span>, finishedWork.<span class="hljs-property">childLanes</span>);
    <span class="hljs-title function_">markRootFinished</span>(root, remainingLanes); <span class="hljs-comment">// Clear already finished discrete updates in case that a later call of</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1105">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1105">&#x00a7;</a>
              </div>
              <p><code>flushDiscreteUpdates</code> starts a useless render pass which may cancels
a scheduled timeout.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (rootsWithPendingDiscreteUpdates !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">hasDiscreteLanes</span>(remainingLanes) &amp;&amp; rootsWithPendingDiscreteUpdates.<span class="hljs-title function_">has</span>(root)) {
        rootsWithPendingDiscreteUpdates.<span class="hljs-title function_">delete</span>(root);
      }
    }

    <span class="hljs-keyword">if</span> (root === workInProgressRoot) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1106">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1106">&#x00a7;</a>
              </div>
              <p>We can reset these now that they are finished.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgressRoot = <span class="hljs-literal">null</span>;
      workInProgress = <span class="hljs-literal">null</span>;
      workInProgressRootRenderLanes = <span class="hljs-title class_">NoLanes</span>;
    } <span class="hljs-comment">// Get the list of effects.</span>


    <span class="hljs-keyword">var</span> firstEffect;

    <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">flags</span> &gt; <span class="hljs-title class_">PerformedWork</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1107">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1107">&#x00a7;</a>
              </div>
              <p>A fiber’s effect list consists only of its children, not itself. So if
the root has an effect, we need to add it to the end of the list. The
resulting list is the set that would belong to the root’s parent, if it
had one; that is, all the effects in the tree including the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (finishedWork.<span class="hljs-property">lastEffect</span> !== <span class="hljs-literal">null</span>) {
        finishedWork.<span class="hljs-property">lastEffect</span>.<span class="hljs-property">nextEffect</span> = finishedWork;
        firstEffect = finishedWork.<span class="hljs-property">firstEffect</span>;
      } <span class="hljs-keyword">else</span> {
        firstEffect = finishedWork;
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1108">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1108">&#x00a7;</a>
              </div>
              <p>There is no effect on the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      firstEffect = finishedWork.<span class="hljs-property">firstEffect</span>;
    }

    <span class="hljs-keyword">if</span> (firstEffect !== <span class="hljs-literal">null</span>) {

      <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
      executionContext |= <span class="hljs-title class_">CommitContext</span>;
      <span class="hljs-keyword">var</span> prevInteractions = <span class="hljs-title function_">pushInteractions</span>(root); <span class="hljs-comment">// Reset this to null before calling lifecycles</span>

      <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">2.</span>current = <span class="hljs-literal">null</span>; <span class="hljs-comment">// The commit phase is broken into several sub-phases. We do a separate pass</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1109">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1109">&#x00a7;</a>
              </div>
              <p>of the effect list for each phase: all mutation effects come before all
layout effects, and so on.
The first phase a “before mutation” phase. We use this phase to read the
state of the host tree right before we mutate it. This is where
getSnapshotBeforeUpdate is called.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      focusedInstanceHandle = <span class="hljs-title function_">prepareForCommit</span>(root.<span class="hljs-property">containerInfo</span>);
      shouldFireAfterActiveInstanceBlur = <span class="hljs-literal">false</span>;
      nextEffect = firstEffect;

      <span class="hljs-keyword">do</span> {
        {
          <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, commitBeforeMutationEffects, <span class="hljs-literal">null</span>);

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
            <span class="hljs-keyword">if</span> (!(nextEffect !== <span class="hljs-literal">null</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should be working on an effect.&quot;</span>);
              }
            }

            <span class="hljs-keyword">var</span> error = <span class="hljs-title function_">clearCaughtError</span>();
            <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, error);
            nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
          }
        }
      } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>); <span class="hljs-comment">// We no longer need to track the active instance fiber</span>


      focusedInstanceHandle = <span class="hljs-literal">null</span>;

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-1110">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1110">&#x00a7;</a>
              </div>
              <p>Mark the current commit time to be shared by all Profilers in this
batch. This enables them to be grouped later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">recordCommitTime</span>();
      } <span class="hljs-comment">// The next phase is the mutation phase, where we mutate the host tree.</span>


      nextEffect = firstEffect;

      <span class="hljs-keyword">do</span> {
        {
          <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, commitMutationEffects, <span class="hljs-literal">null</span>, root, renderPriorityLevel);

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
            <span class="hljs-keyword">if</span> (!(nextEffect !== <span class="hljs-literal">null</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should be working on an effect.&quot;</span>);
              }
            }

            <span class="hljs-keyword">var</span> _error = <span class="hljs-title function_">clearCaughtError</span>();

            <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, _error);
            nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
          }
        }
      } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);

      <span class="hljs-title function_">resetAfterCommit</span>(root.<span class="hljs-property">containerInfo</span>); <span class="hljs-comment">// The work-in-progress tree is now the current tree. This must come after</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1111">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1111">&#x00a7;</a>
              </div>
              <p>the mutation phase, so that the previous tree is still current during
componentWillUnmount, but before the layout phase, so that the finished
work is current during componentDidMount/Update.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      root.<span class="hljs-property">current</span> = finishedWork; <span class="hljs-comment">// The next phase is the layout phase, where we call effects that read</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1112">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1112">&#x00a7;</a>
              </div>
              <p>the host tree after it’s been mutated. The idiomatic use case for this is
layout, but class component lifecycles also fire here for legacy reasons.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      nextEffect = firstEffect;

      <span class="hljs-keyword">do</span> {
        {
          <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, commitLayoutEffects, <span class="hljs-literal">null</span>, root, lanes);

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
            <span class="hljs-keyword">if</span> (!(nextEffect !== <span class="hljs-literal">null</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should be working on an effect.&quot;</span>);
              }
            }

            <span class="hljs-keyword">var</span> _error2 = <span class="hljs-title function_">clearCaughtError</span>();

            <span class="hljs-title function_">captureCommitPhaseError</span>(nextEffect, _error2);
            nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
          }
        }
      } <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>);

      nextEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Tell Scheduler to yield at the end of the frame, so the browser has an</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1113">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1113">&#x00a7;</a>
              </div>
              <p>opportunity to paint.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-title function_">requestPaint</span>();

      {
        <span class="hljs-title function_">popInteractions</span>(prevInteractions);
      }

      executionContext = prevExecutionContext;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1114">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1114">&#x00a7;</a>
              </div>
              <p>No effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      root.<span class="hljs-property">current</span> = finishedWork; <span class="hljs-comment">// Measure these anyway so the flamegraph explicitly shows that there were</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1115">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1115">&#x00a7;</a>
              </div>
              <p>no effects.
TODO: Maybe there’s a better way to report this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      {
        <span class="hljs-title function_">recordCommitTime</span>();
      }
    }

    <span class="hljs-keyword">var</span> rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

    <span class="hljs-keyword">if</span> (rootDoesHavePassiveEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1116">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1116">&#x00a7;</a>
              </div>
              <p>This commit has passive effects. Stash a reference to them. But don’t
schedule a callback until after flushing layout work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      rootDoesHavePassiveEffects = <span class="hljs-literal">false</span>;
      rootWithPendingPassiveEffects = root;
      pendingPassiveEffectsLanes = lanes;
      pendingPassiveEffectsRenderPriority = renderPriorityLevel;
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1117">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1117">&#x00a7;</a>
              </div>
              <p>We are done with the effect chain at this point so let’s clear the
nextEffect pointers to assist with GC. If we have passive effects, we’ll
clear this in flushPassiveEffects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      nextEffect = firstEffect;

      <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> nextNextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
        nextEffect.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;

        <span class="hljs-keyword">if</span> (nextEffect.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Deletion</span>) {
          <span class="hljs-title function_">detachFiberAfterEffects</span>(nextEffect);
        }

        nextEffect = nextNextEffect;
      }
    } <span class="hljs-comment">// Read this again, since an effect might have updated it</span>


    remainingLanes = root.<span class="hljs-property">pendingLanes</span>; <span class="hljs-comment">// Check if there&#x27;s remaining work on this root</span>

    <span class="hljs-keyword">if</span> (remainingLanes !== <span class="hljs-title class_">NoLanes</span>) {
      {
        <span class="hljs-keyword">if</span> (spawnedWorkDuringRender !== <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">var</span> expirationTimes = spawnedWorkDuringRender;
          spawnedWorkDuringRender = <span class="hljs-literal">null</span>;

          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; expirationTimes.<span class="hljs-property">length</span>; i++) {
            <span class="hljs-title function_">scheduleInteractions</span>(root, expirationTimes[i], root.<span class="hljs-property">memoizedInteractions</span>);
          }
        }

        <span class="hljs-title function_">schedulePendingInteractions</span>(root, remainingLanes);
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1118">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1118">&#x00a7;</a>
              </div>
              <p>If there’s no remaining work, we can clear the set of already failed
error boundaries.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      legacyErrorBoundariesThatAlreadyFailed = <span class="hljs-literal">null</span>;
    }

    {
      <span class="hljs-keyword">if</span> (!rootDidHavePassiveEffects) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1119">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1119">&#x00a7;</a>
              </div>
              <p>If there are no passive effects, then we can complete the pending interactions.
Otherwise, we’ll wait until after the passive effects are flushed.
Wait to do this until after remaining work has been scheduled,
so that we don’t prematurely signal complete for interactions when there’s e.g. hidden work.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">finishPendingInteractions</span>(root, lanes);
      }
    }

    <span class="hljs-keyword">if</span> (remainingLanes === <span class="hljs-title class_">SyncLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1120">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1120">&#x00a7;</a>
              </div>
              <p>Count the number of times the root synchronously re-renders without
finishing. If there are too many, it indicates an infinite update loop.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (root === rootWithNestedUpdates) {
        nestedUpdateCount++;
      } <span class="hljs-keyword">else</span> {
        nestedUpdateCount = <span class="hljs-number">0</span>;
        rootWithNestedUpdates = root;
      }
    } <span class="hljs-keyword">else</span> {
      nestedUpdateCount = <span class="hljs-number">0</span>;
    }

    <span class="hljs-title function_">onCommitRoot</span>(finishedWork.<span class="hljs-property">stateNode</span>, renderPriorityLevel);

    {
      <span class="hljs-title function_">onCommitRoot$1</span>();
    } <span class="hljs-comment">// Always call this before exiting `commitRoot`, to ensure that any</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1121">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1121">&#x00a7;</a>
              </div>
              <p>additional work on this root is scheduled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-title function_">ensureRootIsScheduled</span>(root, <span class="hljs-title function_">now</span>());

    <span class="hljs-keyword">if</span> (hasUncaughtError) {
      hasUncaughtError = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> _error3 = firstUncaughtError;
      firstUncaughtError = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">throw</span> _error3;
    }

    <span class="hljs-keyword">if</span> ((executionContext &amp; <span class="hljs-title class_">LegacyUnbatchedContext</span>) !== <span class="hljs-title class_">NoContext</span>) {

      {
        <span class="hljs-title function_">markCommitStopped</span>();
      } <span class="hljs-comment">// This is a legacy edge case. We just committed the initial mount of</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1122">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1122">&#x00a7;</a>
              </div>
              <p>a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
synchronously, but layout updates should be deferred until the end
of the batch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    } <span class="hljs-comment">// If layout work was scheduled, flush it now.</span>


    <span class="hljs-title function_">flushSyncCallbackQueue</span>();

    {
      <span class="hljs-title function_">markCommitStopped</span>();
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitBeforeMutationEffects</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> current = nextEffect.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> ((nextEffect.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Deletion</span>) !== <span class="hljs-title class_">NoFlags</span>) {
          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">doesFiberContain</span>(nextEffect, focusedInstanceHandle)) {
            shouldFireAfterActiveInstanceBlur = <span class="hljs-literal">true</span>;
          }
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1123">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1123">&#x00a7;</a>
              </div>
              <p>TODO: Move this out of the hot path using a dedicated effect tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (nextEffect.<span class="hljs-property">tag</span> === <span class="hljs-title class_">SuspenseComponent</span> &amp;&amp; <span class="hljs-title function_">isSuspenseBoundaryBeingHidden</span>(current, nextEffect) &amp;&amp; <span class="hljs-title function_">doesFiberContain</span>(nextEffect, focusedInstanceHandle)) {
            shouldFireAfterActiveInstanceBlur = <span class="hljs-literal">true</span>;
          }
        }
      }

      <span class="hljs-keyword">var</span> flags = nextEffect.<span class="hljs-property">flags</span>;

      <span class="hljs-keyword">if</span> ((flags &amp; <span class="hljs-title class_">Snapshot</span>) !== <span class="hljs-title class_">NoFlags</span>) {
        <span class="hljs-title function_">setCurrentFiber</span>(nextEffect);
        <span class="hljs-title function_">commitBeforeMutationLifeCycles</span>(current, nextEffect);
        <span class="hljs-title function_">resetCurrentFiber</span>();
      }

      <span class="hljs-keyword">if</span> ((flags &amp; <span class="hljs-title class_">Passive</span>) !== <span class="hljs-title class_">NoFlags</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1124">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1124">&#x00a7;</a>
              </div>
              <p>If there are passive effects, schedule a callback to flush at
the earliest opportunity.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) {
          rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;
          <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-title function_">flushPassiveEffects</span>();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
          });
        }
      }

      nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitMutationEffects</span>(<span class="hljs-params">root, renderPriorityLevel</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1125">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1125">&#x00a7;</a>
              </div>
              <p>TODO: Should probably move the bulk of this function to commitWork.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">setCurrentFiber</span>(nextEffect);
      <span class="hljs-keyword">var</span> flags = nextEffect.<span class="hljs-property">flags</span>;

      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">ContentReset</span>) {
        <span class="hljs-title function_">commitResetTextContent</span>(nextEffect);
      }

      <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Ref</span>) {
        <span class="hljs-keyword">var</span> current = nextEffect.<span class="hljs-property">alternate</span>;

        <span class="hljs-keyword">if</span> (current !== <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">commitDetachRef</span>(current);
        }
      } <span class="hljs-comment">// The following switch statement is only concerned about placement,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1126">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1126">&#x00a7;</a>
              </div>
              <p>updates, and deletions. To avoid needing to add a case for every possible
bitmap value, we remove the secondary effects from the effect tag and
switch on that value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> primaryFlags = flags &amp; (<span class="hljs-title class_">Placement</span> | <span class="hljs-title class_">Update</span> | <span class="hljs-title class_">Deletion</span> | <span class="hljs-title class_">Hydrating</span>);

      <span class="hljs-keyword">switch</span> (primaryFlags) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">Placement</span>:
          {
            <span class="hljs-title function_">commitPlacement</span>(nextEffect); <span class="hljs-comment">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1127">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1127">&#x00a7;</a>
              </div>
              <p>inserted, before any life-cycles like componentDidMount gets called.
TODO: findDOMNode doesn’t rely on this any more but isMounted does
and isMounted is deprecated anyway so we should be able to kill this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            nextEffect.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">Placement</span>;
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">PlacementAndUpdate</span>:
          {</pre></div></div>
            
        </li>
        
        
        <li id="section-1128">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1128">&#x00a7;</a>
              </div>
              <p>Placement</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-title function_">commitPlacement</span>(nextEffect); <span class="hljs-comment">// Clear the &quot;placement&quot; from effect tag so that we know that this is</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1129">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1129">&#x00a7;</a>
              </div>
              <p>inserted, before any life-cycles like componentDidMount gets called.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
            nextEffect.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">Placement</span>; <span class="hljs-comment">// Update</span>

            <span class="hljs-keyword">var</span> _current = nextEffect.<span class="hljs-property">alternate</span>;
            <span class="hljs-title function_">commitWork</span>(_current, nextEffect);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">Hydrating</span>:
          {
            nextEffect.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">Hydrating</span>;
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">HydratingAndUpdate</span>:
          {
            nextEffect.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">Hydrating</span>; <span class="hljs-comment">// Update</span>

            <span class="hljs-keyword">var</span> _current2 = nextEffect.<span class="hljs-property">alternate</span>;
            <span class="hljs-title function_">commitWork</span>(_current2, nextEffect);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">Update</span>:
          {
            <span class="hljs-keyword">var</span> _current3 = nextEffect.<span class="hljs-property">alternate</span>;
            <span class="hljs-title function_">commitWork</span>(_current3, nextEffect);
            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">Deletion</span>:
          {
            <span class="hljs-title function_">commitDeletion</span>(root, nextEffect);
            <span class="hljs-keyword">break</span>;
          }
      }

      <span class="hljs-title function_">resetCurrentFiber</span>();
      nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">commitLayoutEffects</span>(<span class="hljs-params">root, committedLanes</span>) {

    {
      <span class="hljs-title function_">markLayoutEffectsStarted</span>(committedLanes);
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Should probably move the bulk of this function to commitWork.</span>


    <span class="hljs-keyword">while</span> (nextEffect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">setCurrentFiber</span>(nextEffect);
      <span class="hljs-keyword">var</span> flags = nextEffect.<span class="hljs-property">flags</span>;

      <span class="hljs-keyword">if</span> (flags &amp; (<span class="hljs-title class_">Update</span> | <span class="hljs-title class_">Callback</span>)) {
        <span class="hljs-keyword">var</span> current = nextEffect.<span class="hljs-property">alternate</span>;
        <span class="hljs-title function_">commitLifeCycles</span>(root, current, nextEffect);
      }

      {
        <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-title class_">Ref</span>) {
          <span class="hljs-title function_">commitAttachRef</span>(nextEffect);
        }
      }

      <span class="hljs-title function_">resetCurrentFiber</span>();
      nextEffect = nextEffect.<span class="hljs-property">nextEffect</span>;
    }

    {
      <span class="hljs-title function_">markLayoutEffectsStopped</span>();
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushPassiveEffects</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1130">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1130">&#x00a7;</a>
              </div>
              <p>Returns whether passive effects were flushed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (pendingPassiveEffectsRenderPriority !== <span class="hljs-title class_">NoPriority</span>$<span class="hljs-number">1</span>) {
      <span class="hljs-keyword">var</span> priorityLevel = pendingPassiveEffectsRenderPriority &gt; <span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span> ? <span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span> : pendingPassiveEffectsRenderPriority;
      pendingPassiveEffectsRenderPriority = <span class="hljs-title class_">NoPriority</span>$<span class="hljs-number">1</span>;

      {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">runWithPriority$1</span>(priorityLevel, flushPassiveEffectsImpl);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueuePendingPassiveHookEffectMount</span>(<span class="hljs-params">fiber, effect</span>) {
    pendingPassiveHookEffectsMount.<span class="hljs-title function_">push</span>(effect, fiber);

    <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;
      <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">flushPassiveEffects</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      });
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">enqueuePendingPassiveHookEffectUnmount</span>(<span class="hljs-params">fiber, effect</span>) {
    pendingPassiveHookEffectsUnmount.<span class="hljs-title function_">push</span>(effect, fiber);

    {
      fiber.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PassiveUnmountPendingDev</span>;
      <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>;

      <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
        alternate.<span class="hljs-property">flags</span> |= <span class="hljs-title class_">PassiveUnmountPendingDev</span>;
      }
    }

    <span class="hljs-keyword">if</span> (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = <span class="hljs-literal">true</span>;
      <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">NormalPriority</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">flushPassiveEffects</span>();
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      });
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">invokePassiveEffectCreate</span>(<span class="hljs-params">effect</span>) {
    <span class="hljs-keyword">var</span> create = effect.<span class="hljs-property">create</span>;
    effect.<span class="hljs-property">destroy</span> = <span class="hljs-title function_">create</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushPassiveEffectsImpl</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (rootWithPendingPassiveEffects === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> root = rootWithPendingPassiveEffects;
    <span class="hljs-keyword">var</span> lanes = pendingPassiveEffectsLanes;
    rootWithPendingPassiveEffects = <span class="hljs-literal">null</span>;
    pendingPassiveEffectsLanes = <span class="hljs-title class_">NoLanes</span>;

    <span class="hljs-keyword">if</span> (!((executionContext &amp; (<span class="hljs-title class_">RenderContext</span> | <span class="hljs-title class_">CommitContext</span>)) === <span class="hljs-title class_">NoContext</span>)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Cannot flush passive effects while already rendering.&quot;</span>);
      }
    }

    {
      <span class="hljs-title function_">markPassiveEffectsStarted</span>(lanes);
    }

    {
      isFlushingPassiveEffects = <span class="hljs-literal">true</span>;
    }

    <span class="hljs-keyword">var</span> prevExecutionContext = executionContext;
    executionContext |= <span class="hljs-title class_">CommitContext</span>;
    <span class="hljs-keyword">var</span> prevInteractions = <span class="hljs-title function_">pushInteractions</span>(root); <span class="hljs-comment">// It&#x27;s important that ALL pending passive effect destroy functions are called</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1131">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1131">&#x00a7;</a>
              </div>
              <p>before ANY passive effect create functions are called.
Otherwise effects in sibling components might interfere with each other.
e.g. a destroy function in one component may unintentionally override a ref
value set by a create function in another component.
Layout effects have the same constraint.
First pass: Destroy stale passive effects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> unmountEffects = pendingPassiveHookEffectsUnmount;
    pendingPassiveHookEffectsUnmount = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; unmountEffects.<span class="hljs-property">length</span>; i += <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">var</span> _effect = unmountEffects[i];
      <span class="hljs-keyword">var</span> fiber = unmountEffects[i + <span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> destroy = _effect.<span class="hljs-property">destroy</span>;
      _effect.<span class="hljs-property">destroy</span> = <span class="hljs-literal">undefined</span>;

      {
        fiber.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">PassiveUnmountPendingDev</span>;
        <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>;

        <span class="hljs-keyword">if</span> (alternate !== <span class="hljs-literal">null</span>) {
          alternate.<span class="hljs-property">flags</span> &amp;= ~<span class="hljs-title class_">PassiveUnmountPendingDev</span>;
        }
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> destroy === <span class="hljs-string">&#x27;function&#x27;</span>) {
        {
          <span class="hljs-title function_">setCurrentFiber</span>(fiber);

          {
            <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, destroy, <span class="hljs-literal">null</span>);
          }

          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
            <span class="hljs-keyword">if</span> (!(fiber !== <span class="hljs-literal">null</span>)) {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should be working on an effect.&quot;</span>);
              }
            }

            <span class="hljs-keyword">var</span> error = <span class="hljs-title function_">clearCaughtError</span>();
            <span class="hljs-title function_">captureCommitPhaseError</span>(fiber, error);
          }

          <span class="hljs-title function_">resetCurrentFiber</span>();
        }
      }
    } <span class="hljs-comment">// Second pass: Create new passive effects.</span>


    <span class="hljs-keyword">var</span> mountEffects = pendingPassiveHookEffectsMount;
    pendingPassiveHookEffectsMount = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; mountEffects.<span class="hljs-property">length</span>; _i += <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">var</span> _effect2 = mountEffects[_i];
      <span class="hljs-keyword">var</span> _fiber = mountEffects[_i + <span class="hljs-number">1</span>];

      {
        <span class="hljs-title function_">setCurrentFiber</span>(_fiber);

        {
          <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, invokePassiveEffectCreate, <span class="hljs-literal">null</span>, _effect2);
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
          <span class="hljs-keyword">if</span> (!(_fiber !== <span class="hljs-literal">null</span>)) {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Should be working on an effect.&quot;</span>);
            }
          }

          <span class="hljs-keyword">var</span> _error4 = <span class="hljs-title function_">clearCaughtError</span>();

          <span class="hljs-title function_">captureCommitPhaseError</span>(_fiber, _error4);
        }

        <span class="hljs-title function_">resetCurrentFiber</span>();
      }
    } <span class="hljs-comment">// Note: This currently assumes there are no passive effects on the root fiber</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1132">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1132">&#x00a7;</a>
              </div>
              <p>because the root is not part of its own effect list.
This could change in the future.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> effect = root.<span class="hljs-property">current</span>.<span class="hljs-property">firstEffect</span>;

    <span class="hljs-keyword">while</span> (effect !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> nextNextEffect = effect.<span class="hljs-property">nextEffect</span>; <span class="hljs-comment">// Remove nextEffect pointer to assist GC</span>

      effect.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (effect.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">Deletion</span>) {
        <span class="hljs-title function_">detachFiberAfterEffects</span>(effect);
      }

      effect = nextNextEffect;
    }

    {
      <span class="hljs-title function_">popInteractions</span>(prevInteractions);
      <span class="hljs-title function_">finishPendingInteractions</span>(root, lanes);
    }

    {
      isFlushingPassiveEffects = <span class="hljs-literal">false</span>;
    }

    {
      <span class="hljs-title function_">markPassiveEffectsStopped</span>();
    }

    executionContext = prevExecutionContext;
    <span class="hljs-title function_">flushSyncCallbackQueue</span>(); <span class="hljs-comment">// If additional passive effects were scheduled, increment a counter. If this</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1133">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1133">&#x00a7;</a>
              </div>
              <p>exceeds the limit, we’ll fire a warning.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    nestedPassiveUpdateCount = rootWithPendingPassiveEffects === <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : nestedPassiveUpdateCount + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isAlreadyFailedLegacyErrorBoundary</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">return</span> legacyErrorBoundariesThatAlreadyFailed !== <span class="hljs-literal">null</span> &amp;&amp; legacyErrorBoundariesThatAlreadyFailed.<span class="hljs-title function_">has</span>(instance);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markLegacyErrorBoundaryAsFailed</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">if</span> (legacyErrorBoundariesThatAlreadyFailed === <span class="hljs-literal">null</span>) {
      legacyErrorBoundariesThatAlreadyFailed = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([instance]);
    } <span class="hljs-keyword">else</span> {
      legacyErrorBoundariesThatAlreadyFailed.<span class="hljs-title function_">add</span>(instance);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareToThrowUncaughtError</span>(<span class="hljs-params">error</span>) {
    <span class="hljs-keyword">if</span> (!hasUncaughtError) {
      hasUncaughtError = <span class="hljs-literal">true</span>;
      firstUncaughtError = error;
    }
  }

  <span class="hljs-keyword">var</span> onUncaughtError = prepareToThrowUncaughtError;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">captureCommitPhaseErrorOnRoot</span>(<span class="hljs-params">rootFiber, sourceFiber, error</span>) {
    <span class="hljs-keyword">var</span> errorInfo = <span class="hljs-title function_">createCapturedValue</span>(error, sourceFiber);
    <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createRootErrorUpdate</span>(rootFiber, errorInfo, <span class="hljs-title class_">SyncLane</span>);
    <span class="hljs-title function_">enqueueUpdate</span>(rootFiber, update);
    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
    <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">markUpdateLaneFromFiberToRoot</span>(rootFiber, <span class="hljs-title class_">SyncLane</span>);

    <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">markRootUpdated</span>(root, <span class="hljs-title class_">SyncLane</span>, eventTime);
      <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);
      <span class="hljs-title function_">schedulePendingInteractions</span>(root, <span class="hljs-title class_">SyncLane</span>);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">captureCommitPhaseError</span>(<span class="hljs-params">sourceFiber, error</span>) {
    <span class="hljs-keyword">if</span> (sourceFiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1134">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1134">&#x00a7;</a>
              </div>
              <p>Error was thrown at the root. There is no parent, so the root
itself should capture it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">captureCommitPhaseErrorOnRoot</span>(sourceFiber, sourceFiber, error);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> fiber = sourceFiber.<span class="hljs-property">return</span>;

    <span class="hljs-keyword">while</span> (fiber !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostRoot</span>) {
        <span class="hljs-title function_">captureCommitPhaseErrorOnRoot</span>(fiber, sourceFiber, error);
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) {
        <span class="hljs-keyword">var</span> ctor = fiber.<span class="hljs-property">type</span>;
        <span class="hljs-keyword">var</span> instance = fiber.<span class="hljs-property">stateNode</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> ctor.<span class="hljs-property">getDerivedStateFromError</span> === <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidCatch</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; !<span class="hljs-title function_">isAlreadyFailedLegacyErrorBoundary</span>(instance)) {
          <span class="hljs-keyword">var</span> errorInfo = <span class="hljs-title function_">createCapturedValue</span>(error, sourceFiber);
          <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createClassErrorUpdate</span>(fiber, errorInfo, <span class="hljs-title class_">SyncLane</span>);
          <span class="hljs-title function_">enqueueUpdate</span>(fiber, update);
          <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
          <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">markUpdateLaneFromFiberToRoot</span>(fiber, <span class="hljs-title class_">SyncLane</span>);

          <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
            <span class="hljs-title function_">markRootUpdated</span>(root, <span class="hljs-title class_">SyncLane</span>, eventTime);
            <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);
            <span class="hljs-title function_">schedulePendingInteractions</span>(root, <span class="hljs-title class_">SyncLane</span>);
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1135">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1135">&#x00a7;</a>
              </div>
              <p>This component has already been unmounted.
We can’t schedule any follow up work for the root because the fiber is already unmounted,
but we can still call the log-only boundary so the error isn’t swallowed.</p>
<p>TODO This is only a temporary bandaid for the old reconciler fork.
We can delete this special case once the new fork is merged.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> instance.<span class="hljs-property">componentDidCatch</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; !<span class="hljs-title function_">isAlreadyFailedLegacyErrorBoundary</span>(instance)) {
              <span class="hljs-keyword">try</span> {
                instance.<span class="hljs-title function_">componentDidCatch</span>(error, errorInfo);
              } <span class="hljs-keyword">catch</span> (errorToIgnore) {<span class="hljs-comment">// TODO Ignore this error? Rethrow it?</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1136">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1136">&#x00a7;</a>
              </div>
              <p>This is kind of an edge case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              }
            }
          }

          <span class="hljs-keyword">return</span>;
        }
      }

      fiber = fiber.<span class="hljs-property">return</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">pingSuspendedRoot</span>(<span class="hljs-params">root, wakeable, pingedLanes</span>) {
    <span class="hljs-keyword">var</span> pingCache = root.<span class="hljs-property">pingCache</span>;

    <span class="hljs-keyword">if</span> (pingCache !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1137">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1137">&#x00a7;</a>
              </div>
              <p>The wakeable resolved, so we no longer need to memoize, because it will
never be thrown again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      pingCache.<span class="hljs-title function_">delete</span>(wakeable);
    }

    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
    <span class="hljs-title function_">markRootPinged</span>(root, pingedLanes);

    <span class="hljs-keyword">if</span> (workInProgressRoot === root &amp;&amp; <span class="hljs-title function_">isSubsetOfLanes</span>(workInProgressRootRenderLanes, pingedLanes)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1138">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1138">&#x00a7;</a>
              </div>
              <p>Received a ping at the same priority level at which we’re currently
rendering. We might want to restart this render. This should mirror
the logic of whether or not a root suspends once it completes.
TODO: If we’re rendering sync either due to Sync, Batched or expired,
we should probably never restart.
If we’re suspended with delay, or if it’s a retry, we’ll always suspend
so we can always restart.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (workInProgressRootExitStatus === <span class="hljs-title class_">RootSuspendedWithDelay</span> || workInProgressRootExitStatus === <span class="hljs-title class_">RootSuspended</span> &amp;&amp; <span class="hljs-title function_">includesOnlyRetries</span>(workInProgressRootRenderLanes) &amp;&amp; <span class="hljs-title function_">now</span>() - globalMostRecentFallbackTime &lt; <span class="hljs-variable constant_">FALLBACK_THROTTLE_MS</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1139">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1139">&#x00a7;</a>
              </div>
              <p>Restart from the root.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">prepareFreshStack</span>(root, <span class="hljs-title class_">NoLanes</span>);
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1140">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1140">&#x00a7;</a>
              </div>
              <p>Even though we can’t restart right now, we might get an
opportunity later. So we mark this render as having a ping.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgressRootPingedLanes = <span class="hljs-title function_">mergeLanes</span>(workInProgressRootPingedLanes, pingedLanes);
      }
    }

    <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);
    <span class="hljs-title function_">schedulePendingInteractions</span>(root, pingedLanes);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">retryTimedOutBoundary</span>(<span class="hljs-params">boundaryFiber, retryLane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1141">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1141">&#x00a7;</a>
              </div>
              <p>The boundary fiber (a Suspense component or SuspenseList component)
previously was rendered in its fallback state. One of the promises that
suspended it has resolved, which means at least part of the tree was
likely unblocked. Try rendering again, at a new expiration time.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (retryLane === <span class="hljs-title class_">NoLane</span>) {
      retryLane = <span class="hljs-title function_">requestRetryLane</span>(boundaryFiber);
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Special case idle priority?</span>


    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
    <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">markUpdateLaneFromFiberToRoot</span>(boundaryFiber, retryLane);

    <span class="hljs-keyword">if</span> (root !== <span class="hljs-literal">null</span>) {
      <span class="hljs-title function_">markRootUpdated</span>(root, retryLane, eventTime);
      <span class="hljs-title function_">ensureRootIsScheduled</span>(root, eventTime);
      <span class="hljs-title function_">schedulePendingInteractions</span>(root, retryLane);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">retryDehydratedSuspenseBoundary</span>(<span class="hljs-params">boundaryFiber</span>) {
    <span class="hljs-keyword">var</span> suspenseState = boundaryFiber.<span class="hljs-property">memoizedState</span>;
    <span class="hljs-keyword">var</span> retryLane = <span class="hljs-title class_">NoLane</span>;

    <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span>) {
      retryLane = suspenseState.<span class="hljs-property">retryLane</span>;
    }

    <span class="hljs-title function_">retryTimedOutBoundary</span>(boundaryFiber, retryLane);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveRetryWakeable</span>(<span class="hljs-params">boundaryFiber, wakeable</span>) {
    <span class="hljs-keyword">var</span> retryLane = <span class="hljs-title class_">NoLane</span>; <span class="hljs-comment">// Default</span>

    <span class="hljs-keyword">var</span> retryCache;

    {
      <span class="hljs-keyword">switch</span> (boundaryFiber.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
          retryCache = boundaryFiber.<span class="hljs-property">stateNode</span>;
          <span class="hljs-keyword">var</span> suspenseState = boundaryFiber.<span class="hljs-property">memoizedState</span>;

          <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span>) {
            retryLane = suspenseState.<span class="hljs-property">retryLane</span>;
          }

          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseListComponent</span>:
          retryCache = boundaryFiber.<span class="hljs-property">stateNode</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-attr">default</span>:
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Pinged unknown suspense boundary type. This is probably a bug in React.&quot;</span>);
            }
          }

      }
    }

    <span class="hljs-keyword">if</span> (retryCache !== <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1142">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1142">&#x00a7;</a>
              </div>
              <p>The wakeable resolved, so we no longer need to memoize, because it will
never be thrown again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      retryCache.<span class="hljs-title function_">delete</span>(wakeable);
    }

    <span class="hljs-title function_">retryTimedOutBoundary</span>(boundaryFiber, retryLane);
  } <span class="hljs-comment">// Computes the next Just Noticeable Difference (JND) boundary.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1143">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1143">&#x00a7;</a>
              </div>
              <p>The theory is that a person can’t tell the difference between small differences in time.
Therefore, if we wait a bit longer than necessary that won’t translate to a noticeable
difference in the experience. However, waiting for longer might mean that we can avoid
showing an intermediate loading state. The longer we have already waited, the harder it
is to tell small differences in time. Therefore, the longer we’ve already waited,
the longer we can wait additionally. At some point we have to give up though.
We pick a train model where the next boundary commits at a consistent schedule.
These particular numbers are vague estimates. We expect to adjust them based on research.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">jnd</span>(<span class="hljs-params">timeElapsed</span>) {
    <span class="hljs-keyword">return</span> timeElapsed &lt; <span class="hljs-number">120</span> ? <span class="hljs-number">120</span> : timeElapsed &lt; <span class="hljs-number">480</span> ? <span class="hljs-number">480</span> : timeElapsed &lt; <span class="hljs-number">1080</span> ? <span class="hljs-number">1080</span> : timeElapsed &lt; <span class="hljs-number">1920</span> ? <span class="hljs-number">1920</span> : timeElapsed &lt; <span class="hljs-number">3000</span> ? <span class="hljs-number">3000</span> : timeElapsed &lt; <span class="hljs-number">4320</span> ? <span class="hljs-number">4320</span> : <span class="hljs-title function_">ceil</span>(timeElapsed / <span class="hljs-number">1960</span>) * <span class="hljs-number">1960</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">checkForNestedUpdates</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (nestedUpdateCount &gt; <span class="hljs-variable constant_">NESTED_UPDATE_LIMIT</span>) {
      nestedUpdateCount = <span class="hljs-number">0</span>;
      rootWithNestedUpdates = <span class="hljs-literal">null</span>;

      {
        {
          <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.&quot;</span>);
        }
      }
    }

    {
      <span class="hljs-keyword">if</span> (nestedPassiveUpdateCount &gt; <span class="hljs-variable constant_">NESTED_PASSIVE_UPDATE_LIMIT</span>) {
        nestedPassiveUpdateCount = <span class="hljs-number">0</span>;

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Maximum update depth exceeded. This can happen when a component &#x27;</span> + <span class="hljs-string">&quot;calls setState inside useEffect, but useEffect either doesn&#x27;t &quot;</span> + <span class="hljs-string">&#x27;have a dependency array, or one of the dependencies changes on &#x27;</span> + <span class="hljs-string">&#x27;every render.&#x27;</span>);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">flushRenderPhaseStrictModeWarningsInDEV</span>(<span class="hljs-params"></span>) {
    {
      <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-title function_">flushLegacyContextWarning</span>();

      {
        <span class="hljs-title class_">ReactStrictModeWarnings</span>.<span class="hljs-title function_">flushPendingUnsafeLifecycleWarnings</span>();
      }
    }
  }

  <span class="hljs-keyword">var</span> didWarnStateUpdateForNotYetMountedComponent = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnAboutUpdateOnNotYetMountedFiberInDEV</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">if</span> ((executionContext &amp; <span class="hljs-title class_">RenderContext</span>) !== <span class="hljs-title class_">NoContext</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1144">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1144">&#x00a7;</a>
              </div>
              <p>We let the other warning about render phase updates deal with this one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (!(fiber.<span class="hljs-property">mode</span> &amp; (<span class="hljs-title class_">BlockingMode</span> | <span class="hljs-title class_">ConcurrentMode</span>))) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> tag = fiber.<span class="hljs-property">tag</span>;

      <span class="hljs-keyword">if</span> (tag !== <span class="hljs-title class_">IndeterminateComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">HostRoot</span> &amp;&amp; tag !== <span class="hljs-title class_">ClassComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">FunctionComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">ForwardRef</span> &amp;&amp; tag !== <span class="hljs-title class_">MemoComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">SimpleMemoComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">Block</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1145">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1145">&#x00a7;</a>
              </div>
              <p>Only warn for user-defined components, not internal ones like Suspense.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// We show the whole stack but dedupe on the top component&#x27;s name because</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1146">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1146">&#x00a7;</a>
              </div>
              <p>the problematic code almost always lies inside that component.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;ReactComponent&#x27;</span>;

      <span class="hljs-keyword">if</span> (didWarnStateUpdateForNotYetMountedComponent !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (didWarnStateUpdateForNotYetMountedComponent.<span class="hljs-title function_">has</span>(componentName)) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnStateUpdateForNotYetMountedComponent.<span class="hljs-title function_">add</span>(componentName);
      } <span class="hljs-keyword">else</span> {
        didWarnStateUpdateForNotYetMountedComponent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([componentName]);
      }

      <span class="hljs-keyword">var</span> previousFiber = current;

      <span class="hljs-keyword">try</span> {
        <span class="hljs-title function_">setCurrentFiber</span>(fiber);

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Can&#x27;t perform a React state update on a component that hasn&#x27;t mounted yet. &quot;</span> + <span class="hljs-string">&#x27;This indicates that you have a side-effect in your render function that &#x27;</span> + <span class="hljs-string">&#x27;asynchronously later calls tries to update the component. Move this work to &#x27;</span> + <span class="hljs-string">&#x27;useEffect instead.&#x27;</span>);
      } <span class="hljs-keyword">finally</span> {
        <span class="hljs-keyword">if</span> (previousFiber) {
          <span class="hljs-title function_">setCurrentFiber</span>(fiber);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">resetCurrentFiber</span>();
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> didWarnStateUpdateForUnmountedComponent = <span class="hljs-literal">null</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnAboutUpdateOnUnmountedFiberInDEV</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">var</span> tag = fiber.<span class="hljs-property">tag</span>;

      <span class="hljs-keyword">if</span> (tag !== <span class="hljs-title class_">HostRoot</span> &amp;&amp; tag !== <span class="hljs-title class_">ClassComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">FunctionComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">ForwardRef</span> &amp;&amp; tag !== <span class="hljs-title class_">MemoComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">SimpleMemoComponent</span> &amp;&amp; tag !== <span class="hljs-title class_">Block</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1147">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1147">&#x00a7;</a>
              </div>
              <p>Only warn for user-defined components, not internal ones like Suspense.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// If there are pending passive effects unmounts for this Fiber,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1148">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1148">&#x00a7;</a>
              </div>
              <p>we can assume that they would have prevented this update.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">if</span> ((fiber.<span class="hljs-property">flags</span> &amp; <span class="hljs-title class_">PassiveUnmountPendingDev</span>) !== <span class="hljs-title class_">NoFlags</span>) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// We show the whole stack but dedupe on the top component&#x27;s name because</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1149">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1149">&#x00a7;</a>
              </div>
              <p>the problematic code almost always lies inside that component.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

      <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;ReactComponent&#x27;</span>;

      <span class="hljs-keyword">if</span> (didWarnStateUpdateForUnmountedComponent !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (didWarnStateUpdateForUnmountedComponent.<span class="hljs-title function_">has</span>(componentName)) {
          <span class="hljs-keyword">return</span>;
        }

        didWarnStateUpdateForUnmountedComponent.<span class="hljs-title function_">add</span>(componentName);
      } <span class="hljs-keyword">else</span> {
        didWarnStateUpdateForUnmountedComponent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([componentName]);
      }

      <span class="hljs-keyword">if</span> (isFlushingPassiveEffects); <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">var</span> previousFiber = current;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">setCurrentFiber</span>(fiber);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Can&#x27;t perform a React state update on an unmounted component. This &quot;</span> + <span class="hljs-string">&#x27;is a no-op, but it indicates a memory leak in your application. To &#x27;</span> + <span class="hljs-string">&#x27;fix, cancel all subscriptions and asynchronous tasks in %s.&#x27;</span>, tag === <span class="hljs-title class_">ClassComponent</span> ? <span class="hljs-string">&#x27;the componentWillUnmount method&#x27;</span> : <span class="hljs-string">&#x27;a useEffect cleanup function&#x27;</span>);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-keyword">if</span> (previousFiber) {
            <span class="hljs-title function_">setCurrentFiber</span>(fiber);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">resetCurrentFiber</span>();
          }
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> beginWork$<span class="hljs-number">1</span>;

  {
    <span class="hljs-keyword">var</span> dummyFiber = <span class="hljs-literal">null</span>;

    beginWork$<span class="hljs-number">1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">current, unitOfWork, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1150">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1150">&#x00a7;</a>
              </div>
              <p>If a component throws an error, we replay it again in a synchronously
dispatched event, so that the debugger will treat it as an uncaught
error See ReactErrorUtils for more information.
Before entering the begin phase, copy the work-in-progress onto a dummy
fiber. If beginWork throws, we’ll use this to reset the state.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> originalWorkInProgressCopy = <span class="hljs-title function_">assignFiberPropertiesInDEV</span>(dummyFiber, unitOfWork);

      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">beginWork</span>(current, unitOfWork, lanes);
      } <span class="hljs-keyword">catch</span> (originalError) {
        <span class="hljs-keyword">if</span> (originalError !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> originalError === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> originalError.<span class="hljs-property">then</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1151">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1151">&#x00a7;</a>
              </div>
              <p>Don’t replay promises. Treat everything else like an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">throw</span> originalError;
        } <span class="hljs-comment">// Keep this code in sync with handleError; any changes here must have</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1152">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1152">&#x00a7;</a>
              </div>
              <p>corresponding changes there.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

        <span class="hljs-title function_">resetContextDependencies</span>();
        <span class="hljs-title function_">resetHooksAfterThrow</span>(); <span class="hljs-comment">// Don&#x27;t reset current debug fiber, since we&#x27;re about to work on the</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1153">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1153">&#x00a7;</a>
              </div>
              <p>same fiber again.
Unwind the failed stack frame</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-title function_">unwindInterruptedWork</span>(unitOfWork); <span class="hljs-comment">// Restore the original properties of the fiber.</span>

        <span class="hljs-title function_">assignFiberPropertiesInDEV</span>(unitOfWork, originalWorkInProgressCopy);

        <span class="hljs-keyword">if</span> (unitOfWork.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ProfileMode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1154">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1154">&#x00a7;</a>
              </div>
              <p>Reset the profiler timer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">startProfilerTimer</span>(unitOfWork);
        } <span class="hljs-comment">// Run beginWork again.</span>


        <span class="hljs-title function_">invokeGuardedCallback</span>(<span class="hljs-literal">null</span>, beginWork, <span class="hljs-literal">null</span>, current, unitOfWork, lanes);

        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">hasCaughtError</span>()) {
          <span class="hljs-keyword">var</span> replayError = <span class="hljs-title function_">clearCaughtError</span>(); <span class="hljs-comment">// `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1155">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1155">&#x00a7;</a>
              </div>
              <p>Rethrow this error instead of the original one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">throw</span> replayError;
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1156">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1156">&#x00a7;</a>
              </div>
              <p>This branch is reachable if the render phase is impure.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">throw</span> originalError;
        }
      }
    };
  }

  <span class="hljs-keyword">var</span> didWarnAboutUpdateInRender = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">var</span> didWarnAboutUpdateInRenderForAnotherComponent;

  {
    didWarnAboutUpdateInRenderForAnotherComponent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnAboutRenderPhaseUpdatesInDEV</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">if</span> (isRendering &amp;&amp; (executionContext &amp; <span class="hljs-title class_">RenderContext</span>) !== <span class="hljs-title class_">NoContext</span> &amp;&amp; !<span class="hljs-title function_">getIsUpdatingOpaqueValueInRenderPhaseInDEV</span>()) {
        <span class="hljs-keyword">switch</span> (fiber.<span class="hljs-property">tag</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
            {
              <span class="hljs-keyword">var</span> renderingComponentName = workInProgress &amp;&amp; <span class="hljs-title function_">getComponentName</span>(workInProgress.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>; <span class="hljs-comment">// Dedupe by the rendering component because it&#x27;s the one that needs to be fixed.</span>

              <span class="hljs-keyword">var</span> dedupeKey = renderingComponentName;

              <span class="hljs-keyword">if</span> (!didWarnAboutUpdateInRenderForAnotherComponent.<span class="hljs-title function_">has</span>(dedupeKey)) {
                didWarnAboutUpdateInRenderForAnotherComponent.<span class="hljs-title function_">add</span>(dedupeKey);
                <span class="hljs-keyword">var</span> setStateComponentName = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>;

                <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Cannot update a component (`%s`) while rendering a &#x27;</span> + <span class="hljs-string">&#x27;different component (`%s`). To locate the bad setState() call inside `%s`, &#x27;</span> + <span class="hljs-string">&#x27;follow the stack trace as described in https://reactjs.org/link/setstate-in-render&#x27;</span>, setStateComponentName, renderingComponentName, renderingComponentName);
              }

              <span class="hljs-keyword">break</span>;
            }

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
            {
              <span class="hljs-keyword">if</span> (!didWarnAboutUpdateInRender) {
                <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Cannot update during an existing state transition (such as &#x27;</span> + <span class="hljs-string">&#x27;within `render`). Render methods should be a pure &#x27;</span> + <span class="hljs-string">&#x27;function of props and state.&#x27;</span>);

                didWarnAboutUpdateInRender = <span class="hljs-literal">true</span>;
              }

              <span class="hljs-keyword">break</span>;
            }
        }
      }
    }
  } <span class="hljs-comment">// a &#x27;shared&#x27; variable that changes when act() opens/closes in tests.</span>


  <span class="hljs-keyword">var</span> <span class="hljs-title class_">IsThisRendererActing</span> = {
    <span class="hljs-attr">current</span>: <span class="hljs-literal">false</span>
  };
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnIfNotScopedWithMatchingAct</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-title class_">IsSomeRendererActing</span>.<span class="hljs-property">current</span> === <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-title class_">IsThisRendererActing</span>.<span class="hljs-property">current</span> !== <span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">var</span> previousFiber = current;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">setCurrentFiber</span>(fiber);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;It looks like you&#x27;re using the wrong act() around your test interactions.\n&quot;</span> + <span class="hljs-string">&#x27;Be sure to use the matching version of act() corresponding to your renderer:\n\n&#x27;</span> + <span class="hljs-string">&#x27;// for react-dom:\n&#x27;</span> + <span class="hljs-comment">// Break up imports to avoid accidentally parsing them as dependencies.</span>
            <span class="hljs-string">&#x27;import {act} fr&#x27;</span> + <span class="hljs-string">&quot;om &#x27;react-dom/test-utils&#x27;;\n&quot;</span> + <span class="hljs-string">&#x27;// ...\n&#x27;</span> + <span class="hljs-string">&#x27;act(() =&gt; ...);\n\n&#x27;</span> + <span class="hljs-string">&#x27;// for react-test-renderer:\n&#x27;</span> + <span class="hljs-comment">// Break up imports to avoid accidentally parsing them as dependencies.</span>
            <span class="hljs-string">&#x27;import TestRenderer fr&#x27;</span> + <span class="hljs-string">&quot;om react-test-renderer&#x27;;\n&quot;</span> + <span class="hljs-string">&#x27;const {act} = TestRenderer;\n&#x27;</span> + <span class="hljs-string">&#x27;// ...\n&#x27;</span> + <span class="hljs-string">&#x27;act(() =&gt; ...);&#x27;</span>);
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-keyword">if</span> (previousFiber) {
            <span class="hljs-title function_">setCurrentFiber</span>(fiber);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">resetCurrentFiber</span>();
          }
        }
      }
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnIfNotCurrentlyActingEffectsInDEV</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">if</span> ((fiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) !== <span class="hljs-title class_">NoMode</span> &amp;&amp; <span class="hljs-title class_">IsSomeRendererActing</span>.<span class="hljs-property">current</span> === <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-title class_">IsThisRendererActing</span>.<span class="hljs-property">current</span> === <span class="hljs-literal">false</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;An update to %s ran an effect, but was not wrapped in act(...).\n\n&#x27;</span> + <span class="hljs-string">&#x27;When testing, code that causes React state updates should be &#x27;</span> + <span class="hljs-string">&#x27;wrapped into act(...):\n\n&#x27;</span> + <span class="hljs-string">&#x27;act(() =&gt; {\n&#x27;</span> + <span class="hljs-string">&#x27;  /* fire events that update state */\n&#x27;</span> + <span class="hljs-string">&#x27;});\n&#x27;</span> + <span class="hljs-string">&#x27;/* assert on the output */\n\n&#x27;</span> + <span class="hljs-string">&quot;This ensures that you&#x27;re testing the behavior the user would see &quot;</span> + <span class="hljs-string">&#x27;in the browser.&#x27;</span> + <span class="hljs-string">&#x27; Learn more at https://reactjs.org/link/wrap-tests-with-act&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>));
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnIfNotCurrentlyActingUpdatesInDEV</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">if</span> (executionContext === <span class="hljs-title class_">NoContext</span> &amp;&amp; <span class="hljs-title class_">IsSomeRendererActing</span>.<span class="hljs-property">current</span> === <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-title class_">IsThisRendererActing</span>.<span class="hljs-property">current</span> === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">var</span> previousFiber = current;

        <span class="hljs-keyword">try</span> {
          <span class="hljs-title function_">setCurrentFiber</span>(fiber);

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;An update to %s inside a test was not wrapped in act(...).\n\n&#x27;</span> + <span class="hljs-string">&#x27;When testing, code that causes React state updates should be &#x27;</span> + <span class="hljs-string">&#x27;wrapped into act(...):\n\n&#x27;</span> + <span class="hljs-string">&#x27;act(() =&gt; {\n&#x27;</span> + <span class="hljs-string">&#x27;  /* fire events that update state */\n&#x27;</span> + <span class="hljs-string">&#x27;});\n&#x27;</span> + <span class="hljs-string">&#x27;/* assert on the output */\n\n&#x27;</span> + <span class="hljs-string">&quot;This ensures that you&#x27;re testing the behavior the user would see &quot;</span> + <span class="hljs-string">&#x27;in the browser.&#x27;</span> + <span class="hljs-string">&#x27; Learn more at https://reactjs.org/link/wrap-tests-with-act&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>));
        } <span class="hljs-keyword">finally</span> {
          <span class="hljs-keyword">if</span> (previousFiber) {
            <span class="hljs-title function_">setCurrentFiber</span>(fiber);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">resetCurrentFiber</span>();
          }
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; <span class="hljs-comment">// In tests, we want to enforce a mocked scheduler.</span>

  <span class="hljs-keyword">var</span> didWarnAboutUnmockedScheduler = <span class="hljs-literal">false</span>; <span class="hljs-comment">// TODO Before we release concurrent mode, revisit this and decide whether a mocked</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1157">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1157">&#x00a7;</a>
              </div>
              <p>scheduler is the actual recommendation. The alternative could be a testing build,
a new lib, or whatever; we dunno just yet. This message is for early adopters
to get their tests right.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnIfUnmockedScheduler</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">if</span> (didWarnAboutUnmockedScheduler === <span class="hljs-literal">false</span> &amp;&amp; unstable_flushAllWithoutAsserting === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">BlockingMode</span> || fiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">ConcurrentMode</span>) {
          didWarnAboutUnmockedScheduler = <span class="hljs-literal">true</span>;

          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;In Concurrent or Sync modes, the &quot;scheduler&quot; module needs to be mocked &#x27;</span> + <span class="hljs-string">&#x27;to guarantee consistent behaviour across tests and browsers. &#x27;</span> + <span class="hljs-string">&#x27;For example, with jest: \n&#x27;</span> + <span class="hljs-comment">// Break up requires to avoid accidentally parsing them as dependencies.</span>
            <span class="hljs-string">&quot;jest.mock(&#x27;scheduler&#x27;, () =&gt; require&quot;</span> + <span class="hljs-string">&quot;(&#x27;scheduler/unstable_mock&#x27;));\n\n&quot;</span> + <span class="hljs-string">&#x27;For more info, visit https://reactjs.org/link/mock-scheduler&#x27;</span>);
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">computeThreadID</span>(<span class="hljs-params">root, lane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1158">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1158">&#x00a7;</a>
              </div>
              <p>Interaction threads are unique per root and expiration time.
NOTE: Intentionally unsound cast. All that matters is that it’s a number
and it represents a batch of work. Could make a helper function instead,
but meh this is fine for now.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> lane * <span class="hljs-number">1000</span> + root.<span class="hljs-property">interactionThreadID</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markSpawnedWork</span>(<span class="hljs-params">lane</span>) {

    <span class="hljs-keyword">if</span> (spawnedWorkDuringRender === <span class="hljs-literal">null</span>) {
      spawnedWorkDuringRender = [lane];
    } <span class="hljs-keyword">else</span> {
      spawnedWorkDuringRender.<span class="hljs-title function_">push</span>(lane);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleInteractions</span>(<span class="hljs-params">root, lane, interactions</span>) {

    <span class="hljs-keyword">if</span> (interactions.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> pendingInteractionMap = root.<span class="hljs-property">pendingInteractionMap</span>;
      <span class="hljs-keyword">var</span> pendingInteractions = pendingInteractionMap.<span class="hljs-title function_">get</span>(lane);

      <span class="hljs-keyword">if</span> (pendingInteractions != <span class="hljs-literal">null</span>) {
        interactions.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) {
          <span class="hljs-keyword">if</span> (!pendingInteractions.<span class="hljs-title function_">has</span>(interaction)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1159">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1159">&#x00a7;</a>
              </div>
              <p>Update the pending async work count for previously unscheduled interaction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            interaction.<span class="hljs-property">__count</span>++;
          }

          pendingInteractions.<span class="hljs-title function_">add</span>(interaction);
        });
      } <span class="hljs-keyword">else</span> {
        pendingInteractionMap.<span class="hljs-title function_">set</span>(lane, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(interactions)); <span class="hljs-comment">// Update the pending async work count for the current interactions.</span>

        interactions.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) {
          interaction.<span class="hljs-property">__count</span>++;
        });
      }

      <span class="hljs-keyword">var</span> subscriber = __subscriberRef.<span class="hljs-property">current</span>;

      <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> threadID = <span class="hljs-title function_">computeThreadID</span>(root, lane);
        subscriber.<span class="hljs-title function_">onWorkScheduled</span>(interactions, threadID);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">schedulePendingInteractions</span>(<span class="hljs-params">root, lane</span>) {

    <span class="hljs-title function_">scheduleInteractions</span>(root, lane, __interactionsRef.<span class="hljs-property">current</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">startWorkOnPendingInteractions</span>(<span class="hljs-params">root, lanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1160">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1160">&#x00a7;</a>
              </div>
              <p>we can accurately attribute time spent working on it, And so that cascading
work triggered during the render phase will be associated with it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> interactions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    root.<span class="hljs-property">pendingInteractionMap</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">scheduledInteractions, scheduledLane</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">includesSomeLane</span>(lanes, scheduledLane)) {
        scheduledInteractions.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) {
          <span class="hljs-keyword">return</span> interactions.<span class="hljs-title function_">add</span>(interaction);
        });
      }
    }); <span class="hljs-comment">// Store the current set of interactions on the FiberRoot for a few reasons:</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1161">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1161">&#x00a7;</a>
              </div>
              <p>We can re-use it in hot functions like performConcurrentWorkOnRoot()
without having to recalculate it. We will also use it in commitWork() to
pass to any Profiler onRender() hooks. This also provides DevTools with a
way to access it when the onCommitRoot() hook is called.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    root.<span class="hljs-property">memoizedInteractions</span> = interactions;

    <span class="hljs-keyword">if</span> (interactions.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">var</span> subscriber = __subscriberRef.<span class="hljs-property">current</span>;

      <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> threadID = <span class="hljs-title function_">computeThreadID</span>(root, lanes);

        <span class="hljs-keyword">try</span> {
          subscriber.<span class="hljs-title function_">onWorkStarted</span>(interactions, threadID);
        } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1162">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1162">&#x00a7;</a>
              </div>
              <p>If the subscriber throws, rethrow it in a separate task</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">throw</span> error;
          });
        }
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">finishPendingInteractions</span>(<span class="hljs-params">root, committedLanes</span>) {

    <span class="hljs-keyword">var</span> remainingLanesAfterCommit = root.<span class="hljs-property">pendingLanes</span>;
    <span class="hljs-keyword">var</span> subscriber;

    <span class="hljs-keyword">try</span> {
      subscriber = __subscriberRef.<span class="hljs-property">current</span>;

      <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span> &amp;&amp; root.<span class="hljs-property">memoizedInteractions</span>.<span class="hljs-property">size</span> &gt; <span class="hljs-number">0</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1163">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1163">&#x00a7;</a>
              </div>
              <p>FIXME: More than one lane can finish in a single commit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> threadID = <span class="hljs-title function_">computeThreadID</span>(root, committedLanes);
        subscriber.<span class="hljs-title function_">onWorkStopped</span>(root.<span class="hljs-property">memoizedInteractions</span>, threadID);
      }
    } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1164">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1164">&#x00a7;</a>
              </div>
              <p>If the subscriber throws, rethrow it in a separate task</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-keyword">throw</span> error;
      });
    } <span class="hljs-keyword">finally</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1165">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1165">&#x00a7;</a>
              </div>
              <p>Clear completed interactions from the pending Map.
Unless the render was suspended or cascading work was scheduled,
In which case– leave pending interactions until the subsequent render.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> pendingInteractionMap = root.<span class="hljs-property">pendingInteractionMap</span>;
      pendingInteractionMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">scheduledInteractions, lane</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1166">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1166">&#x00a7;</a>
              </div>
              <p>Only decrement the pending interaction count if we’re done.
If there’s still work at the current priority,
That indicates that we are waiting for suspense data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">includesSomeLane</span>(remainingLanesAfterCommit, lane)) {
          pendingInteractionMap.<span class="hljs-title function_">delete</span>(lane);
          scheduledInteractions.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">interaction</span>) {
            interaction.<span class="hljs-property">__count</span>--;

            <span class="hljs-keyword">if</span> (subscriber !== <span class="hljs-literal">null</span> &amp;&amp; interaction.<span class="hljs-property">__count</span> === <span class="hljs-number">0</span>) {
              <span class="hljs-keyword">try</span> {
                subscriber.<span class="hljs-title function_">onInteractionScheduledWorkCompleted</span>(interaction);
              } <span class="hljs-keyword">catch</span> (error) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1167">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1167">&#x00a7;</a>
              </div>
              <p>If the subscriber throws, rethrow it in a separate task</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-title function_">scheduleCallback</span>(<span class="hljs-title class_">ImmediatePriority</span>$<span class="hljs-number">1</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
                  <span class="hljs-keyword">throw</span> error;
                });
              }
            }
          });
        }
      });
    }
  } <span class="hljs-comment">// `act` testing API</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldForceFlushFallbacksInDEV</span>(<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1168">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1168">&#x00a7;</a>
              </div>
              <p>Never force flush in production. This function should get stripped out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> actingUpdatesScopeDepth &gt; <span class="hljs-number">0</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-1169">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1169">&#x00a7;</a>
              </div>
              <p>so we can tell if any async act() calls try to run in parallel.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">var</span> actingUpdatesScopeDepth = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">detachFiberAfterEffects</span>(<span class="hljs-params">fiber</span>) {
    fiber.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
    fiber.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">var</span> resolveFamily = <span class="hljs-literal">null</span>; <span class="hljs-comment">// $FlowFixMe Flow gets confused by a WeakSet feature check below.</span>

  <span class="hljs-keyword">var</span> failedBoundaries = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> setRefreshHandler = <span class="hljs-keyword">function</span> (<span class="hljs-params">handler</span>) {
    {
      resolveFamily = handler;
    }
  };
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveFunctionForHotReloading</span>(<span class="hljs-params">type</span>) {
    {
      <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1170">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1170">&#x00a7;</a>
              </div>
              <p>Hot reloading is disabled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> type;
      }

      <span class="hljs-keyword">var</span> family = <span class="hljs-title function_">resolveFamily</span>(type);

      <span class="hljs-keyword">if</span> (family === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">return</span> type;
      } <span class="hljs-comment">// Use the latest known implementation.</span>


      <span class="hljs-keyword">return</span> family.<span class="hljs-property">current</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveClassForHotReloading</span>(<span class="hljs-params">type</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1171">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1171">&#x00a7;</a>
              </div>
              <p>No implementation differences.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolveFunctionForHotReloading</span>(type);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveForwardRefForHotReloading</span>(<span class="hljs-params">type</span>) {
    {
      <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1172">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1172">&#x00a7;</a>
              </div>
              <p>Hot reloading is disabled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> type;
      }

      <span class="hljs-keyword">var</span> family = <span class="hljs-title function_">resolveFamily</span>(type);

      <span class="hljs-keyword">if</span> (family === <span class="hljs-literal">undefined</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1173">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1173">&#x00a7;</a>
              </div>
              <p>Check if we’re dealing with a real forwardRef. Don’t want to crash early.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (type !== <span class="hljs-literal">null</span> &amp;&amp; type !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-keyword">typeof</span> type.<span class="hljs-property">render</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1174">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1174">&#x00a7;</a>
              </div>
              <p>ForwardRef is special because its resolved .type is an object,
but it’s possible that we only have its inner render function in the map.
If that inner render function is different, we’ll build a new forwardRef type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> currentRender = <span class="hljs-title function_">resolveFunctionForHotReloading</span>(type.<span class="hljs-property">render</span>);

          <span class="hljs-keyword">if</span> (type.<span class="hljs-property">render</span> !== currentRender) {
            <span class="hljs-keyword">var</span> syntheticType = {
              <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_FORWARD_REF_TYPE</span>,
              <span class="hljs-attr">render</span>: currentRender
            };

            <span class="hljs-keyword">if</span> (type.<span class="hljs-property">displayName</span> !== <span class="hljs-literal">undefined</span>) {
              syntheticType.<span class="hljs-property">displayName</span> = type.<span class="hljs-property">displayName</span>;
            }

            <span class="hljs-keyword">return</span> syntheticType;
          }
        }

        <span class="hljs-keyword">return</span> type;
      } <span class="hljs-comment">// Use the latest known implementation.</span>


      <span class="hljs-keyword">return</span> family.<span class="hljs-property">current</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isCompatibleFamilyForHotReloading</span>(<span class="hljs-params">fiber, element</span>) {
    {
      <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1175">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1175">&#x00a7;</a>
              </div>
              <p>Hot reloading is disabled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }

      <span class="hljs-keyword">var</span> prevType = fiber.<span class="hljs-property">elementType</span>;
      <span class="hljs-keyword">var</span> nextType = element.<span class="hljs-property">type</span>; <span class="hljs-comment">// If we got here, we know types aren&#x27;t === equal.</span>

      <span class="hljs-keyword">var</span> needsCompareFamilies = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> $$typeofNextType = <span class="hljs-keyword">typeof</span> nextType === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; nextType !== <span class="hljs-literal">null</span> ? nextType.<span class="hljs-property">$$typeof</span> : <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">switch</span> (fiber.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
          {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextType === <span class="hljs-string">&#x27;function&#x27;</span>) {
              needsCompareFamilies = <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
          {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> nextType === <span class="hljs-string">&#x27;function&#x27;</span>) {
              needsCompareFamilies = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($$typeofNextType === <span class="hljs-variable constant_">REACT_LAZY_TYPE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1176">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1176">&#x00a7;</a>
              </div>
              <p>We don’t know the inner type yet.
We’re going to assume that the lazy inner type is stable,
and so it is sufficient to avoid reconciling it away.
We’re not going to unwrap or actually use the new lazy type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              needsCompareFamilies = <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
          {
            <span class="hljs-keyword">if</span> ($$typeofNextType === <span class="hljs-variable constant_">REACT_FORWARD_REF_TYPE</span>) {
              needsCompareFamilies = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($$typeofNextType === <span class="hljs-variable constant_">REACT_LAZY_TYPE</span>) {
              needsCompareFamilies = <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">MemoComponent</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
          {
            <span class="hljs-keyword">if</span> ($$typeofNextType === <span class="hljs-variable constant_">REACT_MEMO_TYPE</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1177">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1177">&#x00a7;</a>
              </div>
              <p>TODO: if it was but can no longer be simple,
we shouldn’t set this.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              needsCompareFamilies = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ($$typeofNextType === <span class="hljs-variable constant_">REACT_LAZY_TYPE</span>) {
              needsCompareFamilies = <span class="hljs-literal">true</span>;
            }

            <span class="hljs-keyword">break</span>;
          }

        <span class="hljs-attr">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-comment">// Check if both types have a family and it&#x27;s the same one.</span>


      <span class="hljs-keyword">if</span> (needsCompareFamilies) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1178">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1178">&#x00a7;</a>
              </div>
              <p>Note: memo() and forwardRef() we’ll compare outer rather than inner type.
This means both of them need to be registered to preserve state.
If we unwrapped and compared the inner types for wrappers instead,
then we would risk falsely saying two separate memo(Foo)
calls are equivalent because they wrap the same Foo function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> prevFamily = <span class="hljs-title function_">resolveFamily</span>(prevType);

        <span class="hljs-keyword">if</span> (prevFamily !== <span class="hljs-literal">undefined</span> &amp;&amp; prevFamily === <span class="hljs-title function_">resolveFamily</span>(nextType)) {
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markFailedErrorBoundaryForHotReloading</span>(<span class="hljs-params">fiber</span>) {
    {
      <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1179">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1179">&#x00a7;</a>
              </div>
              <p>Hot reloading is disabled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">WeakSet</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (failedBoundaries === <span class="hljs-literal">null</span>) {
        failedBoundaries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();
      }

      failedBoundaries.<span class="hljs-title function_">add</span>(fiber);
    }
  }
  <span class="hljs-keyword">var</span> scheduleRefresh = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, update</span>) {
    {
      <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1180">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1180">&#x00a7;</a>
              </div>
              <p>Hot reloading is disabled.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">var</span> staleFamilies = update.<span class="hljs-property">staleFamilies</span>,
        updatedFamilies = update.<span class="hljs-property">updatedFamilies</span>;
      <span class="hljs-title function_">flushPassiveEffects</span>();
      <span class="hljs-title function_">flushSync</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">scheduleFibersWithFamiliesRecursively</span>(root.<span class="hljs-property">current</span>, updatedFamilies, staleFamilies);
      });
    }
  };
  <span class="hljs-keyword">var</span> scheduleRoot = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, element</span>) {
    {
      <span class="hljs-keyword">if</span> (root.<span class="hljs-property">context</span> !== emptyContextObject) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1181">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1181">&#x00a7;</a>
              </div>
              <p>Super edge case: root has a legacy _renderSubtree context
but we don’t know the parentComponent so we can’t pass it.
Just ignore. We’ll delete this with _renderSubtree code path later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-title function_">flushPassiveEffects</span>();
      <span class="hljs-title function_">flushSync</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">updateContainer</span>(element, root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
      });
    }
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleFibersWithFamiliesRecursively</span>(<span class="hljs-params">fiber, updatedFamilies, staleFamilies</span>) {
    {
      <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>,
        child = fiber.<span class="hljs-property">child</span>,
        sibling = fiber.<span class="hljs-property">sibling</span>,
        tag = fiber.<span class="hljs-property">tag</span>,
        type = fiber.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">var</span> candidateType = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
          candidateType = type;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
          candidateType = type.<span class="hljs-property">render</span>;
          <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">if</span> (resolveFamily === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected resolveFamily to be set during hot reload.&#x27;</span>);
      }

      <span class="hljs-keyword">var</span> needsRender = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> needsRemount = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (candidateType !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> family = <span class="hljs-title function_">resolveFamily</span>(candidateType);

        <span class="hljs-keyword">if</span> (family !== <span class="hljs-literal">undefined</span>) {
          <span class="hljs-keyword">if</span> (staleFamilies.<span class="hljs-title function_">has</span>(family)) {
            needsRemount = <span class="hljs-literal">true</span>;
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (updatedFamilies.<span class="hljs-title function_">has</span>(family)) {
            <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">ClassComponent</span>) {
              needsRemount = <span class="hljs-literal">true</span>;
            } <span class="hljs-keyword">else</span> {
              needsRender = <span class="hljs-literal">true</span>;
            }
          }
        }
      }

      <span class="hljs-keyword">if</span> (failedBoundaries !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (failedBoundaries.<span class="hljs-title function_">has</span>(fiber) || alternate !== <span class="hljs-literal">null</span> &amp;&amp; failedBoundaries.<span class="hljs-title function_">has</span>(alternate)) {
          needsRemount = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">if</span> (needsRemount) {
        fiber.<span class="hljs-property">_debugNeedsRemount</span> = <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">if</span> (needsRemount || needsRender) {
        <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
      }

      <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span> &amp;&amp; !needsRemount) {
        <span class="hljs-title function_">scheduleFibersWithFamiliesRecursively</span>(child, updatedFamilies, staleFamilies);
      }

      <span class="hljs-keyword">if</span> (sibling !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">scheduleFibersWithFamiliesRecursively</span>(sibling, updatedFamilies, staleFamilies);
      }
    }
  }

  <span class="hljs-keyword">var</span> findHostInstancesForRefresh = <span class="hljs-keyword">function</span> (<span class="hljs-params">root, families</span>) {
    {
      <span class="hljs-keyword">var</span> hostInstances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
      <span class="hljs-keyword">var</span> types = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(families.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">family</span>) {
        <span class="hljs-keyword">return</span> family.<span class="hljs-property">current</span>;
      }));
      <span class="hljs-title function_">findHostInstancesForMatchingFibersRecursively</span>(root.<span class="hljs-property">current</span>, types, hostInstances);
      <span class="hljs-keyword">return</span> hostInstances;
    }
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findHostInstancesForMatchingFibersRecursively</span>(<span class="hljs-params">fiber, types, hostInstances</span>) {
    {
      <span class="hljs-keyword">var</span> child = fiber.<span class="hljs-property">child</span>,
        sibling = fiber.<span class="hljs-property">sibling</span>,
        tag = fiber.<span class="hljs-property">tag</span>,
        type = fiber.<span class="hljs-property">type</span>;
      <span class="hljs-keyword">var</span> candidateType = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
          candidateType = type;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
          candidateType = type.<span class="hljs-property">render</span>;
          <span class="hljs-keyword">break</span>;
      }

      <span class="hljs-keyword">var</span> didMatch = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">if</span> (candidateType !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (types.<span class="hljs-title function_">has</span>(candidateType)) {
          didMatch = <span class="hljs-literal">true</span>;
        }
      }

      <span class="hljs-keyword">if</span> (didMatch) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1182">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1182">&#x00a7;</a>
              </div>
              <p>We have a match. This only drills down to the closest host components.
There’s no need to search deeper because for the purpose of giving
visual feedback, “flashing” outermost parent rectangles is sufficient.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-title function_">findHostInstancesForFiberShallowly</span>(fiber, hostInstances);
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1183">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1183">&#x00a7;</a>
              </div>
              <p>If there’s no match, maybe there will be one further down in the child tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (child !== <span class="hljs-literal">null</span>) {
          <span class="hljs-title function_">findHostInstancesForMatchingFibersRecursively</span>(child, types, hostInstances);
        }
      }

      <span class="hljs-keyword">if</span> (sibling !== <span class="hljs-literal">null</span>) {
        <span class="hljs-title function_">findHostInstancesForMatchingFibersRecursively</span>(sibling, types, hostInstances);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findHostInstancesForFiberShallowly</span>(<span class="hljs-params">fiber, hostInstances</span>) {
    {
      <span class="hljs-keyword">var</span> foundHostInstances = <span class="hljs-title function_">findChildHostInstancesForFiberShallowly</span>(fiber, hostInstances);

      <span class="hljs-keyword">if</span> (foundHostInstances) {
        <span class="hljs-keyword">return</span>;
      } <span class="hljs-comment">// If we didn&#x27;t find any host children, fallback to closest host parent.</span>


      <span class="hljs-keyword">var</span> node = fiber;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">tag</span>) {
          <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
            hostInstances.<span class="hljs-title function_">add</span>(node.<span class="hljs-property">stateNode</span>);
            <span class="hljs-keyword">return</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostPortal</span>:
            hostInstances.<span class="hljs-title function_">add</span>(node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>);
            <span class="hljs-keyword">return</span>;

          <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
            hostInstances.<span class="hljs-title function_">add</span>(node.<span class="hljs-property">stateNode</span>.<span class="hljs-property">containerInfo</span>);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Expected to reach root first.&#x27;</span>);
        }

        node = node.<span class="hljs-property">return</span>;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findChildHostInstancesForFiberShallowly</span>(<span class="hljs-params">fiber, hostInstances</span>) {
    {
      <span class="hljs-keyword">var</span> node = fiber;
      <span class="hljs-keyword">var</span> foundHostInstances = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-property">tag</span> === <span class="hljs-title class_">HostComponent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1184">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1184">&#x00a7;</a>
              </div>
              <p>We got a match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          foundHostInstances = <span class="hljs-literal">true</span>;
          hostInstances.<span class="hljs-title function_">add</span>(node.<span class="hljs-property">stateNode</span>); <span class="hljs-comment">// There may still be more, so keep searching.</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.<span class="hljs-property">child</span> !== <span class="hljs-literal">null</span>) {
          node.<span class="hljs-property">child</span>.<span class="hljs-property">return</span> = node;
          node = node.<span class="hljs-property">child</span>;
          <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> (node === fiber) {
          <span class="hljs-keyword">return</span> foundHostInstances;
        }

        <span class="hljs-keyword">while</span> (node.<span class="hljs-property">sibling</span> === <span class="hljs-literal">null</span>) {
          <span class="hljs-keyword">if</span> (node.<span class="hljs-property">return</span> === <span class="hljs-literal">null</span> || node.<span class="hljs-property">return</span> === fiber) {
            <span class="hljs-keyword">return</span> foundHostInstances;
          }

          node = node.<span class="hljs-property">return</span>;
        }

        node.<span class="hljs-property">sibling</span>.<span class="hljs-property">return</span> = node.<span class="hljs-property">return</span>;
        node = node.<span class="hljs-property">sibling</span>;
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">var</span> hasBadMapPolyfill;

  {
    hasBadMapPolyfill = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> nonExtensibleObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>({});
      <span class="hljs-comment">/* eslint-disable no-new */</span>

      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[nonExtensibleObject, <span class="hljs-literal">null</span>]]);
      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([nonExtensibleObject]);
      <span class="hljs-comment">/* eslint-enable no-new */</span>
    } <span class="hljs-keyword">catch</span> (e) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1185">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1185">&#x00a7;</a>
              </div>
              <p>TODO: Consider warning about bad polyfills</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      hasBadMapPolyfill = <span class="hljs-literal">true</span>;
    }
  }

  <span class="hljs-keyword">var</span> debugCounter = <span class="hljs-number">1</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberNode</span>(<span class="hljs-params">tag, pendingProps, key, mode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1186">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1186">&#x00a7;</a>
              </div>
              <p>Instance</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">key</span> = key;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementType</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Fiber</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">index</span> = <span class="hljs-number">0</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">ref</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingProps</span> = pendingProps;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mode</span> = mode; <span class="hljs-comment">// Effects</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flags</span> = <span class="hljs-title class_">NoFlags</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">alternate</span> = <span class="hljs-literal">null</span>;

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-1187">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1187">&#x00a7;</a>
              </div>
              <p>Note: The following is done to avoid a v8 performance cliff.</p>
<p>Initializing the fields below to smis and later updating them with
double values will cause Fibers to end up having separate shapes.
This behavior/bug has something to do with Object.preventExtension().
Fortunately this only impacts DEV builds.
Unfortunately it makes React unusably slow for some applications.
To work around this, initialize the fields below with doubles.</p>
<p>Learn more about this here:
<a href="https://github.com/facebook/react/issues/14365">https://github.com/facebook/react/issues/14365</a>
<a href="https://bugs.chromium.org/p/v8/issues/detail?id=8538">https://bugs.chromium.org/p/v8/issues/detail?id=8538</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-title class_">Number</span>.<span class="hljs-property">NaN</span>; <span class="hljs-comment">// It&#x27;s okay to replace the initial doubles with smis after initialization.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1188">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1188">&#x00a7;</a>
              </div>
              <p>This won’t trigger the performance cliff mentioned above,
and it simplifies other profiler code (including DevTools).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-number">0</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-number">0</span>;
    }

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-1189">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1189">&#x00a7;</a>
              </div>
              <p>This isn’t directly used but is handy for debugging internals:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugID</span> = debugCounter++;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugSource</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugOwner</span> = <span class="hljs-literal">null</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugNeedsRemount</span> = <span class="hljs-literal">false</span>;
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugHookTypes</span> = <span class="hljs-literal">null</span>;

      <span class="hljs-keyword">if</span> (!hasBadMapPolyfill &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property">preventExtensions</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(<span class="hljs-variable language_">this</span>);
      }
    }
  } <span class="hljs-comment">// This is a constructor function, rather than a POJO constructor, still</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1190">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1190">&#x00a7;</a>
              </div>
              <p>please ensure we do the following:</p>
<ol>
<li>Nobody should add any instance methods on this. Instance methods can be
more difficult to predict when they get optimized and they are almost
never inlined properly in static compilers.</li>
<li>Nobody should rely on <code>instanceof Fiber</code> for type testing. We should
always know when it is a fiber.</li>
<li>We might want to experiment with using numeric keys since they are easier
to optimize in a non-JIT environment.</li>
<li>We can easily go from a constructor to a createFiber object literal if that
is faster.</li>
<li>It should be easy to port this to a C struct and keep a C implementation
compatible.</li>
</ol>

            </div>
            
            <div class="content"><div class='highlight'><pre>

  <span class="hljs-keyword">var</span> createFiber = <span class="hljs-keyword">function</span> (<span class="hljs-params">tag, pendingProps, key, mode</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1191">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1191">&#x00a7;</a>
              </div>
              <p>$FlowFixMe: the shapes are exact here but Flow doesn’t like constructors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberNode</span>(tag, pendingProps, key, mode);
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldConstruct$1</span>(<span class="hljs-params">Component</span>) {
    <span class="hljs-keyword">var</span> prototype = <span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;
    <span class="hljs-keyword">return</span> !!(prototype &amp;&amp; prototype.<span class="hljs-property">isReactComponent</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isSimpleFunctionComponent</span>(<span class="hljs-params">type</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; !<span class="hljs-title function_">shouldConstruct$1</span>(type) &amp;&amp; type.<span class="hljs-property">defaultProps</span> === <span class="hljs-literal">undefined</span>;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolveLazyComponentTag</span>(<span class="hljs-params">Component</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Component</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">shouldConstruct$1</span>(<span class="hljs-title class_">Component</span>) ? <span class="hljs-title class_">ClassComponent</span> : <span class="hljs-title class_">FunctionComponent</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Component</span> !== <span class="hljs-literal">undefined</span> &amp;&amp; <span class="hljs-title class_">Component</span> !== <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">var</span> $$typeof = <span class="hljs-title class_">Component</span>.<span class="hljs-property">$$typeof</span>;

      <span class="hljs-keyword">if</span> ($$typeof === <span class="hljs-variable constant_">REACT_FORWARD_REF_TYPE</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ForwardRef</span>;
      }

      <span class="hljs-keyword">if</span> ($$typeof === <span class="hljs-variable constant_">REACT_MEMO_TYPE</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">MemoComponent</span>;
      }

      {
        <span class="hljs-keyword">if</span> ($$typeof === <span class="hljs-variable constant_">REACT_BLOCK_TYPE</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Block</span>;
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title class_">IndeterminateComponent</span>;
  } <span class="hljs-comment">// This is used to create an alternate fiber to do work on.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorkInProgress</span>(<span class="hljs-params">current, pendingProps</span>) {
    <span class="hljs-keyword">var</span> workInProgress = current.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (workInProgress === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1192">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1192">&#x00a7;</a>
              </div>
              <p>We use a double buffering pooling technique because we know that we’ll
only ever need at most two versions of a tree. We pool the “other” unused
node that we’re free to reuse. This is lazily created to avoid allocating
extra objects for things that are never updated. It also allow us to
reclaim the extra memory if needed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress = <span class="hljs-title function_">createFiber</span>(current.<span class="hljs-property">tag</span>, pendingProps, current.<span class="hljs-property">key</span>, current.<span class="hljs-property">mode</span>);
      workInProgress.<span class="hljs-property">elementType</span> = current.<span class="hljs-property">elementType</span>;
      workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>;
      workInProgress.<span class="hljs-property">stateNode</span> = current.<span class="hljs-property">stateNode</span>;

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-1193">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1193">&#x00a7;</a>
              </div>
              <p>DEV-only fields</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgress.<span class="hljs-property">_debugID</span> = current.<span class="hljs-property">_debugID</span>;
        workInProgress.<span class="hljs-property">_debugSource</span> = current.<span class="hljs-property">_debugSource</span>;
        workInProgress.<span class="hljs-property">_debugOwner</span> = current.<span class="hljs-property">_debugOwner</span>;
        workInProgress.<span class="hljs-property">_debugHookTypes</span> = current.<span class="hljs-property">_debugHookTypes</span>;
      }

      workInProgress.<span class="hljs-property">alternate</span> = current;
      current.<span class="hljs-property">alternate</span> = workInProgress;
    } <span class="hljs-keyword">else</span> {
      workInProgress.<span class="hljs-property">pendingProps</span> = pendingProps; <span class="hljs-comment">// Needed because Blocks store data on type.</span>

      workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>; <span class="hljs-comment">// We already have an alternate.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1194">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1194">&#x00a7;</a>
              </div>
              <p>Reset the effect tag.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      workInProgress.<span class="hljs-property">flags</span> = <span class="hljs-title class_">NoFlags</span>; <span class="hljs-comment">// The effect list is no longer valid.</span>

      workInProgress.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-1195">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1195">&#x00a7;</a>
              </div>
              <p>We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.
This prevents time from endlessly accumulating in new commits.
This has the downside of resetting values for different priority renders,
But works for yielding (the common case) and should support resuming.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgress.<span class="hljs-property">actualDuration</span> = <span class="hljs-number">0</span>;
        workInProgress.<span class="hljs-property">actualStartTime</span> = -<span class="hljs-number">1</span>;
      }
    }

    workInProgress.<span class="hljs-property">childLanes</span> = current.<span class="hljs-property">childLanes</span>;
    workInProgress.<span class="hljs-property">lanes</span> = current.<span class="hljs-property">lanes</span>;
    workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>;
    workInProgress.<span class="hljs-property">memoizedProps</span> = current.<span class="hljs-property">memoizedProps</span>;
    workInProgress.<span class="hljs-property">memoizedState</span> = current.<span class="hljs-property">memoizedState</span>;
    workInProgress.<span class="hljs-property">updateQueue</span> = current.<span class="hljs-property">updateQueue</span>; <span class="hljs-comment">// Clone the dependencies object. This is mutated during the render phase, so</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1196">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1196">&#x00a7;</a>
              </div>
              <p>it cannot be shared with the current fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">var</span> currentDependencies = current.<span class="hljs-property">dependencies</span>;
    workInProgress.<span class="hljs-property">dependencies</span> = currentDependencies === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : {
      <span class="hljs-attr">lanes</span>: currentDependencies.<span class="hljs-property">lanes</span>,
      <span class="hljs-attr">firstContext</span>: currentDependencies.<span class="hljs-property">firstContext</span>
    }; <span class="hljs-comment">// These will be overridden during the parent&#x27;s reconciliation</span>

    workInProgress.<span class="hljs-property">sibling</span> = current.<span class="hljs-property">sibling</span>;
    workInProgress.<span class="hljs-property">index</span> = current.<span class="hljs-property">index</span>;
    workInProgress.<span class="hljs-property">ref</span> = current.<span class="hljs-property">ref</span>;

    {
      workInProgress.<span class="hljs-property">selfBaseDuration</span> = current.<span class="hljs-property">selfBaseDuration</span>;
      workInProgress.<span class="hljs-property">treeBaseDuration</span> = current.<span class="hljs-property">treeBaseDuration</span>;
    }

    {
      workInProgress.<span class="hljs-property">_debugNeedsRemount</span> = current.<span class="hljs-property">_debugNeedsRemount</span>;

      <span class="hljs-keyword">switch</span> (workInProgress.<span class="hljs-property">tag</span>) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">IndeterminateComponent</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">FunctionComponent</span>:
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">SimpleMemoComponent</span>:
          workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title function_">resolveFunctionForHotReloading</span>(current.<span class="hljs-property">type</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ClassComponent</span>:
          workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title function_">resolveClassForHotReloading</span>(current.<span class="hljs-property">type</span>);
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ForwardRef</span>:
          workInProgress.<span class="hljs-property">type</span> = <span class="hljs-title function_">resolveForwardRefForHotReloading</span>(current.<span class="hljs-property">type</span>);
          <span class="hljs-keyword">break</span>;
      }
    }

    <span class="hljs-keyword">return</span> workInProgress;
  } <span class="hljs-comment">// Used to reuse a Fiber for a second pass.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resetWorkInProgress</span>(<span class="hljs-params">workInProgress, renderLanes</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1197">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1197">&#x00a7;</a>
              </div>
              <p>This resets the Fiber to what createFiber or createWorkInProgress would
have set the values to before during the first pass. Ideally this wouldn’t
be necessary but unfortunately many code paths reads from the workInProgress
when they should be reading from current and writing to workInProgress.
We assume pendingProps, index, key, ref, return are still untouched to
avoid doing another reconciliation.
Reset the effect tag but keep any Placement tags, since that’s something
that child fiber is setting, not the reconciliation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    workInProgress.<span class="hljs-property">flags</span> &amp;= <span class="hljs-title class_">Placement</span>; <span class="hljs-comment">// The effect list is no longer valid.</span>

    workInProgress.<span class="hljs-property">nextEffect</span> = <span class="hljs-literal">null</span>;
    workInProgress.<span class="hljs-property">firstEffect</span> = <span class="hljs-literal">null</span>;
    workInProgress.<span class="hljs-property">lastEffect</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> current = workInProgress.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1198">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1198">&#x00a7;</a>
              </div>
              <p>Reset to createFiber’s initial values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">childLanes</span> = <span class="hljs-title class_">NoLanes</span>;
      workInProgress.<span class="hljs-property">lanes</span> = renderLanes;
      workInProgress.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">memoizedProps</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">memoizedState</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">updateQueue</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">dependencies</span> = <span class="hljs-literal">null</span>;
      workInProgress.<span class="hljs-property">stateNode</span> = <span class="hljs-literal">null</span>;

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-1199">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1199">&#x00a7;</a>
              </div>
              <p>Note: We don’t reset the actualTime counts. It’s useful to accumulate
actual time across multiple render passes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgress.<span class="hljs-property">selfBaseDuration</span> = <span class="hljs-number">0</span>;
        workInProgress.<span class="hljs-property">treeBaseDuration</span> = <span class="hljs-number">0</span>;
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1200">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1200">&#x00a7;</a>
              </div>
              <p>Reset to the cloned values that createWorkInProgress would’ve.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      workInProgress.<span class="hljs-property">childLanes</span> = current.<span class="hljs-property">childLanes</span>;
      workInProgress.<span class="hljs-property">lanes</span> = current.<span class="hljs-property">lanes</span>;
      workInProgress.<span class="hljs-property">child</span> = current.<span class="hljs-property">child</span>;
      workInProgress.<span class="hljs-property">memoizedProps</span> = current.<span class="hljs-property">memoizedProps</span>;
      workInProgress.<span class="hljs-property">memoizedState</span> = current.<span class="hljs-property">memoizedState</span>;
      workInProgress.<span class="hljs-property">updateQueue</span> = current.<span class="hljs-property">updateQueue</span>; <span class="hljs-comment">// Needed because Blocks store data on type.</span>

      workInProgress.<span class="hljs-property">type</span> = current.<span class="hljs-property">type</span>; <span class="hljs-comment">// Clone the dependencies object. This is mutated during the render phase, so</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1201">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1201">&#x00a7;</a>
              </div>
              <p>it cannot be shared with the current fiber.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> currentDependencies = current.<span class="hljs-property">dependencies</span>;
      workInProgress.<span class="hljs-property">dependencies</span> = currentDependencies === <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : {
        <span class="hljs-attr">lanes</span>: currentDependencies.<span class="hljs-property">lanes</span>,
        <span class="hljs-attr">firstContext</span>: currentDependencies.<span class="hljs-property">firstContext</span>
      };

      {</pre></div></div>
            
        </li>
        
        
        <li id="section-1202">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1202">&#x00a7;</a>
              </div>
              <p>Note: We don’t reset the actualTime counts. It’s useful to accumulate
actual time across multiple render passes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        workInProgress.<span class="hljs-property">selfBaseDuration</span> = current.<span class="hljs-property">selfBaseDuration</span>;
        workInProgress.<span class="hljs-property">treeBaseDuration</span> = current.<span class="hljs-property">treeBaseDuration</span>;
      }
    }

    <span class="hljs-keyword">return</span> workInProgress;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createHostRootFiber</span>(<span class="hljs-params">tag</span>) {
    <span class="hljs-keyword">var</span> mode;

    <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">ConcurrentRoot</span>) {
      mode = <span class="hljs-title class_">ConcurrentMode</span> | <span class="hljs-title class_">BlockingMode</span> | <span class="hljs-title class_">StrictMode</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">BlockingRoot</span>) {
      mode = <span class="hljs-title class_">BlockingMode</span> | <span class="hljs-title class_">StrictMode</span>;
    } <span class="hljs-keyword">else</span> {
      mode = <span class="hljs-title class_">NoMode</span>;
    }

    <span class="hljs-keyword">if</span> (isDevToolsPresent) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1203">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1203">&#x00a7;</a>
              </div>
              <p>Always collect profile timings when DevTools are present.
This enables DevTools to start capturing timing at any point–
Without some nodes in the tree having empty base times.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      mode |= <span class="hljs-title class_">ProfileMode</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">HostRoot</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, mode);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromTypeAndProps</span>(<span class="hljs-params">type, <span class="hljs-comment">// React$ElementType</span>
    key, pendingProps, owner, mode, lanes</span>) {
    <span class="hljs-keyword">var</span> fiberTag = <span class="hljs-title class_">IndeterminateComponent</span>; <span class="hljs-comment">// The resolved type is set if we know what the final type will be. I.e. it&#x27;s not lazy.</span>

    <span class="hljs-keyword">var</span> resolvedType = type;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">shouldConstruct$1</span>(type)) {
        fiberTag = <span class="hljs-title class_">ClassComponent</span>;

        {
          resolvedType = <span class="hljs-title function_">resolveClassForHotReloading</span>(resolvedType);
        }
      } <span class="hljs-keyword">else</span> {
        {
          resolvedType = <span class="hljs-title function_">resolveFunctionForHotReloading</span>(resolvedType);
        }
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;string&#x27;</span>) {
      fiberTag = <span class="hljs-title class_">HostComponent</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-attr">getTag</span>: <span class="hljs-keyword">switch</span> (type) {
        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_FRAGMENT_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberFromFragment</span>(pendingProps.<span class="hljs-property">children</span>, mode, lanes, key);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_DEBUG_TRACING_MODE_TYPE</span>:
          fiberTag = <span class="hljs-title class_">Mode</span>;
          mode |= <span class="hljs-title class_">DebugTracingMode</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_STRICT_MODE_TYPE</span>:
          fiberTag = <span class="hljs-title class_">Mode</span>;
          mode |= <span class="hljs-title class_">StrictMode</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PROFILER_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberFromProfiler</span>(pendingProps, mode, lanes, key);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberFromSuspense</span>(pendingProps, mode, lanes, key);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SUSPENSE_LIST_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberFromSuspenseList</span>(pendingProps, mode, lanes, key);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_OFFSCREEN_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberFromOffscreen</span>(pendingProps, mode, lanes, key);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LEGACY_HIDDEN_TYPE</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberFromLegacyHidden</span>(pendingProps, mode, lanes, key);

        <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_SCOPE_TYPE</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-1204">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1204">&#x00a7;</a>
              </div>
              <p>eslint-disable-next-line no-fallthrough</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-attr">default</span>:
          {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; type !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">switch</span> (type.<span class="hljs-property">$$typeof</span>) {
                <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_PROVIDER_TYPE</span>:
                  fiberTag = <span class="hljs-title class_">ContextProvider</span>;
                  <span class="hljs-keyword">break</span> getTag;

                <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_CONTEXT_TYPE</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-1205">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1205">&#x00a7;</a>
              </div>
              <p>This is a consumer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                  fiberTag = <span class="hljs-title class_">ContextConsumer</span>;
                  <span class="hljs-keyword">break</span> getTag;

                <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_FORWARD_REF_TYPE</span>:
                  fiberTag = <span class="hljs-title class_">ForwardRef</span>;

                  {
                    resolvedType = <span class="hljs-title function_">resolveForwardRefForHotReloading</span>(resolvedType);
                  }

                  <span class="hljs-keyword">break</span> getTag;

                <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_MEMO_TYPE</span>:
                  fiberTag = <span class="hljs-title class_">MemoComponent</span>;
                  <span class="hljs-keyword">break</span> getTag;

                <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_LAZY_TYPE</span>:
                  fiberTag = <span class="hljs-title class_">LazyComponent</span>;
                  resolvedType = <span class="hljs-literal">null</span>;
                  <span class="hljs-keyword">break</span> getTag;

                <span class="hljs-keyword">case</span> <span class="hljs-attr">REACT_BLOCK_TYPE</span>:
                  fiberTag = <span class="hljs-title class_">Block</span>;
                  <span class="hljs-keyword">break</span> getTag;
              }
            }

            <span class="hljs-keyword">var</span> info = <span class="hljs-string">&#x27;&#x27;</span>;

            {
              <span class="hljs-keyword">if</span> (type === <span class="hljs-literal">undefined</span> || <span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; type !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(type).<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
                info += <span class="hljs-string">&#x27; You likely forgot to export your component from the file &#x27;</span> + <span class="hljs-string">&quot;it&#x27;s defined in, or you might have mixed up default and &quot;</span> + <span class="hljs-string">&#x27;named imports.&#x27;</span>;
              }

              <span class="hljs-keyword">var</span> ownerName = owner ? <span class="hljs-title function_">getComponentName</span>(owner.<span class="hljs-property">type</span>) : <span class="hljs-literal">null</span>;

              <span class="hljs-keyword">if</span> (ownerName) {
                info += <span class="hljs-string">&#x27;\n\nCheck the render method of `&#x27;</span> + ownerName + <span class="hljs-string">&#x27;`.&#x27;</span>;
              }
            }

            {
              {
                <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: &quot;</span> + (type == <span class="hljs-literal">null</span> ? type : <span class="hljs-keyword">typeof</span> type) + <span class="hljs-string">&quot;.&quot;</span> + info);
              }
            }
          }
      }
    }

    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(fiberTag, pendingProps, key, mode);
    fiber.<span class="hljs-property">elementType</span> = type;
    fiber.<span class="hljs-property">type</span> = resolvedType;
    fiber.<span class="hljs-property">lanes</span> = lanes;

    {
      fiber.<span class="hljs-property">_debugOwner</span> = owner;
    }

    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromElement</span>(<span class="hljs-params">element, mode, lanes</span>) {
    <span class="hljs-keyword">var</span> owner = <span class="hljs-literal">null</span>;

    {
      owner = element.<span class="hljs-property">_owner</span>;
    }

    <span class="hljs-keyword">var</span> type = element.<span class="hljs-property">type</span>;
    <span class="hljs-keyword">var</span> key = element.<span class="hljs-property">key</span>;
    <span class="hljs-keyword">var</span> pendingProps = element.<span class="hljs-property">props</span>;
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiberFromTypeAndProps</span>(type, key, pendingProps, owner, mode, lanes);

    {
      fiber.<span class="hljs-property">_debugSource</span> = element.<span class="hljs-property">_source</span>;
      fiber.<span class="hljs-property">_debugOwner</span> = element.<span class="hljs-property">_owner</span>;
    }

    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromFragment</span>(<span class="hljs-params">elements, mode, lanes, key</span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">Fragment</span>, elements, key, mode);
    fiber.<span class="hljs-property">lanes</span> = lanes;
    <span class="hljs-keyword">return</span> fiber;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromProfiler</span>(<span class="hljs-params">pendingProps, mode, lanes, key</span>) {
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> pendingProps.<span class="hljs-property">id</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Profiler must specify an &quot;id&quot; as a prop&#x27;</span>);
      }
    }

    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">Profiler</span>, pendingProps, key, mode | <span class="hljs-title class_">ProfileMode</span>); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> The Profiler fiber shouldn&#x27;t have a type. It has a tag.</span>

    fiber.<span class="hljs-property">elementType</span> = <span class="hljs-variable constant_">REACT_PROFILER_TYPE</span>;
    fiber.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">REACT_PROFILER_TYPE</span>;
    fiber.<span class="hljs-property">lanes</span> = lanes;

    {
      fiber.<span class="hljs-property">stateNode</span> = {
        <span class="hljs-attr">effectDuration</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">passiveEffectDuration</span>: <span class="hljs-number">0</span>
      };
    }

    <span class="hljs-keyword">return</span> fiber;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromSuspense</span>(<span class="hljs-params">pendingProps, mode, lanes, key</span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">SuspenseComponent</span>, pendingProps, key, mode); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> The SuspenseComponent fiber shouldn&#x27;t have a type. It has a tag.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1206">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1206">&#x00a7;</a>
              </div>
              <p>This needs to be fixed in getComponentName so that it relies on the tag
instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    fiber.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">REACT_SUSPENSE_TYPE</span>;
    fiber.<span class="hljs-property">elementType</span> = <span class="hljs-variable constant_">REACT_SUSPENSE_TYPE</span>;
    fiber.<span class="hljs-property">lanes</span> = lanes;
    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromSuspenseList</span>(<span class="hljs-params">pendingProps, mode, lanes, key</span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">SuspenseListComponent</span>, pendingProps, key, mode);

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-1207">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1207">&#x00a7;</a>
              </div>
              <p>TODO: The SuspenseListComponent fiber shouldn’t have a type. It has a tag.
This needs to be fixed in getComponentName so that it relies on the tag
instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      fiber.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">REACT_SUSPENSE_LIST_TYPE</span>;
    }

    fiber.<span class="hljs-property">elementType</span> = <span class="hljs-variable constant_">REACT_SUSPENSE_LIST_TYPE</span>;
    fiber.<span class="hljs-property">lanes</span> = lanes;
    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromOffscreen</span>(<span class="hljs-params">pendingProps, mode, lanes, key</span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">OffscreenComponent</span>, pendingProps, key, mode); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> The OffscreenComponent fiber shouldn&#x27;t have a type. It has a tag.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1208">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1208">&#x00a7;</a>
              </div>
              <p>This needs to be fixed in getComponentName so that it relies on the tag
instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    {
      fiber.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">REACT_OFFSCREEN_TYPE</span>;
    }

    fiber.<span class="hljs-property">elementType</span> = <span class="hljs-variable constant_">REACT_OFFSCREEN_TYPE</span>;
    fiber.<span class="hljs-property">lanes</span> = lanes;
    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromLegacyHidden</span>(<span class="hljs-params">pendingProps, mode, lanes, key</span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">LegacyHiddenComponent</span>, pendingProps, key, mode); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> The LegacyHidden fiber shouldn&#x27;t have a type. It has a tag.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1209">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1209">&#x00a7;</a>
              </div>
              <p>This needs to be fixed in getComponentName so that it relies on the tag
instead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    {
      fiber.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">REACT_LEGACY_HIDDEN_TYPE</span>;
    }

    fiber.<span class="hljs-property">elementType</span> = <span class="hljs-variable constant_">REACT_LEGACY_HIDDEN_TYPE</span>;
    fiber.<span class="hljs-property">lanes</span> = lanes;
    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromText</span>(<span class="hljs-params">content, mode, lanes</span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">HostText</span>, content, <span class="hljs-literal">null</span>, mode);
    fiber.<span class="hljs-property">lanes</span> = lanes;
    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromHostInstanceForDeletion</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">HostComponent</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-title class_">NoMode</span>); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> These should not need a type.</span>

    fiber.<span class="hljs-property">elementType</span> = <span class="hljs-string">&#x27;DELETED&#x27;</span>;
    fiber.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;DELETED&#x27;</span>;
    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromDehydratedFragment</span>(<span class="hljs-params">dehydratedNode</span>) {
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">DehydratedFragment</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-title class_">NoMode</span>);
    fiber.<span class="hljs-property">stateNode</span> = dehydratedNode;
    <span class="hljs-keyword">return</span> fiber;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberFromPortal</span>(<span class="hljs-params">portal, mode, lanes</span>) {
    <span class="hljs-keyword">var</span> pendingProps = portal.<span class="hljs-property">children</span> !== <span class="hljs-literal">null</span> ? portal.<span class="hljs-property">children</span> : [];
    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">HostPortal</span>, pendingProps, portal.<span class="hljs-property">key</span>, mode);
    fiber.<span class="hljs-property">lanes</span> = lanes;
    fiber.<span class="hljs-property">stateNode</span> = {
      <span class="hljs-attr">containerInfo</span>: portal.<span class="hljs-property">containerInfo</span>,
      <span class="hljs-attr">pendingChildren</span>: <span class="hljs-literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-1210">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1210">&#x00a7;</a>
              </div>
              <p>Used by persistent updates</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-attr">implementation</span>: portal.<span class="hljs-property">implementation</span>
    };
    <span class="hljs-keyword">return</span> fiber;
  } <span class="hljs-comment">// Used for stashing WIP properties to replay failed work in DEV.</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">assignFiberPropertiesInDEV</span>(<span class="hljs-params">target, source</span>) {
    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1211">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1211">&#x00a7;</a>
              </div>
              <p>This Fiber’s initial properties will always be overwritten.
We only use a Fiber to ensure the same hidden class so DEV isn’t slow.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      target = <span class="hljs-title function_">createFiber</span>(<span class="hljs-title class_">IndeterminateComponent</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-title class_">NoMode</span>);
    } <span class="hljs-comment">// This is intentionally written as a list of all properties.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1212">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1212">&#x00a7;</a>
              </div>
              <p>We tried to use Object.assign() instead but this is called in
the hottest path, and Object.assign() was too slow:
<a href="https://github.com/facebook/react/issues/12502">https://github.com/facebook/react/issues/12502</a>
This code is DEV-only so size is not a concern.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    target.<span class="hljs-property">tag</span> = source.<span class="hljs-property">tag</span>;
    target.<span class="hljs-property">key</span> = source.<span class="hljs-property">key</span>;
    target.<span class="hljs-property">elementType</span> = source.<span class="hljs-property">elementType</span>;
    target.<span class="hljs-property">type</span> = source.<span class="hljs-property">type</span>;
    target.<span class="hljs-property">stateNode</span> = source.<span class="hljs-property">stateNode</span>;
    target.<span class="hljs-property">return</span> = source.<span class="hljs-property">return</span>;
    target.<span class="hljs-property">child</span> = source.<span class="hljs-property">child</span>;
    target.<span class="hljs-property">sibling</span> = source.<span class="hljs-property">sibling</span>;
    target.<span class="hljs-property">index</span> = source.<span class="hljs-property">index</span>;
    target.<span class="hljs-property">ref</span> = source.<span class="hljs-property">ref</span>;
    target.<span class="hljs-property">pendingProps</span> = source.<span class="hljs-property">pendingProps</span>;
    target.<span class="hljs-property">memoizedProps</span> = source.<span class="hljs-property">memoizedProps</span>;
    target.<span class="hljs-property">updateQueue</span> = source.<span class="hljs-property">updateQueue</span>;
    target.<span class="hljs-property">memoizedState</span> = source.<span class="hljs-property">memoizedState</span>;
    target.<span class="hljs-property">dependencies</span> = source.<span class="hljs-property">dependencies</span>;
    target.<span class="hljs-property">mode</span> = source.<span class="hljs-property">mode</span>;
    target.<span class="hljs-property">flags</span> = source.<span class="hljs-property">flags</span>;
    target.<span class="hljs-property">nextEffect</span> = source.<span class="hljs-property">nextEffect</span>;
    target.<span class="hljs-property">firstEffect</span> = source.<span class="hljs-property">firstEffect</span>;
    target.<span class="hljs-property">lastEffect</span> = source.<span class="hljs-property">lastEffect</span>;
    target.<span class="hljs-property">lanes</span> = source.<span class="hljs-property">lanes</span>;
    target.<span class="hljs-property">childLanes</span> = source.<span class="hljs-property">childLanes</span>;
    target.<span class="hljs-property">alternate</span> = source.<span class="hljs-property">alternate</span>;

    {
      target.<span class="hljs-property">actualDuration</span> = source.<span class="hljs-property">actualDuration</span>;
      target.<span class="hljs-property">actualStartTime</span> = source.<span class="hljs-property">actualStartTime</span>;
      target.<span class="hljs-property">selfBaseDuration</span> = source.<span class="hljs-property">selfBaseDuration</span>;
      target.<span class="hljs-property">treeBaseDuration</span> = source.<span class="hljs-property">treeBaseDuration</span>;
    }

    target.<span class="hljs-property">_debugID</span> = source.<span class="hljs-property">_debugID</span>;
    target.<span class="hljs-property">_debugSource</span> = source.<span class="hljs-property">_debugSource</span>;
    target.<span class="hljs-property">_debugOwner</span> = source.<span class="hljs-property">_debugOwner</span>;
    target.<span class="hljs-property">_debugNeedsRemount</span> = source.<span class="hljs-property">_debugNeedsRemount</span>;
    target.<span class="hljs-property">_debugHookTypes</span> = source.<span class="hljs-property">_debugHookTypes</span>;
    <span class="hljs-keyword">return</span> target;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">FiberRootNode</span>(<span class="hljs-params">containerInfo, tag, hydrate</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">containerInfo</span> = containerInfo;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingChildren</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pingCache</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">finishedWork</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timeoutHandle</span> = noTimeout;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">context</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingContext</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">hydrate</span> = hydrate;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackNode</span> = <span class="hljs-literal">null</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbackPriority</span> = <span class="hljs-title class_">NoLanePriority</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">eventTimes</span> = <span class="hljs-title function_">createLaneMap</span>(<span class="hljs-title class_">NoLanes</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">expirationTimes</span> = <span class="hljs-title function_">createLaneMap</span>(<span class="hljs-title class_">NoTimestamp</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">suspendedLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pingedLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">expiredLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">mutableReadLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">finishedLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">entangledLanes</span> = <span class="hljs-title class_">NoLanes</span>;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">entanglements</span> = <span class="hljs-title function_">createLaneMap</span>(<span class="hljs-title class_">NoLanes</span>);

    {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">mutableSourceEagerHydrationData</span> = <span class="hljs-literal">null</span>;
    }

    {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">interactionThreadID</span> = <span class="hljs-title function_">unstable_getThreadID</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">memoizedInteractions</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">pendingInteractionMap</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
    }

    {
      <span class="hljs-keyword">switch</span> (tag) {
        <span class="hljs-keyword">case</span> <span class="hljs-title class_">BlockingRoot</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugRootType</span> = <span class="hljs-string">&#x27;createBlockingRoot()&#x27;</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">ConcurrentRoot</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugRootType</span> = <span class="hljs-string">&#x27;createRoot()&#x27;</span>;
          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> <span class="hljs-title class_">LegacyRoot</span>:
          <span class="hljs-variable language_">this</span>.<span class="hljs-property">_debugRootType</span> = <span class="hljs-string">&#x27;createLegacyRoot()&#x27;</span>;
          <span class="hljs-keyword">break</span>;
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createFiberRoot</span>(<span class="hljs-params">containerInfo, tag, hydrate, hydrationCallbacks</span>) {
    <span class="hljs-keyword">var</span> root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FiberRootNode</span>(containerInfo, tag, hydrate);</pre></div></div>
            
        </li>
        
        
        <li id="section-1213">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1213">&#x00a7;</a>
              </div>
              <p>stateNode is any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> uninitializedFiber = <span class="hljs-title function_">createHostRootFiber</span>(tag);
    root.<span class="hljs-property">current</span> = uninitializedFiber;
    uninitializedFiber.<span class="hljs-property">stateNode</span> = root;
    <span class="hljs-title function_">initializeUpdateQueue</span>(uninitializedFiber);
    <span class="hljs-keyword">return</span> root;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-1214">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1214">&#x00a7;</a>
              </div>
              <p>This ensures that the version used for server rendering matches the one
that is eventually read during hydration.
If they don’t match there’s a potential tear and a full deopt render is required.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">registerMutableSourceForHydration</span>(<span class="hljs-params">root, mutableSource</span>) {
    <span class="hljs-keyword">var</span> getVersion = mutableSource.<span class="hljs-property">_getVersion</span>;
    <span class="hljs-keyword">var</span> version = <span class="hljs-title function_">getVersion</span>(mutableSource.<span class="hljs-property">_source</span>); <span class="hljs-comment">// TODO Clear this data once all pending hydration work is finished.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1215">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1215">&#x00a7;</a>
              </div>
              <p>Retaining it forever may interfere with GC.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    <span class="hljs-keyword">if</span> (root.<span class="hljs-property">mutableSourceEagerHydrationData</span> == <span class="hljs-literal">null</span>) {
      root.<span class="hljs-property">mutableSourceEagerHydrationData</span> = [mutableSource, version];
    } <span class="hljs-keyword">else</span> {
      root.<span class="hljs-property">mutableSourceEagerHydrationData</span>.<span class="hljs-title function_">push</span>(mutableSource, version);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPortal</span>(<span class="hljs-params">children, containerInfo, <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> figure out the API for cross-renderer implementation.</span>
    implementation</span>) {
    <span class="hljs-keyword">var</span> key = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">3</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">3</span>] : <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1216">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1216">&#x00a7;</a>
              </div>
              <p>This tag allow us to uniquely identify this as a React Portal</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-attr">$$typeof</span>: <span class="hljs-variable constant_">REACT_PORTAL_TYPE</span>,
      <span class="hljs-attr">key</span>: key == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : <span class="hljs-string">&#x27;&#x27;</span> + key,
      <span class="hljs-attr">children</span>: children,
      <span class="hljs-attr">containerInfo</span>: containerInfo,
      <span class="hljs-attr">implementation</span>: implementation
    };
  }

  <span class="hljs-keyword">var</span> didWarnAboutNestedUpdates;
  <span class="hljs-keyword">var</span> didWarnAboutFindNodeInStrictMode;

  {
    didWarnAboutNestedUpdates = <span class="hljs-literal">false</span>;
    didWarnAboutFindNodeInStrictMode = {};
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getContextForSubtree</span>(<span class="hljs-params">parentComponent</span>) {
    <span class="hljs-keyword">if</span> (!parentComponent) {
      <span class="hljs-keyword">return</span> emptyContextObject;
    }

    <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">get</span>(parentComponent);
    <span class="hljs-keyword">var</span> parentContext = <span class="hljs-title function_">findCurrentUnmaskedContext</span>(fiber);

    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">ClassComponent</span>) {
      <span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = fiber.<span class="hljs-property">type</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContextProvider</span>(<span class="hljs-title class_">Component</span>)) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">processChildContext</span>(fiber, <span class="hljs-title class_">Component</span>, parentContext);
      }
    }

    <span class="hljs-keyword">return</span> parentContext;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findHostInstanceWithWarning</span>(<span class="hljs-params">component, methodName</span>) {
    {
      <span class="hljs-keyword">var</span> fiber = <span class="hljs-title function_">get</span>(component);

      <span class="hljs-keyword">if</span> (fiber === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> component.<span class="hljs-property">render</span> === <span class="hljs-string">&#x27;function&#x27;</span>) {
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Unable to find node on an unmounted component.&quot;</span>);
            }
          }
        } <span class="hljs-keyword">else</span> {
          {
            {
              <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Argument appears to not be a ReactComponent. Keys: &quot;</span> + <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(component));
            }
          }
        }
      }

      <span class="hljs-keyword">var</span> hostFiber = <span class="hljs-title function_">findCurrentHostFiber</span>(fiber);

      <span class="hljs-keyword">if</span> (hostFiber === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }

      <span class="hljs-keyword">if</span> (hostFiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
        <span class="hljs-keyword">var</span> componentName = <span class="hljs-title function_">getComponentName</span>(fiber.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Component&#x27;</span>;

        <span class="hljs-keyword">if</span> (!didWarnAboutFindNodeInStrictMode[componentName]) {
          didWarnAboutFindNodeInStrictMode[componentName] = <span class="hljs-literal">true</span>;
          <span class="hljs-keyword">var</span> previousFiber = current;

          <span class="hljs-keyword">try</span> {
            <span class="hljs-title function_">setCurrentFiber</span>(hostFiber);

            <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">mode</span> &amp; <span class="hljs-title class_">StrictMode</span>) {
              <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s is deprecated in StrictMode. &#x27;</span> + <span class="hljs-string">&#x27;%s was passed an instance of %s which is inside StrictMode. &#x27;</span> + <span class="hljs-string">&#x27;Instead, add a ref directly to the element you want to reference. &#x27;</span> + <span class="hljs-string">&#x27;Learn more about using refs safely here: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/strict-mode-find-node&#x27;</span>, methodName, methodName, componentName);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s is deprecated in StrictMode. &#x27;</span> + <span class="hljs-string">&#x27;%s was passed an instance of %s which renders StrictMode children. &#x27;</span> + <span class="hljs-string">&#x27;Instead, add a ref directly to the element you want to reference. &#x27;</span> + <span class="hljs-string">&#x27;Learn more about using refs safely here: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/strict-mode-find-node&#x27;</span>, methodName, methodName, componentName);
            }
          } <span class="hljs-keyword">finally</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1217">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1217">&#x00a7;</a>
              </div>
              <p>Ideally this should reset to previous but this shouldn’t be called in
render and there’s another warning for that anyway.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (previousFiber) {
              <span class="hljs-title function_">setCurrentFiber</span>(previousFiber);
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-title function_">resetCurrentFiber</span>();
            }
          }
        }
      }

      <span class="hljs-keyword">return</span> hostFiber.<span class="hljs-property">stateNode</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createContainer</span>(<span class="hljs-params">containerInfo, tag, hydrate, hydrationCallbacks</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createFiberRoot</span>(containerInfo, tag, hydrate);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">updateContainer</span>(<span class="hljs-params">element, container, parentComponent, callback</span>) {
    {
      <span class="hljs-title function_">onScheduleRoot</span>(container, element);
    }

    <span class="hljs-keyword">var</span> current$<span class="hljs-number">1</span> = container.<span class="hljs-property">current</span>;
    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();

    {</pre></div></div>
            
        </li>
        
        
        <li id="section-1218">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1218">&#x00a7;</a>
              </div>
              <p>$FlowExpectedError - jest isn’t a global, and isn’t recognized outside of tests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;undefined&#x27;</span> !== <span class="hljs-keyword">typeof</span> jest) {
        <span class="hljs-title function_">warnIfUnmockedScheduler</span>(current$<span class="hljs-number">1</span>);
        <span class="hljs-title function_">warnIfNotScopedWithMatchingAct</span>(current$<span class="hljs-number">1</span>);
      }
    }

    <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(current$<span class="hljs-number">1</span>);

    {
      <span class="hljs-title function_">markRenderScheduled</span>(lane);
    }

    <span class="hljs-keyword">var</span> context = <span class="hljs-title function_">getContextForSubtree</span>(parentComponent);

    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">context</span> === <span class="hljs-literal">null</span>) {
      container.<span class="hljs-property">context</span> = context;
    } <span class="hljs-keyword">else</span> {
      container.<span class="hljs-property">pendingContext</span> = context;
    }

    {
      <span class="hljs-keyword">if</span> (isRendering &amp;&amp; current !== <span class="hljs-literal">null</span> &amp;&amp; !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = <span class="hljs-literal">true</span>;

        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Render methods should be a pure function of props and state; &#x27;</span> + <span class="hljs-string">&#x27;triggering nested component updates from render is not allowed. &#x27;</span> + <span class="hljs-string">&#x27;If necessary, trigger nested updates in componentDidUpdate.\n\n&#x27;</span> + <span class="hljs-string">&#x27;Check the render method of %s.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(current.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;Unknown&#x27;</span>);
      }
    }

    <span class="hljs-keyword">var</span> update = <span class="hljs-title function_">createUpdate</span>(eventTime, lane); <span class="hljs-comment">// Caution: React DevTools currently depends on this property</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1219">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1219">&#x00a7;</a>
              </div>
              <p>being called “element”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
    update.<span class="hljs-property">payload</span> = {
      <span class="hljs-attr">element</span>: element
    };
    callback = callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback;

    <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span>) {
      {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render(...): Expected the last optional `callback` argument to be a &#x27;</span> + <span class="hljs-string">&#x27;function. Instead received: %s.&#x27;</span>, callback);
        }
      }

      update.<span class="hljs-property">callback</span> = callback;
    }

    <span class="hljs-title function_">enqueueUpdate</span>(current$<span class="hljs-number">1</span>, update);
    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(current$<span class="hljs-number">1</span>, lane, eventTime);
    <span class="hljs-keyword">return</span> lane;
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getPublicRootInstance</span>(<span class="hljs-params">container</span>) {
    <span class="hljs-keyword">var</span> containerFiber = container.<span class="hljs-property">current</span>;

    <span class="hljs-keyword">if</span> (!containerFiber.<span class="hljs-property">child</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">switch</span> (containerFiber.<span class="hljs-property">child</span>.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostComponent</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPublicInstance</span>(containerFiber.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>);

      <span class="hljs-attr">default</span>:
        <span class="hljs-keyword">return</span> containerFiber.<span class="hljs-property">child</span>.<span class="hljs-property">stateNode</span>;
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptSynchronousHydration$1</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">switch</span> (fiber.<span class="hljs-property">tag</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-title class_">HostRoot</span>:
        <span class="hljs-keyword">var</span> root = fiber.<span class="hljs-property">stateNode</span>;

        <span class="hljs-keyword">if</span> (root.<span class="hljs-property">hydrate</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1220">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1220">&#x00a7;</a>
              </div>
              <p>Flush the first scheduled “update”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">var</span> lanes = <span class="hljs-title function_">getHighestPriorityPendingLanes</span>(root);
          <span class="hljs-title function_">flushRoot</span>(root, lanes);
        }

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-title class_">SuspenseComponent</span>:
        <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
        <span class="hljs-title function_">flushSync</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, eventTime);
        }); <span class="hljs-comment">// If we&#x27;re still blocked after this, we need to increase</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1221">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1221">&#x00a7;</a>
              </div>
              <p>the priority of any promises resolving within this
boundary so that they next attempt also has higher pri.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        <span class="hljs-keyword">var</span> retryLane = <span class="hljs-title class_">InputDiscreteHydrationLane</span>;
        <span class="hljs-title function_">markRetryLaneIfNotHydrated</span>(fiber, retryLane);
        <span class="hljs-keyword">break</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRetryLaneImpl</span>(<span class="hljs-params">fiber, retryLane</span>) {
    <span class="hljs-keyword">var</span> suspenseState = fiber.<span class="hljs-property">memoizedState</span>;

    <span class="hljs-keyword">if</span> (suspenseState !== <span class="hljs-literal">null</span> &amp;&amp; suspenseState.<span class="hljs-property">dehydrated</span> !== <span class="hljs-literal">null</span>) {
      suspenseState.<span class="hljs-property">retryLane</span> = <span class="hljs-title function_">higherPriorityLane</span>(suspenseState.<span class="hljs-property">retryLane</span>, retryLane);
    }
  } <span class="hljs-comment">// Increases the priority of thennables when they resolve within this boundary.</span>


  <span class="hljs-keyword">function</span> <span class="hljs-title function_">markRetryLaneIfNotHydrated</span>(<span class="hljs-params">fiber, retryLane</span>) {
    <span class="hljs-title function_">markRetryLaneImpl</span>(fiber, retryLane);
    <span class="hljs-keyword">var</span> alternate = fiber.<span class="hljs-property">alternate</span>;

    <span class="hljs-keyword">if</span> (alternate) {
      <span class="hljs-title function_">markRetryLaneImpl</span>(alternate, retryLane);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptUserBlockingHydration$1</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">SuspenseComponent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1222">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1222">&#x00a7;</a>
              </div>
              <p>We ignore HostRoots here because we can’t increase
their priority and they should not suspend on I/O,
since you have to wrap anything that might suspend in
Suspense.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
    <span class="hljs-keyword">var</span> lane = <span class="hljs-title class_">InputDiscreteHydrationLane</span>;
    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);
    <span class="hljs-title function_">markRetryLaneIfNotHydrated</span>(fiber, lane);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptContinuousHydration$1</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">SuspenseComponent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1223">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1223">&#x00a7;</a>
              </div>
              <p>We ignore HostRoots here because we can’t increase
their priority and they should not suspend on I/O,
since you have to wrap anything that might suspend in
Suspense.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
    <span class="hljs-keyword">var</span> lane = <span class="hljs-title class_">SelectiveHydrationLane</span>;
    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);
    <span class="hljs-title function_">markRetryLaneIfNotHydrated</span>(fiber, lane);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptHydrationAtCurrentPriority$1</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">tag</span> !== <span class="hljs-title class_">SuspenseComponent</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1224">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1224">&#x00a7;</a>
              </div>
              <p>We ignore HostRoots here because we can’t increase
their priority other than synchronously flush it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> eventTime = <span class="hljs-title function_">requestEventTime</span>();
    <span class="hljs-keyword">var</span> lane = <span class="hljs-title function_">requestUpdateLane</span>(fiber);
    <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);
    <span class="hljs-title function_">markRetryLaneIfNotHydrated</span>(fiber, lane);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">runWithPriority$2</span>(<span class="hljs-params">priority, fn</span>) {
    <span class="hljs-keyword">var</span> previousPriority = <span class="hljs-title function_">getCurrentUpdateLanePriority</span>();

    <span class="hljs-keyword">try</span> {
      <span class="hljs-title function_">setCurrentUpdateLanePriority</span>(priority);
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>();
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-title function_">setCurrentUpdateLanePriority</span>(previousPriority);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findHostInstanceWithNoPortals</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> hostFiber = <span class="hljs-title function_">findCurrentHostFiberWithNoPortals</span>(fiber);

    <span class="hljs-keyword">if</span> (hostFiber === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (hostFiber.<span class="hljs-property">tag</span> === <span class="hljs-title class_">FundamentalComponent</span>) {
      <span class="hljs-keyword">return</span> hostFiber.<span class="hljs-property">stateNode</span>.<span class="hljs-property">instance</span>;
    }

    <span class="hljs-keyword">return</span> hostFiber.<span class="hljs-property">stateNode</span>;
  }

  <span class="hljs-keyword">var</span> shouldSuspendImpl = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldSuspend</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">shouldSuspendImpl</span>(fiber);
  }
  <span class="hljs-keyword">var</span> overrideHookState = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> overrideHookStateDeletePath = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> overrideHookStateRenamePath = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> overrideProps = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> overridePropsDeletePath = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> overridePropsRenamePath = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> scheduleUpdate = <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">var</span> setSuspenseHandler = <span class="hljs-literal">null</span>;

  {
    <span class="hljs-keyword">var</span> copyWithDeleteImpl = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, path, index</span>) {
      <span class="hljs-keyword">var</span> key = path[index];
      <span class="hljs-keyword">var</span> updated = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? obj.<span class="hljs-title function_">slice</span>() : <span class="hljs-title function_">_assign</span>({}, obj);

      <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> === path.<span class="hljs-property">length</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(updated)) {
          updated.<span class="hljs-title function_">splice</span>(key, <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">delete</span> updated[key];
        }

        <span class="hljs-keyword">return</span> updated;
      } <span class="hljs-comment">// $FlowFixMe number or string is fine here</span>


      updated[key] = <span class="hljs-title function_">copyWithDeleteImpl</span>(obj[key], path, index + <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> updated;
    };

    <span class="hljs-keyword">var</span> copyWithDelete = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, path</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">copyWithDeleteImpl</span>(obj, path, <span class="hljs-number">0</span>);
    };

    <span class="hljs-keyword">var</span> copyWithRenameImpl = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, oldPath, newPath, index</span>) {
      <span class="hljs-keyword">var</span> oldKey = oldPath[index];
      <span class="hljs-keyword">var</span> updated = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? obj.<span class="hljs-title function_">slice</span>() : <span class="hljs-title function_">_assign</span>({}, obj);

      <span class="hljs-keyword">if</span> (index + <span class="hljs-number">1</span> === oldPath.<span class="hljs-property">length</span>) {
        <span class="hljs-keyword">var</span> newKey = newPath[index]; <span class="hljs-comment">// $FlowFixMe number or string is fine here</span>

        updated[newKey] = updated[oldKey];

        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(updated)) {
          updated.<span class="hljs-title function_">splice</span>(oldKey, <span class="hljs-number">1</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">delete</span> updated[oldKey];
        }
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-1225">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1225">&#x00a7;</a>
              </div>
              <p>$FlowFixMe number or string is fine here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        updated[oldKey] = <span class="hljs-title function_">copyWithRenameImpl</span>( <span class="hljs-comment">// $FlowFixMe number or string is fine here</span>
          obj[oldKey], oldPath, newPath, index + <span class="hljs-number">1</span>);
      }

      <span class="hljs-keyword">return</span> updated;
    };

    <span class="hljs-keyword">var</span> copyWithRename = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, oldPath, newPath</span>) {
      <span class="hljs-keyword">if</span> (oldPath.<span class="hljs-property">length</span> !== newPath.<span class="hljs-property">length</span>) {
        <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;copyWithRename() expects paths of the same length&#x27;</span>);

        <span class="hljs-keyword">return</span>;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; newPath.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i++) {
          <span class="hljs-keyword">if</span> (oldPath[i] !== newPath[i]) {
            <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;copyWithRename() expects paths to be the same except for the deepest key&#x27;</span>);

            <span class="hljs-keyword">return</span>;
          }
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-title function_">copyWithRenameImpl</span>(obj, oldPath, newPath, <span class="hljs-number">0</span>);
    };

    <span class="hljs-keyword">var</span> copyWithSetImpl = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, path, index, value</span>) {
      <span class="hljs-keyword">if</span> (index &gt;= path.<span class="hljs-property">length</span>) {
        <span class="hljs-keyword">return</span> value;
      }

      <span class="hljs-keyword">var</span> key = path[index];
      <span class="hljs-keyword">var</span> updated = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(obj) ? obj.<span class="hljs-title function_">slice</span>() : <span class="hljs-title function_">_assign</span>({}, obj); <span class="hljs-comment">// $FlowFixMe number or string is fine here</span>

      updated[key] = <span class="hljs-title function_">copyWithSetImpl</span>(obj[key], path, index + <span class="hljs-number">1</span>, value);
      <span class="hljs-keyword">return</span> updated;
    };

    <span class="hljs-keyword">var</span> copyWithSet = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj, path, value</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">copyWithSetImpl</span>(obj, path, <span class="hljs-number">0</span>, value);
    };

    <span class="hljs-keyword">var</span> findHook = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, id</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1226">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1226">&#x00a7;</a>
              </div>
              <p>For now, the “id” of stateful hooks is just the stateful hook index.
This may change in the future with e.g. nested hooks.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> currentHook = fiber.<span class="hljs-property">memoizedState</span>;

      <span class="hljs-keyword">while</span> (currentHook !== <span class="hljs-literal">null</span> &amp;&amp; id &gt; <span class="hljs-number">0</span>) {
        currentHook = currentHook.<span class="hljs-property">next</span>;
        id--;
      }

      <span class="hljs-keyword">return</span> currentHook;
    }; <span class="hljs-comment">// Support DevTools editable values for useState and useReducer.</span>


    overrideHookState = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, id, path, value</span>) {
      <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">findHook</span>(fiber, id);

      <span class="hljs-keyword">if</span> (hook !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> newState = <span class="hljs-title function_">copyWithSet</span>(hook.<span class="hljs-property">memoizedState</span>, path, value);
        hook.<span class="hljs-property">memoizedState</span> = newState;
        hook.<span class="hljs-property">baseState</span> = newState; <span class="hljs-comment">// We aren&#x27;t actually adding an update to the queue,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1227">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1227">&#x00a7;</a>
              </div>
              <p>because there is no update we can add for useReducer hooks that won’t trigger an error.
(There’s no appropriate action type for DevTools overrides.)
As a result though, React will see the scheduled update as a noop and bailout.
Shallow cloning props works as a workaround for now to bypass the bailout check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        fiber.<span class="hljs-property">memoizedProps</span> = <span class="hljs-title function_">_assign</span>({}, fiber.<span class="hljs-property">memoizedProps</span>);
        <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
      }
    };

    overrideHookStateDeletePath = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, id, path</span>) {
      <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">findHook</span>(fiber, id);

      <span class="hljs-keyword">if</span> (hook !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> newState = <span class="hljs-title function_">copyWithDelete</span>(hook.<span class="hljs-property">memoizedState</span>, path);
        hook.<span class="hljs-property">memoizedState</span> = newState;
        hook.<span class="hljs-property">baseState</span> = newState; <span class="hljs-comment">// We aren&#x27;t actually adding an update to the queue,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1228">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1228">&#x00a7;</a>
              </div>
              <p>because there is no update we can add for useReducer hooks that won’t trigger an error.
(There’s no appropriate action type for DevTools overrides.)
As a result though, React will see the scheduled update as a noop and bailout.
Shallow cloning props works as a workaround for now to bypass the bailout check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        fiber.<span class="hljs-property">memoizedProps</span> = <span class="hljs-title function_">_assign</span>({}, fiber.<span class="hljs-property">memoizedProps</span>);
        <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
      }
    };

    overrideHookStateRenamePath = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, id, oldPath, newPath</span>) {
      <span class="hljs-keyword">var</span> hook = <span class="hljs-title function_">findHook</span>(fiber, id);

      <span class="hljs-keyword">if</span> (hook !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> newState = <span class="hljs-title function_">copyWithRename</span>(hook.<span class="hljs-property">memoizedState</span>, oldPath, newPath);
        hook.<span class="hljs-property">memoizedState</span> = newState;
        hook.<span class="hljs-property">baseState</span> = newState; <span class="hljs-comment">// We aren&#x27;t actually adding an update to the queue,</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1229">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1229">&#x00a7;</a>
              </div>
              <p>because there is no update we can add for useReducer hooks that won’t trigger an error.
(There’s no appropriate action type for DevTools overrides.)
As a result though, React will see the scheduled update as a noop and bailout.
Shallow cloning props works as a workaround for now to bypass the bailout check.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
        fiber.<span class="hljs-property">memoizedProps</span> = <span class="hljs-title function_">_assign</span>({}, fiber.<span class="hljs-property">memoizedProps</span>);
        <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
      }
    }; <span class="hljs-comment">// Support DevTools props for function components, forwardRef, memo, host components, etc.</span>


    overrideProps = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, path, value</span>) {
      fiber.<span class="hljs-property">pendingProps</span> = <span class="hljs-title function_">copyWithSet</span>(fiber.<span class="hljs-property">memoizedProps</span>, path, value);

      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">alternate</span>) {
        fiber.<span class="hljs-property">alternate</span>.<span class="hljs-property">pendingProps</span> = fiber.<span class="hljs-property">pendingProps</span>;
      }

      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
    };

    overridePropsDeletePath = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, path</span>) {
      fiber.<span class="hljs-property">pendingProps</span> = <span class="hljs-title function_">copyWithDelete</span>(fiber.<span class="hljs-property">memoizedProps</span>, path);

      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">alternate</span>) {
        fiber.<span class="hljs-property">alternate</span>.<span class="hljs-property">pendingProps</span> = fiber.<span class="hljs-property">pendingProps</span>;
      }

      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
    };

    overridePropsRenamePath = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber, oldPath, newPath</span>) {
      fiber.<span class="hljs-property">pendingProps</span> = <span class="hljs-title function_">copyWithRename</span>(fiber.<span class="hljs-property">memoizedProps</span>, oldPath, newPath);

      <span class="hljs-keyword">if</span> (fiber.<span class="hljs-property">alternate</span>) {
        fiber.<span class="hljs-property">alternate</span>.<span class="hljs-property">pendingProps</span> = fiber.<span class="hljs-property">pendingProps</span>;
      }

      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
    };

    scheduleUpdate = <span class="hljs-keyword">function</span> (<span class="hljs-params">fiber</span>) {
      <span class="hljs-title function_">scheduleUpdateOnFiber</span>(fiber, <span class="hljs-title class_">SyncLane</span>, <span class="hljs-title class_">NoTimestamp</span>);
    };

    setSuspenseHandler = <span class="hljs-keyword">function</span> (<span class="hljs-params">newShouldSuspendImpl</span>) {
      shouldSuspendImpl = newShouldSuspendImpl;
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findHostInstanceByFiber</span>(<span class="hljs-params">fiber</span>) {
    <span class="hljs-keyword">var</span> hostFiber = <span class="hljs-title function_">findCurrentHostFiber</span>(fiber);

    <span class="hljs-keyword">if</span> (hostFiber === <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> hostFiber.<span class="hljs-property">stateNode</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">emptyFindFiberByHostInstance</span>(<span class="hljs-params">instance</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getCurrentFiberForDevTools</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> current;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">injectIntoDevTools</span>(<span class="hljs-params">devToolsConfig</span>) {
    <span class="hljs-keyword">var</span> findFiberByHostInstance = devToolsConfig.<span class="hljs-property">findFiberByHostInstance</span>;
    <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentDispatcher</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentDispatcher</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">injectInternals</span>({
      <span class="hljs-attr">bundleType</span>: devToolsConfig.<span class="hljs-property">bundleType</span>,
      <span class="hljs-attr">version</span>: devToolsConfig.<span class="hljs-property">version</span>,
      <span class="hljs-attr">rendererPackageName</span>: devToolsConfig.<span class="hljs-property">rendererPackageName</span>,
      <span class="hljs-attr">rendererConfig</span>: devToolsConfig.<span class="hljs-property">rendererConfig</span>,
      <span class="hljs-attr">overrideHookState</span>: overrideHookState,
      <span class="hljs-attr">overrideHookStateDeletePath</span>: overrideHookStateDeletePath,
      <span class="hljs-attr">overrideHookStateRenamePath</span>: overrideHookStateRenamePath,
      <span class="hljs-attr">overrideProps</span>: overrideProps,
      <span class="hljs-attr">overridePropsDeletePath</span>: overridePropsDeletePath,
      <span class="hljs-attr">overridePropsRenamePath</span>: overridePropsRenamePath,
      <span class="hljs-attr">setSuspenseHandler</span>: setSuspenseHandler,
      <span class="hljs-attr">scheduleUpdate</span>: scheduleUpdate,
      <span class="hljs-attr">currentDispatcherRef</span>: <span class="hljs-title class_">ReactCurrentDispatcher</span>,
      <span class="hljs-attr">findHostInstanceByFiber</span>: findHostInstanceByFiber,
      <span class="hljs-attr">findFiberByHostInstance</span>: findFiberByHostInstance || emptyFindFiberByHostInstance,</pre></div></div>
            
        </li>
        
        
        <li id="section-1230">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1230">&#x00a7;</a>
              </div>
              <p>React Refresh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-attr">findHostInstancesForRefresh</span>: findHostInstancesForRefresh,
      <span class="hljs-attr">scheduleRefresh</span>: scheduleRefresh,
      <span class="hljs-attr">scheduleRoot</span>: scheduleRoot,
      <span class="hljs-attr">setRefreshHandler</span>: setRefreshHandler,</pre></div></div>
            
        </li>
        
        
        <li id="section-1231">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1231">&#x00a7;</a>
              </div>
              <p>Enables DevTools to append owner stacks to error messages in DEV mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-attr">getCurrentFiber</span>: getCurrentFiberForDevTools
    });
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ReactDOMRoot</span>(<span class="hljs-params">container, options</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span> = <span class="hljs-title function_">createRootImpl</span>(container, <span class="hljs-title class_">ConcurrentRoot</span>, options);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ReactDOMBlockingRoot</span>(<span class="hljs-params">container, tag, options</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span> = <span class="hljs-title function_">createRootImpl</span>(container, tag, options);
  }

  <span class="hljs-title class_">React</span>DOMRoot.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-title class_">React</span>DOMBlockingRoot.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">render</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">children</span>) {
    <span class="hljs-keyword">var</span> root = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span>;

    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render(...): does not support the second callback argument. &#x27;</span> + <span class="hljs-string">&#x27;To execute a side effect after rendering, declare it in a component body with useEffect().&#x27;</span>);
      }

      <span class="hljs-keyword">var</span> container = root.<span class="hljs-property">containerInfo</span>;

      <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> !== <span class="hljs-variable constant_">COMMENT_NODE</span>) {
        <span class="hljs-keyword">var</span> hostInstance = <span class="hljs-title function_">findHostInstanceWithNoPortals</span>(root.<span class="hljs-property">current</span>);

        <span class="hljs-keyword">if</span> (hostInstance) {
          <span class="hljs-keyword">if</span> (hostInstance.<span class="hljs-property">parentNode</span> !== container) {
            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render(...): It looks like the React-rendered content of the &#x27;</span> + <span class="hljs-string">&#x27;root container was removed without using React. This is not &#x27;</span> + <span class="hljs-string">&#x27;supported and will cause errors. Instead, call &#x27;</span> + <span class="hljs-string">&quot;root.unmount() to empty a root&#x27;s container.&quot;</span>);
          }
        }
      }
    }

    <span class="hljs-title function_">updateContainer</span>(children, root, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);
  };

  <span class="hljs-title class_">React</span>DOMRoot.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unmount</span> = <span class="hljs-title class_">React</span>DOMBlockingRoot.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">unmount</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;unmount(...): does not support a callback argument. &#x27;</span> + <span class="hljs-string">&#x27;To execute a side effect after rendering, declare it in a component body with useEffect().&#x27;</span>);
      }
    }

    <span class="hljs-keyword">var</span> root = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_internalRoot</span>;
    <span class="hljs-keyword">var</span> container = root.<span class="hljs-property">containerInfo</span>;
    <span class="hljs-title function_">updateContainer</span>(<span class="hljs-literal">null</span>, root, <span class="hljs-literal">null</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-title function_">unmarkContainerAsRoot</span>(container);
    });
  };

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRootImpl</span>(<span class="hljs-params">container, tag, options</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1232">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1232">&#x00a7;</a>
              </div>
              <p>Tag is either LegacyRoot or Concurrent Root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> hydrate = options != <span class="hljs-literal">null</span> &amp;&amp; options.<span class="hljs-property">hydrate</span> === <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> hydrationCallbacks = options != <span class="hljs-literal">null</span> &amp;&amp; options.<span class="hljs-property">hydrationOptions</span> || <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> mutableSources = options != <span class="hljs-literal">null</span> &amp;&amp; options.<span class="hljs-property">hydrationOptions</span> != <span class="hljs-literal">null</span> &amp;&amp; options.<span class="hljs-property">hydrationOptions</span>.<span class="hljs-property">mutableSources</span> || <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">var</span> root = <span class="hljs-title function_">createContainer</span>(container, tag, hydrate);
    <span class="hljs-title function_">markContainerAsRoot</span>(root.<span class="hljs-property">current</span>, container);
    <span class="hljs-keyword">var</span> containerNodeType = container.<span class="hljs-property">nodeType</span>;

    {
      <span class="hljs-keyword">var</span> rootContainerElement = container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span> ? container.<span class="hljs-property">parentNode</span> : container;
      <span class="hljs-title function_">listenToAllSupportedEvents</span>(rootContainerElement);
    }

    <span class="hljs-keyword">if</span> (mutableSources) {
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; mutableSources.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">var</span> mutableSource = mutableSources[i];
        <span class="hljs-title function_">registerMutableSourceForHydration</span>(root, mutableSource);
      }
    }

    <span class="hljs-keyword">return</span> root;
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createRoot</span>(<span class="hljs-params">container, options</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidContainer</span>(container)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;createRoot(...): Target container is not a DOM element.&quot;</span>);
      }
    }

    <span class="hljs-title function_">warnIfReactDOMContainerInDEV</span>(container);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">React</span>DOMRoot(container, options);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createBlockingRoot</span>(<span class="hljs-params">container, options</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidContainer</span>(container)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;createRoot(...): Target container is not a DOM element.&quot;</span>);
      }
    }

    <span class="hljs-title function_">warnIfReactDOMContainerInDEV</span>(container);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">React</span>DOMBlockingRoot(container, <span class="hljs-title class_">BlockingRoot</span>, options);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createLegacyRoot</span>(<span class="hljs-params">container, options</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">React</span>DOMBlockingRoot(container, <span class="hljs-title class_">LegacyRoot</span>, options);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">isValidContainer</span>(<span class="hljs-params">node</span>) {
    <span class="hljs-keyword">return</span> !!(node &amp;&amp; (node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span> || node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_NODE</span> || node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_FRAGMENT_NODE</span> || node.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">COMMENT_NODE</span> &amp;&amp; node.<span class="hljs-property">nodeValue</span> === <span class="hljs-string">&#x27; react-mount-point-unstable &#x27;</span>));
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnIfReactDOMContainerInDEV</span>(<span class="hljs-params">container</span>) {
    {
      <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span> &amp;&amp; container.<span class="hljs-property">tagName</span> &amp;&amp; container.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;BODY&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;createRoot(): Creating roots directly with document.body is &#x27;</span> + <span class="hljs-string">&#x27;discouraged, since its children are often manipulated by third-party &#x27;</span> + <span class="hljs-string">&#x27;scripts and browser extensions. This may lead to subtle &#x27;</span> + <span class="hljs-string">&#x27;reconciliation issues. Try using a container element created &#x27;</span> + <span class="hljs-string">&#x27;for your app.&#x27;</span>);
      }

      <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isContainerMarkedAsRoot</span>(container)) {
        <span class="hljs-keyword">if</span> (container.<span class="hljs-property">_reactRootContainer</span>) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;You are calling ReactDOM.createRoot() on a container that was previously &#x27;</span> + <span class="hljs-string">&#x27;passed to ReactDOM.render(). This is not supported.&#x27;</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;You are calling ReactDOM.createRoot() on a container that &#x27;</span> + <span class="hljs-string">&#x27;has already been passed to createRoot() before. Instead, call &#x27;</span> + <span class="hljs-string">&#x27;root.render() on the existing root instead if you want to update it.&#x27;</span>);
        }
      }
    }
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">3</span> = <span class="hljs-title class_">ReactSharedInternals</span>.<span class="hljs-property">ReactCurrentOwner</span>;
  <span class="hljs-keyword">var</span> topLevelUpdateWarnings;
  <span class="hljs-keyword">var</span> warnedAboutHydrateAPI = <span class="hljs-literal">false</span>;

  {
    topLevelUpdateWarnings = <span class="hljs-keyword">function</span> (<span class="hljs-params">container</span>) {
      <span class="hljs-keyword">if</span> (container.<span class="hljs-property">_reactRootContainer</span> &amp;&amp; container.<span class="hljs-property">nodeType</span> !== <span class="hljs-variable constant_">COMMENT_NODE</span>) {
        <span class="hljs-keyword">var</span> hostInstance = <span class="hljs-title function_">findHostInstanceWithNoPortals</span>(container.<span class="hljs-property">_reactRootContainer</span>.<span class="hljs-property">_internalRoot</span>.<span class="hljs-property">current</span>);

        <span class="hljs-keyword">if</span> (hostInstance) {
          <span class="hljs-keyword">if</span> (hostInstance.<span class="hljs-property">parentNode</span> !== container) {
            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render(...): It looks like the React-rendered content of this &#x27;</span> + <span class="hljs-string">&#x27;container was removed without using React. This is not &#x27;</span> + <span class="hljs-string">&#x27;supported and will cause errors. Instead, call &#x27;</span> + <span class="hljs-string">&#x27;ReactDOM.unmountComponentAtNode to empty a container.&#x27;</span>);
          }
        }
      }

      <span class="hljs-keyword">var</span> isRootRenderedBySomeReact = !!container.<span class="hljs-property">_reactRootContainer</span>;
      <span class="hljs-keyword">var</span> rootEl = <span class="hljs-title function_">getReactRootElementInContainer</span>(container);
      <span class="hljs-keyword">var</span> hasNonRootReactChild = !!(rootEl &amp;&amp; <span class="hljs-title function_">getInstanceFromNode</span>(rootEl));

      <span class="hljs-keyword">if</span> (hasNonRootReactChild &amp;&amp; !isRootRenderedBySomeReact) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render(...): Replacing React-rendered children with a new root &#x27;</span> + <span class="hljs-string">&#x27;component. If you intended to update the children of this node, &#x27;</span> + <span class="hljs-string">&#x27;you should instead have the existing children update their state &#x27;</span> + <span class="hljs-string">&#x27;and render the new components instead of calling ReactDOM.render.&#x27;</span>);
      }

      <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span> &amp;&amp; container.<span class="hljs-property">tagName</span> &amp;&amp; container.<span class="hljs-property">tagName</span>.<span class="hljs-title function_">toUpperCase</span>() === <span class="hljs-string">&#x27;BODY&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render(): Rendering components directly into document.body is &#x27;</span> + <span class="hljs-string">&#x27;discouraged, since its children are often manipulated by third-party &#x27;</span> + <span class="hljs-string">&#x27;scripts and browser extensions. This may lead to subtle &#x27;</span> + <span class="hljs-string">&#x27;reconciliation issues. Try rendering into a container element created &#x27;</span> + <span class="hljs-string">&#x27;for your app.&#x27;</span>);
      }
    };
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getReactRootElementInContainer</span>(<span class="hljs-params">container</span>) {
    <span class="hljs-keyword">if</span> (!container) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">DOCUMENT_NODE</span>) {
      <span class="hljs-keyword">return</span> container.<span class="hljs-property">documentElement</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> container.<span class="hljs-property">firstChild</span>;
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">shouldHydrateDueToLegacyHeuristic</span>(<span class="hljs-params">container</span>) {
    <span class="hljs-keyword">var</span> rootElement = <span class="hljs-title function_">getReactRootElementInContainer</span>(container);
    <span class="hljs-keyword">return</span> !!(rootElement &amp;&amp; rootElement.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span> &amp;&amp; rootElement.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-variable constant_">ROOT_ATTRIBUTE_NAME</span>));
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyCreateRootFromDOMContainer</span>(<span class="hljs-params">container, forceHydrate</span>) {
    <span class="hljs-keyword">var</span> shouldHydrate = forceHydrate || <span class="hljs-title function_">shouldHydrateDueToLegacyHeuristic</span>(container); <span class="hljs-comment">// First clear any existing content.</span>

    <span class="hljs-keyword">if</span> (!shouldHydrate) {
      <span class="hljs-keyword">var</span> warned = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> rootSibling;

      <span class="hljs-keyword">while</span> (rootSibling = container.<span class="hljs-property">lastChild</span>) {
        {
          <span class="hljs-keyword">if</span> (!warned &amp;&amp; rootSibling.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span> &amp;&amp; rootSibling.<span class="hljs-title function_">hasAttribute</span>(<span class="hljs-variable constant_">ROOT_ATTRIBUTE_NAME</span>)) {
            warned = <span class="hljs-literal">true</span>;

            <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render(): Target node has markup rendered by React, but there &#x27;</span> + <span class="hljs-string">&#x27;are unrelated nodes as well. This is most commonly caused by &#x27;</span> + <span class="hljs-string">&#x27;white-space inserted around server-rendered markup.&#x27;</span>);
          }
        }

        container.<span class="hljs-title function_">removeChild</span>(rootSibling);
      }
    }

    {
      <span class="hljs-keyword">if</span> (shouldHydrate &amp;&amp; !forceHydrate &amp;&amp; !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = <span class="hljs-literal">true</span>;

        <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;render(): Calling ReactDOM.render() to hydrate server-rendered markup &#x27;</span> + <span class="hljs-string">&#x27;will stop working in React v18. Replace the ReactDOM.render() call &#x27;</span> + <span class="hljs-string">&#x27;with ReactDOM.hydrate() if you want React to attach to the server HTML.&#x27;</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createLegacyRoot</span>(container, shouldHydrate ? {
      <span class="hljs-attr">hydrate</span>: <span class="hljs-literal">true</span>
    } : <span class="hljs-literal">undefined</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">warnOnInvalidCallback$1</span>(<span class="hljs-params">callback, callerName</span>) {
    {
      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> callback !== <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s(...): Expected the last optional `callback` argument to be a &#x27;</span> + <span class="hljs-string">&#x27;function. Instead received: %s.&#x27;</span>, callerName, callback);
      }
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(<span class="hljs-params">parentComponent, children, container, forceHydrate, callback</span>) {
    {
      <span class="hljs-title function_">topLevelUpdateWarnings</span>(container);
      <span class="hljs-title function_">warnOnInvalidCallback$1</span>(callback === <span class="hljs-literal">undefined</span> ? <span class="hljs-literal">null</span> : callback, <span class="hljs-string">&#x27;render&#x27;</span>);
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Without `any` type, Flow says &quot;Property cannot be accessed on any</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1233">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1233">&#x00a7;</a>
              </div>
              <p>member of intersection type.” Whyyyyyy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">var</span> root = container.<span class="hljs-property">_reactRootContainer</span>;
    <span class="hljs-keyword">var</span> fiberRoot;

    <span class="hljs-keyword">if</span> (!root) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1234">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1234">&#x00a7;</a>
              </div>
              <p>Initial mount</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      root = container.<span class="hljs-property">_reactRootContainer</span> = <span class="hljs-title function_">legacyCreateRootFromDOMContainer</span>(container, forceHydrate);
      fiberRoot = root.<span class="hljs-property">_internalRoot</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">var</span> originalCallback = callback;

        callback = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">var</span> instance = <span class="hljs-title function_">getPublicRootInstance</span>(fiberRoot);
          originalCallback.<span class="hljs-title function_">call</span>(instance);
        };
      } <span class="hljs-comment">// Initial mount should not be batched.</span>


      <span class="hljs-title function_">unbatchedUpdates</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);
      });
    } <span class="hljs-keyword">else</span> {
      fiberRoot = root.<span class="hljs-property">_internalRoot</span>;

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) {
        <span class="hljs-keyword">var</span> _originalCallback = callback;

        callback = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
          <span class="hljs-keyword">var</span> instance = <span class="hljs-title function_">getPublicRootInstance</span>(fiberRoot);

          _originalCallback.<span class="hljs-title function_">call</span>(instance);
        };
      } <span class="hljs-comment">// Update</span>


      <span class="hljs-title function_">updateContainer</span>(children, fiberRoot, parentComponent, callback);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getPublicRootInstance</span>(fiberRoot);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">findDOMNode</span>(<span class="hljs-params">componentOrElement</span>) {
    {
      <span class="hljs-keyword">var</span> owner = <span class="hljs-title class_">ReactCurrentOwner</span>$<span class="hljs-number">3.</span>current;

      <span class="hljs-keyword">if</span> (owner !== <span class="hljs-literal">null</span> &amp;&amp; owner.<span class="hljs-property">stateNode</span> !== <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">var</span> warnedAboutRefsInRender = owner.<span class="hljs-property">stateNode</span>.<span class="hljs-property">_warnedAboutRefsInRender</span>;

        <span class="hljs-keyword">if</span> (!warnedAboutRefsInRender) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;%s is accessing findDOMNode inside its render(). &#x27;</span> + <span class="hljs-string">&#x27;render() should be a pure function of props and state. It should &#x27;</span> + <span class="hljs-string">&#x27;never access something that requires stale data from the previous &#x27;</span> + <span class="hljs-string">&#x27;render, such as refs. Move this logic to componentDidMount and &#x27;</span> + <span class="hljs-string">&#x27;componentDidUpdate instead.&#x27;</span>, <span class="hljs-title function_">getComponentName</span>(owner.<span class="hljs-property">type</span>) || <span class="hljs-string">&#x27;A component&#x27;</span>);
        }

        owner.<span class="hljs-property">stateNode</span>.<span class="hljs-property">_warnedAboutRefsInRender</span> = <span class="hljs-literal">true</span>;
      }
    }

    <span class="hljs-keyword">if</span> (componentOrElement == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">if</span> (componentOrElement.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span>) {
      <span class="hljs-keyword">return</span> componentOrElement;
    }

    {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">findHostInstanceWithWarning</span>(componentOrElement, <span class="hljs-string">&#x27;findDOMNode&#x27;</span>);
    }
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">hydrate</span>(<span class="hljs-params">element, container, callback</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidContainer</span>(container)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Target container is not a DOM element.&quot;</span>);
      }
    }

    {
      <span class="hljs-keyword">var</span> isModernRoot = <span class="hljs-title function_">isContainerMarkedAsRoot</span>(container) &amp;&amp; container.<span class="hljs-property">_reactRootContainer</span> === <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">if</span> (isModernRoot) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;You are calling ReactDOM.hydrate() on a container that was previously &#x27;</span> + <span class="hljs-string">&#x27;passed to ReactDOM.createRoot(). This is not supported. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean to call createRoot(container, {hydrate: true}).render(element)?&#x27;</span>);
      }
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> throw or warn if we couldn&#x27;t hydrate?</span>


    <span class="hljs-keyword">return</span> <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(<span class="hljs-literal">null</span>, element, container, <span class="hljs-literal">true</span>, callback);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">element, container, callback</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidContainer</span>(container)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Target container is not a DOM element.&quot;</span>);
      }
    }

    {
      <span class="hljs-keyword">var</span> isModernRoot = <span class="hljs-title function_">isContainerMarkedAsRoot</span>(container) &amp;&amp; container.<span class="hljs-property">_reactRootContainer</span> === <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">if</span> (isModernRoot) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;You are calling ReactDOM.render() on a container that was previously &#x27;</span> + <span class="hljs-string">&#x27;passed to ReactDOM.createRoot(). This is not supported. &#x27;</span> + <span class="hljs-string">&#x27;Did you mean to call root.render(element)?&#x27;</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(<span class="hljs-literal">null</span>, element, container, <span class="hljs-literal">false</span>, callback);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unstable_renderSubtreeIntoContainer</span>(<span class="hljs-params">parentComponent, element, containerNode, callback</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidContainer</span>(containerNode)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Target container is not a DOM element.&quot;</span>);
      }
    }

    <span class="hljs-keyword">if</span> (!(parentComponent != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-title function_">has</span>(parentComponent))) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;parentComponent must be a valid React Component&quot;</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(parentComponent, element, containerNode, <span class="hljs-literal">false</span>, callback);
  }
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unmountComponentAtNode</span>(<span class="hljs-params">container</span>) {
    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidContainer</span>(container)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;unmountComponentAtNode(...): Target container is not a DOM element.&quot;</span>);
      }
    }

    {
      <span class="hljs-keyword">var</span> isModernRoot = <span class="hljs-title function_">isContainerMarkedAsRoot</span>(container) &amp;&amp; container.<span class="hljs-property">_reactRootContainer</span> === <span class="hljs-literal">undefined</span>;

      <span class="hljs-keyword">if</span> (isModernRoot) {
        <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;You are calling ReactDOM.unmountComponentAtNode() on a container that was previously &#x27;</span> + <span class="hljs-string">&#x27;passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?&#x27;</span>);
      }
    }

    <span class="hljs-keyword">if</span> (container.<span class="hljs-property">_reactRootContainer</span>) {
      {
        <span class="hljs-keyword">var</span> rootEl = <span class="hljs-title function_">getReactRootElementInContainer</span>(container);
        <span class="hljs-keyword">var</span> renderedByDifferentReact = rootEl &amp;&amp; !<span class="hljs-title function_">getInstanceFromNode</span>(rootEl);

        <span class="hljs-keyword">if</span> (renderedByDifferentReact) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;unmountComponentAtNode(): The node you&#x27;re attempting to unmount &quot;</span> + <span class="hljs-string">&#x27;was rendered by another copy of React.&#x27;</span>);
        }
      } <span class="hljs-comment">// Unmount should not be batched.</span>


      <span class="hljs-title function_">unbatchedUpdates</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">legacyRenderSubtreeIntoContainer</span>(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, container, <span class="hljs-literal">false</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1235">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1235">&#x00a7;</a>
              </div>
              <p>$FlowFixMe This should probably use <code>delete container._reactRootContainer</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          container.<span class="hljs-property">_reactRootContainer</span> = <span class="hljs-literal">null</span>;
          <span class="hljs-title function_">unmarkContainerAsRoot</span>(container);
        });
      }); <span class="hljs-comment">// If you call unmountComponentAtNode twice in quick succession, you&#x27;ll</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1236">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1236">&#x00a7;</a>
              </div>
              <p>get <code>true</code> twice. That’s probably fine?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    } <span class="hljs-keyword">else</span> {
      {
        <span class="hljs-keyword">var</span> _rootEl = <span class="hljs-title function_">getReactRootElementInContainer</span>(container);

        <span class="hljs-keyword">var</span> hasNonRootReactChild = !!(_rootEl &amp;&amp; <span class="hljs-title function_">getInstanceFromNode</span>(_rootEl)); <span class="hljs-comment">// Check if the container itself is a React root node.</span>

        <span class="hljs-keyword">var</span> isContainerReactRoot = container.<span class="hljs-property">nodeType</span> === <span class="hljs-variable constant_">ELEMENT_NODE</span> &amp;&amp; <span class="hljs-title function_">isValidContainer</span>(container.<span class="hljs-property">parentNode</span>) &amp;&amp; !!container.<span class="hljs-property">parentNode</span>.<span class="hljs-property">_reactRootContainer</span>;

        <span class="hljs-keyword">if</span> (hasNonRootReactChild) {
          <span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;unmountComponentAtNode(): The node you&#x27;re attempting to unmount &quot;</span> + <span class="hljs-string">&#x27;was rendered by React and is not a top-level container. %s&#x27;</span>, isContainerReactRoot ? <span class="hljs-string">&#x27;You may have accidentally passed in a React root node instead &#x27;</span> + <span class="hljs-string">&#x27;of its container.&#x27;</span> : <span class="hljs-string">&#x27;Instead, have the parent component update its state and &#x27;</span> + <span class="hljs-string">&#x27;rerender in order to remove this component.&#x27;</span>);
        }
      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
  }

  <span class="hljs-title function_">setAttemptSynchronousHydration</span>(attemptSynchronousHydration$<span class="hljs-number">1</span>);
  <span class="hljs-title function_">setAttemptUserBlockingHydration</span>(attemptUserBlockingHydration$<span class="hljs-number">1</span>);
  <span class="hljs-title function_">setAttemptContinuousHydration</span>(attemptContinuousHydration$<span class="hljs-number">1</span>);
  <span class="hljs-title function_">setAttemptHydrationAtCurrentPriority</span>(attemptHydrationAtCurrentPriority$<span class="hljs-number">1</span>);
  <span class="hljs-title function_">setGetCurrentUpdatePriority</span>(getCurrentUpdateLanePriority);
  <span class="hljs-title function_">setAttemptHydrationAtPriority</span>(runWithPriority$<span class="hljs-number">2</span>);
  <span class="hljs-keyword">var</span> didWarnAboutUnstableCreatePortal = <span class="hljs-literal">false</span>;

  {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Map</span> !== <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-comment">// $FlowIssue Flow incorrectly thinks Map has no prototype</span>
      <span class="hljs-title class_">Map</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Map</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span> !== <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Set</span> !== <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-comment">// $FlowIssue Flow incorrectly thinks Set has no prototype</span>
      <span class="hljs-title class_">Set</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Set</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">clear</span> !== <span class="hljs-string">&#x27;function&#x27;</span> || <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Set</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;React depends on Map and Set built-in types. Make sure that you load a &#x27;</span> + <span class="hljs-string">&#x27;polyfill in older browsers. https://reactjs.org/link/react-polyfills&#x27;</span>);
    }
  }

  <span class="hljs-title function_">setRestoreImplementation</span>(restoreControlledState$<span class="hljs-number">3</span>);
  <span class="hljs-title function_">setBatchingImplementation</span>(batchedUpdates$<span class="hljs-number">1</span>, discreteUpdates$<span class="hljs-number">1</span>, flushDiscreteUpdates, batchedEventUpdates$<span class="hljs-number">1</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPortal$1</span>(<span class="hljs-params">children, container</span>) {
    <span class="hljs-keyword">var</span> key = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>] : <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isValidContainer</span>(container)) {
      {
        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Target container is not a DOM element.&quot;</span>);
      }
    } <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> pass ReactDOM portal implementation as third argument</span></pre></div></div>
            
        </li>
        
        
        <li id="section-1237">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1237">&#x00a7;</a>
              </div>
              <p>$FlowFixMe The Flow type is opaque but there’s no way to actually create it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createPortal</span>(children, container, <span class="hljs-literal">null</span>, key);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">scheduleHydration</span>(<span class="hljs-params">target</span>) {
    <span class="hljs-keyword">if</span> (target) {
      <span class="hljs-title function_">queueExplicitHydrationTarget</span>(target);
    }
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderSubtreeIntoContainer</span>(<span class="hljs-params">parentComponent, element, containerNode, callback</span>) {

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">unstable_renderSubtreeIntoContainer</span>(parentComponent, element, containerNode, callback);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">unstable_createPortal</span>(<span class="hljs-params">children, container</span>) {
    <span class="hljs-keyword">var</span> key = <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>] !== <span class="hljs-literal">undefined</span> ? <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>] : <span class="hljs-literal">null</span>;

    {
      <span class="hljs-keyword">if</span> (!didWarnAboutUnstableCreatePortal) {
        didWarnAboutUnstableCreatePortal = <span class="hljs-literal">true</span>;

        <span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;The ReactDOM.unstable_createPortal() alias has been deprecated, &#x27;</span> + <span class="hljs-string">&#x27;and will be removed in React 18+. Update your code to use &#x27;</span> + <span class="hljs-string">&#x27;ReactDOM.createPortal() instead. It has the exact same API, &#x27;</span> + <span class="hljs-string">&#x27;but without the &quot;unstable_&quot; prefix.&#x27;</span>);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-title function_">createPortal$1</span>(children, container, key);
  }

  <span class="hljs-keyword">var</span> <span class="hljs-title class_">Internals</span> = {</pre></div></div>
            
        </li>
        
        
        <li id="section-1238">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1238">&#x00a7;</a>
              </div>
              <p>Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
This is an array for better minification.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-title class_">Events</span>: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, flushPassiveEffects, <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> This is related to `act`, not events. Move to separate key?</span>
      <span class="hljs-title class_">IsThisRendererActing</span>]
  };
  <span class="hljs-keyword">var</span> foundDevTools = <span class="hljs-title function_">injectIntoDevTools</span>({
    <span class="hljs-attr">findFiberByHostInstance</span>: getClosestInstanceFromNode,
    <span class="hljs-attr">bundleType</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">version</span>: <span class="hljs-title class_">ReactVersion</span>,
    <span class="hljs-attr">rendererPackageName</span>: <span class="hljs-string">&#x27;react-dom&#x27;</span>
  });

  {
    <span class="hljs-keyword">if</span> (!foundDevTools &amp;&amp; canUseDOM &amp;&amp; <span class="hljs-variable language_">window</span>.<span class="hljs-property">top</span> === <span class="hljs-variable language_">window</span>.<span class="hljs-property">self</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1239">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1239">&#x00a7;</a>
              </div>
              <p>If we’re in Chrome or Firefox, provide a download link if not installed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (navigator.<span class="hljs-property">userAgent</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Chrome&#x27;</span>) &gt; -<span class="hljs-number">1</span> &amp;&amp; navigator.<span class="hljs-property">userAgent</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Edge&#x27;</span>) === -<span class="hljs-number">1</span> || navigator.<span class="hljs-property">userAgent</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;Firefox&#x27;</span>) &gt; -<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">var</span> protocol = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">protocol</span>; <span class="hljs-comment">// Don&#x27;t warn in exotic cases like chrome-extension://.</span>

        <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^(https?|file):$/</span>.<span class="hljs-title function_">test</span>(protocol)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-1240">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1240">&#x00a7;</a>
              </div>
              <p>eslint-disable-next-line react-internal/no-production-logging</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;%cDownload the React DevTools &#x27;</span> + <span class="hljs-string">&#x27;for a better development experience: &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/react-devtools&#x27;</span> + (protocol === <span class="hljs-string">&#x27;file:&#x27;</span> ? <span class="hljs-string">&#x27;\nYou might need to use a local HTTP server (instead of file://): &#x27;</span> + <span class="hljs-string">&#x27;https://reactjs.org/link/react-devtools-faq&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>), <span class="hljs-string">&#x27;font-weight:bold&#x27;</span>);
        }
      }
    }
  }

  <span class="hljs-built_in">exports</span>.<span class="hljs-property">__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</span> = <span class="hljs-title class_">Internals</span>;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">createPortal</span> = createPortal$<span class="hljs-number">1</span>;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">findDOMNode</span> = findDOMNode;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">flushSync</span> = flushSync;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">hydrate</span> = hydrate;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">render</span> = render;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unmountComponentAtNode</span> = unmountComponentAtNode;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_batchedUpdates</span> = batchedUpdates$<span class="hljs-number">1</span>;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_createBlockingRoot</span> = createBlockingRoot;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_createPortal</span> = unstable_createPortal;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_createRoot</span> = createRoot;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_flushControlled</span> = flushControlled;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_renderSubtreeIntoContainer</span> = renderSubtreeIntoContainer;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_runWithPriority</span> = runWithPriority$<span class="hljs-number">2</span>;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">unstable_scheduleHydration</span> = scheduleHydration;
  <span class="hljs-built_in">exports</span>.<span class="hljs-property">version</span> = <span class="hljs-title class_">ReactVersion</span>;

})));</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
